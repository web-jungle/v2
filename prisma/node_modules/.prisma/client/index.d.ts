
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Collaborateur
 * 
 */
export type Collaborateur = $Result.DefaultSelection<Prisma.$CollaborateurPayload>
/**
 * Model Compte
 * 
 */
export type Compte = $Result.DefaultSelection<Prisma.$ComptePayload>
/**
 * Model Evenement
 * 
 */
export type Evenement = $Result.DefaultSelection<Prisma.$EvenementPayload>
/**
 * Model Salarie
 * 
 */
export type Salarie = $Result.DefaultSelection<Prisma.$SalariePayload>
/**
 * Model Vehicule
 * 
 */
export type Vehicule = $Result.DefaultSelection<Prisma.$VehiculePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model DemandeConge
 * 
 */
export type DemandeConge = $Result.DefaultSelection<Prisma.$DemandeCongePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ContratMaintenance
 * 
 */
export type ContratMaintenance = $Result.DefaultSelection<Prisma.$ContratMaintenancePayload>
/**
 * Model StockItem
 * 
 */
export type StockItem = $Result.DefaultSelection<Prisma.$StockItemPayload>
/**
 * Model FicheDePoste
 * 
 */
export type FicheDePoste = $Result.DefaultSelection<Prisma.$FicheDePostePayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RoleAdmin: {
  super_admin: 'super_admin',
  admin: 'admin',
  moderateur: 'moderateur'
};

export type RoleAdmin = (typeof RoleAdmin)[keyof typeof RoleAdmin]


export const Role: {
  admin: 'admin',
  manager: 'manager',
  collaborateur: 'collaborateur'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type RoleAdmin = $Enums.RoleAdmin

export const RoleAdmin: typeof $Enums.RoleAdmin

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Collaborateurs
 * const collaborateurs = await prisma.collaborateur.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Collaborateurs
   * const collaborateurs = await prisma.collaborateur.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.collaborateur`: Exposes CRUD operations for the **Collaborateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collaborateurs
    * const collaborateurs = await prisma.collaborateur.findMany()
    * ```
    */
  get collaborateur(): Prisma.CollaborateurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compte`: Exposes CRUD operations for the **Compte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comptes
    * const comptes = await prisma.compte.findMany()
    * ```
    */
  get compte(): Prisma.CompteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evenement`: Exposes CRUD operations for the **Evenement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evenements
    * const evenements = await prisma.evenement.findMany()
    * ```
    */
  get evenement(): Prisma.EvenementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salarie`: Exposes CRUD operations for the **Salarie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salaries
    * const salaries = await prisma.salarie.findMany()
    * ```
    */
  get salarie(): Prisma.SalarieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicule`: Exposes CRUD operations for the **Vehicule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicules
    * const vehicules = await prisma.vehicule.findMany()
    * ```
    */
  get vehicule(): Prisma.VehiculeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.demandeConge`: Exposes CRUD operations for the **DemandeConge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DemandeConges
    * const demandeConges = await prisma.demandeConge.findMany()
    * ```
    */
  get demandeConge(): Prisma.DemandeCongeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contratMaintenance`: Exposes CRUD operations for the **ContratMaintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContratMaintenances
    * const contratMaintenances = await prisma.contratMaintenance.findMany()
    * ```
    */
  get contratMaintenance(): Prisma.ContratMaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockItem`: Exposes CRUD operations for the **StockItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockItems
    * const stockItems = await prisma.stockItem.findMany()
    * ```
    */
  get stockItem(): Prisma.StockItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ficheDePoste`: Exposes CRUD operations for the **FicheDePoste** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FicheDePostes
    * const ficheDePostes = await prisma.ficheDePoste.findMany()
    * ```
    */
  get ficheDePoste(): Prisma.FicheDePosteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Collaborateur: 'Collaborateur',
    Compte: 'Compte',
    Evenement: 'Evenement',
    Salarie: 'Salarie',
    Vehicule: 'Vehicule',
    Contact: 'Contact',
    DemandeConge: 'DemandeConge',
    Notification: 'Notification',
    ContratMaintenance: 'ContratMaintenance',
    StockItem: 'StockItem',
    FicheDePoste: 'FicheDePoste',
    Admin: 'Admin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "collaborateur" | "compte" | "evenement" | "salarie" | "vehicule" | "contact" | "demandeConge" | "notification" | "contratMaintenance" | "stockItem" | "ficheDePoste" | "admin"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Collaborateur: {
        payload: Prisma.$CollaborateurPayload<ExtArgs>
        fields: Prisma.CollaborateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollaborateurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollaborateurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>
          }
          findFirst: {
            args: Prisma.CollaborateurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollaborateurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>
          }
          findMany: {
            args: Prisma.CollaborateurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>[]
          }
          create: {
            args: Prisma.CollaborateurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>
          }
          createMany: {
            args: Prisma.CollaborateurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollaborateurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>[]
          }
          delete: {
            args: Prisma.CollaborateurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>
          }
          update: {
            args: Prisma.CollaborateurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>
          }
          deleteMany: {
            args: Prisma.CollaborateurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollaborateurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollaborateurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>[]
          }
          upsert: {
            args: Prisma.CollaborateurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollaborateurPayload>
          }
          aggregate: {
            args: Prisma.CollaborateurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollaborateur>
          }
          groupBy: {
            args: Prisma.CollaborateurGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollaborateurGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollaborateurCountArgs<ExtArgs>
            result: $Utils.Optional<CollaborateurCountAggregateOutputType> | number
          }
        }
      }
      Compte: {
        payload: Prisma.$ComptePayload<ExtArgs>
        fields: Prisma.CompteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>
          }
          findFirst: {
            args: Prisma.CompteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>
          }
          findMany: {
            args: Prisma.CompteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>[]
          }
          create: {
            args: Prisma.CompteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>
          }
          createMany: {
            args: Prisma.CompteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>[]
          }
          delete: {
            args: Prisma.CompteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>
          }
          update: {
            args: Prisma.CompteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>
          }
          deleteMany: {
            args: Prisma.CompteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>[]
          }
          upsert: {
            args: Prisma.CompteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComptePayload>
          }
          aggregate: {
            args: Prisma.CompteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompte>
          }
          groupBy: {
            args: Prisma.CompteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompteCountArgs<ExtArgs>
            result: $Utils.Optional<CompteCountAggregateOutputType> | number
          }
        }
      }
      Evenement: {
        payload: Prisma.$EvenementPayload<ExtArgs>
        fields: Prisma.EvenementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvenementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvenementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          findFirst: {
            args: Prisma.EvenementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvenementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          findMany: {
            args: Prisma.EvenementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>[]
          }
          create: {
            args: Prisma.EvenementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          createMany: {
            args: Prisma.EvenementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvenementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>[]
          }
          delete: {
            args: Prisma.EvenementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          update: {
            args: Prisma.EvenementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          deleteMany: {
            args: Prisma.EvenementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvenementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvenementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>[]
          }
          upsert: {
            args: Prisma.EvenementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          aggregate: {
            args: Prisma.EvenementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvenement>
          }
          groupBy: {
            args: Prisma.EvenementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvenementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvenementCountArgs<ExtArgs>
            result: $Utils.Optional<EvenementCountAggregateOutputType> | number
          }
        }
      }
      Salarie: {
        payload: Prisma.$SalariePayload<ExtArgs>
        fields: Prisma.SalarieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalarieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalarieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>
          }
          findFirst: {
            args: Prisma.SalarieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalarieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>
          }
          findMany: {
            args: Prisma.SalarieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>[]
          }
          create: {
            args: Prisma.SalarieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>
          }
          createMany: {
            args: Prisma.SalarieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalarieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>[]
          }
          delete: {
            args: Prisma.SalarieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>
          }
          update: {
            args: Prisma.SalarieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>
          }
          deleteMany: {
            args: Prisma.SalarieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalarieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalarieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>[]
          }
          upsert: {
            args: Prisma.SalarieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalariePayload>
          }
          aggregate: {
            args: Prisma.SalarieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalarie>
          }
          groupBy: {
            args: Prisma.SalarieGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalarieGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalarieCountArgs<ExtArgs>
            result: $Utils.Optional<SalarieCountAggregateOutputType> | number
          }
        }
      }
      Vehicule: {
        payload: Prisma.$VehiculePayload<ExtArgs>
        fields: Prisma.VehiculeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehiculeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehiculeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>
          }
          findFirst: {
            args: Prisma.VehiculeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehiculeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>
          }
          findMany: {
            args: Prisma.VehiculeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>[]
          }
          create: {
            args: Prisma.VehiculeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>
          }
          createMany: {
            args: Prisma.VehiculeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehiculeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>[]
          }
          delete: {
            args: Prisma.VehiculeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>
          }
          update: {
            args: Prisma.VehiculeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>
          }
          deleteMany: {
            args: Prisma.VehiculeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehiculeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehiculeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>[]
          }
          upsert: {
            args: Prisma.VehiculeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculePayload>
          }
          aggregate: {
            args: Prisma.VehiculeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicule>
          }
          groupBy: {
            args: Prisma.VehiculeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiculeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehiculeCountArgs<ExtArgs>
            result: $Utils.Optional<VehiculeCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      DemandeConge: {
        payload: Prisma.$DemandeCongePayload<ExtArgs>
        fields: Prisma.DemandeCongeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DemandeCongeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DemandeCongeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>
          }
          findFirst: {
            args: Prisma.DemandeCongeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DemandeCongeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>
          }
          findMany: {
            args: Prisma.DemandeCongeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>[]
          }
          create: {
            args: Prisma.DemandeCongeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>
          }
          createMany: {
            args: Prisma.DemandeCongeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DemandeCongeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>[]
          }
          delete: {
            args: Prisma.DemandeCongeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>
          }
          update: {
            args: Prisma.DemandeCongeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>
          }
          deleteMany: {
            args: Prisma.DemandeCongeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DemandeCongeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DemandeCongeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>[]
          }
          upsert: {
            args: Prisma.DemandeCongeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DemandeCongePayload>
          }
          aggregate: {
            args: Prisma.DemandeCongeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDemandeConge>
          }
          groupBy: {
            args: Prisma.DemandeCongeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DemandeCongeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DemandeCongeCountArgs<ExtArgs>
            result: $Utils.Optional<DemandeCongeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ContratMaintenance: {
        payload: Prisma.$ContratMaintenancePayload<ExtArgs>
        fields: Prisma.ContratMaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContratMaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContratMaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>
          }
          findFirst: {
            args: Prisma.ContratMaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContratMaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>
          }
          findMany: {
            args: Prisma.ContratMaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>[]
          }
          create: {
            args: Prisma.ContratMaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>
          }
          createMany: {
            args: Prisma.ContratMaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContratMaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>[]
          }
          delete: {
            args: Prisma.ContratMaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>
          }
          update: {
            args: Prisma.ContratMaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>
          }
          deleteMany: {
            args: Prisma.ContratMaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContratMaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContratMaintenanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>[]
          }
          upsert: {
            args: Prisma.ContratMaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratMaintenancePayload>
          }
          aggregate: {
            args: Prisma.ContratMaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContratMaintenance>
          }
          groupBy: {
            args: Prisma.ContratMaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContratMaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContratMaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<ContratMaintenanceCountAggregateOutputType> | number
          }
        }
      }
      StockItem: {
        payload: Prisma.$StockItemPayload<ExtArgs>
        fields: Prisma.StockItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          findFirst: {
            args: Prisma.StockItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          findMany: {
            args: Prisma.StockItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>[]
          }
          create: {
            args: Prisma.StockItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          createMany: {
            args: Prisma.StockItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>[]
          }
          delete: {
            args: Prisma.StockItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          update: {
            args: Prisma.StockItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          deleteMany: {
            args: Prisma.StockItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>[]
          }
          upsert: {
            args: Prisma.StockItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          aggregate: {
            args: Prisma.StockItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockItem>
          }
          groupBy: {
            args: Prisma.StockItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockItemCountArgs<ExtArgs>
            result: $Utils.Optional<StockItemCountAggregateOutputType> | number
          }
        }
      }
      FicheDePoste: {
        payload: Prisma.$FicheDePostePayload<ExtArgs>
        fields: Prisma.FicheDePosteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FicheDePosteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FicheDePosteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>
          }
          findFirst: {
            args: Prisma.FicheDePosteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FicheDePosteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>
          }
          findMany: {
            args: Prisma.FicheDePosteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>[]
          }
          create: {
            args: Prisma.FicheDePosteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>
          }
          createMany: {
            args: Prisma.FicheDePosteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FicheDePosteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>[]
          }
          delete: {
            args: Prisma.FicheDePosteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>
          }
          update: {
            args: Prisma.FicheDePosteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>
          }
          deleteMany: {
            args: Prisma.FicheDePosteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FicheDePosteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FicheDePosteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>[]
          }
          upsert: {
            args: Prisma.FicheDePosteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FicheDePostePayload>
          }
          aggregate: {
            args: Prisma.FicheDePosteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFicheDePoste>
          }
          groupBy: {
            args: Prisma.FicheDePosteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FicheDePosteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FicheDePosteCountArgs<ExtArgs>
            result: $Utils.Optional<FicheDePosteCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    collaborateur?: CollaborateurOmit
    compte?: CompteOmit
    evenement?: EvenementOmit
    salarie?: SalarieOmit
    vehicule?: VehiculeOmit
    contact?: ContactOmit
    demandeConge?: DemandeCongeOmit
    notification?: NotificationOmit
    contratMaintenance?: ContratMaintenanceOmit
    stockItem?: StockItemOmit
    ficheDePoste?: FicheDePosteOmit
    admin?: AdminOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CollaborateurCountOutputType
   */

  export type CollaborateurCountOutputType = {
    evenements: number
    managersPar: number
    contactsGeres: number
    demandesConges: number
  }

  export type CollaborateurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evenements?: boolean | CollaborateurCountOutputTypeCountEvenementsArgs
    managersPar?: boolean | CollaborateurCountOutputTypeCountManagersParArgs
    contactsGeres?: boolean | CollaborateurCountOutputTypeCountContactsGeresArgs
    demandesConges?: boolean | CollaborateurCountOutputTypeCountDemandesCongesArgs
  }

  // Custom InputTypes
  /**
   * CollaborateurCountOutputType without action
   */
  export type CollaborateurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollaborateurCountOutputType
     */
    select?: CollaborateurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollaborateurCountOutputType without action
   */
  export type CollaborateurCountOutputTypeCountEvenementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementWhereInput
  }

  /**
   * CollaborateurCountOutputType without action
   */
  export type CollaborateurCountOutputTypeCountManagersParArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompteWhereInput
  }

  /**
   * CollaborateurCountOutputType without action
   */
  export type CollaborateurCountOutputTypeCountContactsGeresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * CollaborateurCountOutputType without action
   */
  export type CollaborateurCountOutputTypeCountDemandesCongesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DemandeCongeWhereInput
  }


  /**
   * Count Type CompteCountOutputType
   */

  export type CompteCountOutputType = {
    collaborateursGeres: number
    demandesConges: number
    contacts: number
    notifications: number
  }

  export type CompteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateursGeres?: boolean | CompteCountOutputTypeCountCollaborateursGeresArgs
    demandesConges?: boolean | CompteCountOutputTypeCountDemandesCongesArgs
    contacts?: boolean | CompteCountOutputTypeCountContactsArgs
    notifications?: boolean | CompteCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CompteCountOutputType without action
   */
  export type CompteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteCountOutputType
     */
    select?: CompteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompteCountOutputType without action
   */
  export type CompteCountOutputTypeCountCollaborateursGeresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollaborateurWhereInput
  }

  /**
   * CompteCountOutputType without action
   */
  export type CompteCountOutputTypeCountDemandesCongesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DemandeCongeWhereInput
  }

  /**
   * CompteCountOutputType without action
   */
  export type CompteCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * CompteCountOutputType without action
   */
  export type CompteCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    collaborateurs: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateurs?: boolean | ContactCountOutputTypeCountCollaborateursArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCollaborateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollaborateurWhereInput
  }


  /**
   * Count Type DemandeCongeCountOutputType
   */

  export type DemandeCongeCountOutputType = {
    notifications: number
  }

  export type DemandeCongeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | DemandeCongeCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * DemandeCongeCountOutputType without action
   */
  export type DemandeCongeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeCongeCountOutputType
     */
    select?: DemandeCongeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DemandeCongeCountOutputType without action
   */
  export type DemandeCongeCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Collaborateur
   */

  export type AggregateCollaborateur = {
    _count: CollaborateurCountAggregateOutputType | null
    _min: CollaborateurMinAggregateOutputType | null
    _max: CollaborateurMaxAggregateOutputType | null
  }

  export type CollaborateurMinAggregateOutputType = {
    id: string | null
    nom: string | null
    couleur: string | null
    entreprise: string | null
    aCompte: boolean | null
    createdAt: Date | null
  }

  export type CollaborateurMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    couleur: string | null
    entreprise: string | null
    aCompte: boolean | null
    createdAt: Date | null
  }

  export type CollaborateurCountAggregateOutputType = {
    id: number
    nom: number
    couleur: number
    entreprise: number
    aCompte: number
    createdAt: number
    _all: number
  }


  export type CollaborateurMinAggregateInputType = {
    id?: true
    nom?: true
    couleur?: true
    entreprise?: true
    aCompte?: true
    createdAt?: true
  }

  export type CollaborateurMaxAggregateInputType = {
    id?: true
    nom?: true
    couleur?: true
    entreprise?: true
    aCompte?: true
    createdAt?: true
  }

  export type CollaborateurCountAggregateInputType = {
    id?: true
    nom?: true
    couleur?: true
    entreprise?: true
    aCompte?: true
    createdAt?: true
    _all?: true
  }

  export type CollaborateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collaborateur to aggregate.
     */
    where?: CollaborateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborateurs to fetch.
     */
    orderBy?: CollaborateurOrderByWithRelationInput | CollaborateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollaborateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collaborateurs
    **/
    _count?: true | CollaborateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollaborateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollaborateurMaxAggregateInputType
  }

  export type GetCollaborateurAggregateType<T extends CollaborateurAggregateArgs> = {
        [P in keyof T & keyof AggregateCollaborateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollaborateur[P]>
      : GetScalarType<T[P], AggregateCollaborateur[P]>
  }




  export type CollaborateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollaborateurWhereInput
    orderBy?: CollaborateurOrderByWithAggregationInput | CollaborateurOrderByWithAggregationInput[]
    by: CollaborateurScalarFieldEnum[] | CollaborateurScalarFieldEnum
    having?: CollaborateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollaborateurCountAggregateInputType | true
    _min?: CollaborateurMinAggregateInputType
    _max?: CollaborateurMaxAggregateInputType
  }

  export type CollaborateurGroupByOutputType = {
    id: string
    nom: string
    couleur: string
    entreprise: string
    aCompte: boolean
    createdAt: Date
    _count: CollaborateurCountAggregateOutputType | null
    _min: CollaborateurMinAggregateOutputType | null
    _max: CollaborateurMaxAggregateOutputType | null
  }

  type GetCollaborateurGroupByPayload<T extends CollaborateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollaborateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollaborateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollaborateurGroupByOutputType[P]>
            : GetScalarType<T[P], CollaborateurGroupByOutputType[P]>
        }
      >
    >


  export type CollaborateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    couleur?: boolean
    entreprise?: boolean
    aCompte?: boolean
    createdAt?: boolean
    evenements?: boolean | Collaborateur$evenementsArgs<ExtArgs>
    compte?: boolean | Collaborateur$compteArgs<ExtArgs>
    managersPar?: boolean | Collaborateur$managersParArgs<ExtArgs>
    contactsGeres?: boolean | Collaborateur$contactsGeresArgs<ExtArgs>
    demandesConges?: boolean | Collaborateur$demandesCongesArgs<ExtArgs>
    salarie?: boolean | Collaborateur$salarieArgs<ExtArgs>
    ficheDePoste?: boolean | Collaborateur$ficheDePosteArgs<ExtArgs>
    _count?: boolean | CollaborateurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collaborateur"]>

  export type CollaborateurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    couleur?: boolean
    entreprise?: boolean
    aCompte?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["collaborateur"]>

  export type CollaborateurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    couleur?: boolean
    entreprise?: boolean
    aCompte?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["collaborateur"]>

  export type CollaborateurSelectScalar = {
    id?: boolean
    nom?: boolean
    couleur?: boolean
    entreprise?: boolean
    aCompte?: boolean
    createdAt?: boolean
  }

  export type CollaborateurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "couleur" | "entreprise" | "aCompte" | "createdAt", ExtArgs["result"]["collaborateur"]>
  export type CollaborateurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evenements?: boolean | Collaborateur$evenementsArgs<ExtArgs>
    compte?: boolean | Collaborateur$compteArgs<ExtArgs>
    managersPar?: boolean | Collaborateur$managersParArgs<ExtArgs>
    contactsGeres?: boolean | Collaborateur$contactsGeresArgs<ExtArgs>
    demandesConges?: boolean | Collaborateur$demandesCongesArgs<ExtArgs>
    salarie?: boolean | Collaborateur$salarieArgs<ExtArgs>
    ficheDePoste?: boolean | Collaborateur$ficheDePosteArgs<ExtArgs>
    _count?: boolean | CollaborateurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollaborateurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CollaborateurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CollaborateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Collaborateur"
    objects: {
      evenements: Prisma.$EvenementPayload<ExtArgs>[]
      compte: Prisma.$ComptePayload<ExtArgs> | null
      managersPar: Prisma.$ComptePayload<ExtArgs>[]
      contactsGeres: Prisma.$ContactPayload<ExtArgs>[]
      demandesConges: Prisma.$DemandeCongePayload<ExtArgs>[]
      salarie: Prisma.$SalariePayload<ExtArgs> | null
      ficheDePoste: Prisma.$FicheDePostePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      couleur: string
      entreprise: string
      aCompte: boolean
      createdAt: Date
    }, ExtArgs["result"]["collaborateur"]>
    composites: {}
  }

  type CollaborateurGetPayload<S extends boolean | null | undefined | CollaborateurDefaultArgs> = $Result.GetResult<Prisma.$CollaborateurPayload, S>

  type CollaborateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollaborateurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollaborateurCountAggregateInputType | true
    }

  export interface CollaborateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Collaborateur'], meta: { name: 'Collaborateur' } }
    /**
     * Find zero or one Collaborateur that matches the filter.
     * @param {CollaborateurFindUniqueArgs} args - Arguments to find a Collaborateur
     * @example
     * // Get one Collaborateur
     * const collaborateur = await prisma.collaborateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollaborateurFindUniqueArgs>(args: SelectSubset<T, CollaborateurFindUniqueArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Collaborateur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollaborateurFindUniqueOrThrowArgs} args - Arguments to find a Collaborateur
     * @example
     * // Get one Collaborateur
     * const collaborateur = await prisma.collaborateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollaborateurFindUniqueOrThrowArgs>(args: SelectSubset<T, CollaborateurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collaborateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborateurFindFirstArgs} args - Arguments to find a Collaborateur
     * @example
     * // Get one Collaborateur
     * const collaborateur = await prisma.collaborateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollaborateurFindFirstArgs>(args?: SelectSubset<T, CollaborateurFindFirstArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collaborateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborateurFindFirstOrThrowArgs} args - Arguments to find a Collaborateur
     * @example
     * // Get one Collaborateur
     * const collaborateur = await prisma.collaborateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollaborateurFindFirstOrThrowArgs>(args?: SelectSubset<T, CollaborateurFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Collaborateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborateurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collaborateurs
     * const collaborateurs = await prisma.collaborateur.findMany()
     * 
     * // Get first 10 Collaborateurs
     * const collaborateurs = await prisma.collaborateur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collaborateurWithIdOnly = await prisma.collaborateur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollaborateurFindManyArgs>(args?: SelectSubset<T, CollaborateurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Collaborateur.
     * @param {CollaborateurCreateArgs} args - Arguments to create a Collaborateur.
     * @example
     * // Create one Collaborateur
     * const Collaborateur = await prisma.collaborateur.create({
     *   data: {
     *     // ... data to create a Collaborateur
     *   }
     * })
     * 
     */
    create<T extends CollaborateurCreateArgs>(args: SelectSubset<T, CollaborateurCreateArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Collaborateurs.
     * @param {CollaborateurCreateManyArgs} args - Arguments to create many Collaborateurs.
     * @example
     * // Create many Collaborateurs
     * const collaborateur = await prisma.collaborateur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollaborateurCreateManyArgs>(args?: SelectSubset<T, CollaborateurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collaborateurs and returns the data saved in the database.
     * @param {CollaborateurCreateManyAndReturnArgs} args - Arguments to create many Collaborateurs.
     * @example
     * // Create many Collaborateurs
     * const collaborateur = await prisma.collaborateur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collaborateurs and only return the `id`
     * const collaborateurWithIdOnly = await prisma.collaborateur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollaborateurCreateManyAndReturnArgs>(args?: SelectSubset<T, CollaborateurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Collaborateur.
     * @param {CollaborateurDeleteArgs} args - Arguments to delete one Collaborateur.
     * @example
     * // Delete one Collaborateur
     * const Collaborateur = await prisma.collaborateur.delete({
     *   where: {
     *     // ... filter to delete one Collaborateur
     *   }
     * })
     * 
     */
    delete<T extends CollaborateurDeleteArgs>(args: SelectSubset<T, CollaborateurDeleteArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Collaborateur.
     * @param {CollaborateurUpdateArgs} args - Arguments to update one Collaborateur.
     * @example
     * // Update one Collaborateur
     * const collaborateur = await prisma.collaborateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollaborateurUpdateArgs>(args: SelectSubset<T, CollaborateurUpdateArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Collaborateurs.
     * @param {CollaborateurDeleteManyArgs} args - Arguments to filter Collaborateurs to delete.
     * @example
     * // Delete a few Collaborateurs
     * const { count } = await prisma.collaborateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollaborateurDeleteManyArgs>(args?: SelectSubset<T, CollaborateurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collaborateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collaborateurs
     * const collaborateur = await prisma.collaborateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollaborateurUpdateManyArgs>(args: SelectSubset<T, CollaborateurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collaborateurs and returns the data updated in the database.
     * @param {CollaborateurUpdateManyAndReturnArgs} args - Arguments to update many Collaborateurs.
     * @example
     * // Update many Collaborateurs
     * const collaborateur = await prisma.collaborateur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collaborateurs and only return the `id`
     * const collaborateurWithIdOnly = await prisma.collaborateur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollaborateurUpdateManyAndReturnArgs>(args: SelectSubset<T, CollaborateurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Collaborateur.
     * @param {CollaborateurUpsertArgs} args - Arguments to update or create a Collaborateur.
     * @example
     * // Update or create a Collaborateur
     * const collaborateur = await prisma.collaborateur.upsert({
     *   create: {
     *     // ... data to create a Collaborateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collaborateur we want to update
     *   }
     * })
     */
    upsert<T extends CollaborateurUpsertArgs>(args: SelectSubset<T, CollaborateurUpsertArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Collaborateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborateurCountArgs} args - Arguments to filter Collaborateurs to count.
     * @example
     * // Count the number of Collaborateurs
     * const count = await prisma.collaborateur.count({
     *   where: {
     *     // ... the filter for the Collaborateurs we want to count
     *   }
     * })
    **/
    count<T extends CollaborateurCountArgs>(
      args?: Subset<T, CollaborateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollaborateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collaborateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollaborateurAggregateArgs>(args: Subset<T, CollaborateurAggregateArgs>): Prisma.PrismaPromise<GetCollaborateurAggregateType<T>>

    /**
     * Group by Collaborateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollaborateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollaborateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollaborateurGroupByArgs['orderBy'] }
        : { orderBy?: CollaborateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollaborateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollaborateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Collaborateur model
   */
  readonly fields: CollaborateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Collaborateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollaborateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evenements<T extends Collaborateur$evenementsArgs<ExtArgs> = {}>(args?: Subset<T, Collaborateur$evenementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    compte<T extends Collaborateur$compteArgs<ExtArgs> = {}>(args?: Subset<T, Collaborateur$compteArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    managersPar<T extends Collaborateur$managersParArgs<ExtArgs> = {}>(args?: Subset<T, Collaborateur$managersParArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactsGeres<T extends Collaborateur$contactsGeresArgs<ExtArgs> = {}>(args?: Subset<T, Collaborateur$contactsGeresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    demandesConges<T extends Collaborateur$demandesCongesArgs<ExtArgs> = {}>(args?: Subset<T, Collaborateur$demandesCongesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salarie<T extends Collaborateur$salarieArgs<ExtArgs> = {}>(args?: Subset<T, Collaborateur$salarieArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ficheDePoste<T extends Collaborateur$ficheDePosteArgs<ExtArgs> = {}>(args?: Subset<T, Collaborateur$ficheDePosteArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Collaborateur model
   */
  interface CollaborateurFieldRefs {
    readonly id: FieldRef<"Collaborateur", 'String'>
    readonly nom: FieldRef<"Collaborateur", 'String'>
    readonly couleur: FieldRef<"Collaborateur", 'String'>
    readonly entreprise: FieldRef<"Collaborateur", 'String'>
    readonly aCompte: FieldRef<"Collaborateur", 'Boolean'>
    readonly createdAt: FieldRef<"Collaborateur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Collaborateur findUnique
   */
  export type CollaborateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * Filter, which Collaborateur to fetch.
     */
    where: CollaborateurWhereUniqueInput
  }

  /**
   * Collaborateur findUniqueOrThrow
   */
  export type CollaborateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * Filter, which Collaborateur to fetch.
     */
    where: CollaborateurWhereUniqueInput
  }

  /**
   * Collaborateur findFirst
   */
  export type CollaborateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * Filter, which Collaborateur to fetch.
     */
    where?: CollaborateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborateurs to fetch.
     */
    orderBy?: CollaborateurOrderByWithRelationInput | CollaborateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collaborateurs.
     */
    cursor?: CollaborateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collaborateurs.
     */
    distinct?: CollaborateurScalarFieldEnum | CollaborateurScalarFieldEnum[]
  }

  /**
   * Collaborateur findFirstOrThrow
   */
  export type CollaborateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * Filter, which Collaborateur to fetch.
     */
    where?: CollaborateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborateurs to fetch.
     */
    orderBy?: CollaborateurOrderByWithRelationInput | CollaborateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collaborateurs.
     */
    cursor?: CollaborateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collaborateurs.
     */
    distinct?: CollaborateurScalarFieldEnum | CollaborateurScalarFieldEnum[]
  }

  /**
   * Collaborateur findMany
   */
  export type CollaborateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * Filter, which Collaborateurs to fetch.
     */
    where?: CollaborateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collaborateurs to fetch.
     */
    orderBy?: CollaborateurOrderByWithRelationInput | CollaborateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collaborateurs.
     */
    cursor?: CollaborateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collaborateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collaborateurs.
     */
    skip?: number
    distinct?: CollaborateurScalarFieldEnum | CollaborateurScalarFieldEnum[]
  }

  /**
   * Collaborateur create
   */
  export type CollaborateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * The data needed to create a Collaborateur.
     */
    data: XOR<CollaborateurCreateInput, CollaborateurUncheckedCreateInput>
  }

  /**
   * Collaborateur createMany
   */
  export type CollaborateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collaborateurs.
     */
    data: CollaborateurCreateManyInput | CollaborateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collaborateur createManyAndReturn
   */
  export type CollaborateurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * The data used to create many Collaborateurs.
     */
    data: CollaborateurCreateManyInput | CollaborateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collaborateur update
   */
  export type CollaborateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * The data needed to update a Collaborateur.
     */
    data: XOR<CollaborateurUpdateInput, CollaborateurUncheckedUpdateInput>
    /**
     * Choose, which Collaborateur to update.
     */
    where: CollaborateurWhereUniqueInput
  }

  /**
   * Collaborateur updateMany
   */
  export type CollaborateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collaborateurs.
     */
    data: XOR<CollaborateurUpdateManyMutationInput, CollaborateurUncheckedUpdateManyInput>
    /**
     * Filter which Collaborateurs to update
     */
    where?: CollaborateurWhereInput
    /**
     * Limit how many Collaborateurs to update.
     */
    limit?: number
  }

  /**
   * Collaborateur updateManyAndReturn
   */
  export type CollaborateurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * The data used to update Collaborateurs.
     */
    data: XOR<CollaborateurUpdateManyMutationInput, CollaborateurUncheckedUpdateManyInput>
    /**
     * Filter which Collaborateurs to update
     */
    where?: CollaborateurWhereInput
    /**
     * Limit how many Collaborateurs to update.
     */
    limit?: number
  }

  /**
   * Collaborateur upsert
   */
  export type CollaborateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * The filter to search for the Collaborateur to update in case it exists.
     */
    where: CollaborateurWhereUniqueInput
    /**
     * In case the Collaborateur found by the `where` argument doesn't exist, create a new Collaborateur with this data.
     */
    create: XOR<CollaborateurCreateInput, CollaborateurUncheckedCreateInput>
    /**
     * In case the Collaborateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollaborateurUpdateInput, CollaborateurUncheckedUpdateInput>
  }

  /**
   * Collaborateur delete
   */
  export type CollaborateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    /**
     * Filter which Collaborateur to delete.
     */
    where: CollaborateurWhereUniqueInput
  }

  /**
   * Collaborateur deleteMany
   */
  export type CollaborateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collaborateurs to delete
     */
    where?: CollaborateurWhereInput
    /**
     * Limit how many Collaborateurs to delete.
     */
    limit?: number
  }

  /**
   * Collaborateur.evenements
   */
  export type Collaborateur$evenementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    where?: EvenementWhereInput
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    cursor?: EvenementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Collaborateur.compte
   */
  export type Collaborateur$compteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    where?: CompteWhereInput
  }

  /**
   * Collaborateur.managersPar
   */
  export type Collaborateur$managersParArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    where?: CompteWhereInput
    orderBy?: CompteOrderByWithRelationInput | CompteOrderByWithRelationInput[]
    cursor?: CompteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompteScalarFieldEnum | CompteScalarFieldEnum[]
  }

  /**
   * Collaborateur.contactsGeres
   */
  export type Collaborateur$contactsGeresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Collaborateur.demandesConges
   */
  export type Collaborateur$demandesCongesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    where?: DemandeCongeWhereInput
    orderBy?: DemandeCongeOrderByWithRelationInput | DemandeCongeOrderByWithRelationInput[]
    cursor?: DemandeCongeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DemandeCongeScalarFieldEnum | DemandeCongeScalarFieldEnum[]
  }

  /**
   * Collaborateur.salarie
   */
  export type Collaborateur$salarieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    where?: SalarieWhereInput
  }

  /**
   * Collaborateur.ficheDePoste
   */
  export type Collaborateur$ficheDePosteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    where?: FicheDePosteWhereInput
  }

  /**
   * Collaborateur without action
   */
  export type CollaborateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
  }


  /**
   * Model Compte
   */

  export type AggregateCompte = {
    _count: CompteCountAggregateOutputType | null
    _min: CompteMinAggregateOutputType | null
    _max: CompteMaxAggregateOutputType | null
  }

  export type CompteMinAggregateOutputType = {
    id: string | null
    identifiant: string | null
    motDePasse: string | null
    role: $Enums.Role | null
    collaborateurId: string | null
    createdAt: Date | null
  }

  export type CompteMaxAggregateOutputType = {
    id: string | null
    identifiant: string | null
    motDePasse: string | null
    role: $Enums.Role | null
    collaborateurId: string | null
    createdAt: Date | null
  }

  export type CompteCountAggregateOutputType = {
    id: number
    identifiant: number
    motDePasse: number
    role: number
    collaborateurId: number
    createdAt: number
    _all: number
  }


  export type CompteMinAggregateInputType = {
    id?: true
    identifiant?: true
    motDePasse?: true
    role?: true
    collaborateurId?: true
    createdAt?: true
  }

  export type CompteMaxAggregateInputType = {
    id?: true
    identifiant?: true
    motDePasse?: true
    role?: true
    collaborateurId?: true
    createdAt?: true
  }

  export type CompteCountAggregateInputType = {
    id?: true
    identifiant?: true
    motDePasse?: true
    role?: true
    collaborateurId?: true
    createdAt?: true
    _all?: true
  }

  export type CompteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Compte to aggregate.
     */
    where?: CompteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comptes to fetch.
     */
    orderBy?: CompteOrderByWithRelationInput | CompteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comptes
    **/
    _count?: true | CompteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompteMaxAggregateInputType
  }

  export type GetCompteAggregateType<T extends CompteAggregateArgs> = {
        [P in keyof T & keyof AggregateCompte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompte[P]>
      : GetScalarType<T[P], AggregateCompte[P]>
  }




  export type CompteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompteWhereInput
    orderBy?: CompteOrderByWithAggregationInput | CompteOrderByWithAggregationInput[]
    by: CompteScalarFieldEnum[] | CompteScalarFieldEnum
    having?: CompteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompteCountAggregateInputType | true
    _min?: CompteMinAggregateInputType
    _max?: CompteMaxAggregateInputType
  }

  export type CompteGroupByOutputType = {
    id: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    collaborateurId: string
    createdAt: Date
    _count: CompteCountAggregateOutputType | null
    _min: CompteMinAggregateOutputType | null
    _max: CompteMaxAggregateOutputType | null
  }

  type GetCompteGroupByPayload<T extends CompteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompteGroupByOutputType[P]>
            : GetScalarType<T[P], CompteGroupByOutputType[P]>
        }
      >
    >


  export type CompteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifiant?: boolean
    motDePasse?: boolean
    role?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
    collaborateursGeres?: boolean | Compte$collaborateursGeresArgs<ExtArgs>
    demandesConges?: boolean | Compte$demandesCongesArgs<ExtArgs>
    contacts?: boolean | Compte$contactsArgs<ExtArgs>
    notifications?: boolean | Compte$notificationsArgs<ExtArgs>
    _count?: boolean | CompteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compte"]>

  export type CompteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifiant?: boolean
    motDePasse?: boolean
    role?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compte"]>

  export type CompteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifiant?: boolean
    motDePasse?: boolean
    role?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compte"]>

  export type CompteSelectScalar = {
    id?: boolean
    identifiant?: boolean
    motDePasse?: boolean
    role?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
  }

  export type CompteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifiant" | "motDePasse" | "role" | "collaborateurId" | "createdAt", ExtArgs["result"]["compte"]>
  export type CompteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
    collaborateursGeres?: boolean | Compte$collaborateursGeresArgs<ExtArgs>
    demandesConges?: boolean | Compte$demandesCongesArgs<ExtArgs>
    contacts?: boolean | Compte$contactsArgs<ExtArgs>
    notifications?: boolean | Compte$notificationsArgs<ExtArgs>
    _count?: boolean | CompteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }
  export type CompteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }

  export type $ComptePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Compte"
    objects: {
      collaborateur: Prisma.$CollaborateurPayload<ExtArgs>
      collaborateursGeres: Prisma.$CollaborateurPayload<ExtArgs>[]
      demandesConges: Prisma.$DemandeCongePayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifiant: string
      motDePasse: string
      role: $Enums.Role
      collaborateurId: string
      createdAt: Date
    }, ExtArgs["result"]["compte"]>
    composites: {}
  }

  type CompteGetPayload<S extends boolean | null | undefined | CompteDefaultArgs> = $Result.GetResult<Prisma.$ComptePayload, S>

  type CompteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompteCountAggregateInputType | true
    }

  export interface CompteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Compte'], meta: { name: 'Compte' } }
    /**
     * Find zero or one Compte that matches the filter.
     * @param {CompteFindUniqueArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompteFindUniqueArgs>(args: SelectSubset<T, CompteFindUniqueArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compte that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompteFindUniqueOrThrowArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompteFindUniqueOrThrowArgs>(args: SelectSubset<T, CompteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteFindFirstArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompteFindFirstArgs>(args?: SelectSubset<T, CompteFindFirstArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteFindFirstOrThrowArgs} args - Arguments to find a Compte
     * @example
     * // Get one Compte
     * const compte = await prisma.compte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompteFindFirstOrThrowArgs>(args?: SelectSubset<T, CompteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comptes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comptes
     * const comptes = await prisma.compte.findMany()
     * 
     * // Get first 10 Comptes
     * const comptes = await prisma.compte.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const compteWithIdOnly = await prisma.compte.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompteFindManyArgs>(args?: SelectSubset<T, CompteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compte.
     * @param {CompteCreateArgs} args - Arguments to create a Compte.
     * @example
     * // Create one Compte
     * const Compte = await prisma.compte.create({
     *   data: {
     *     // ... data to create a Compte
     *   }
     * })
     * 
     */
    create<T extends CompteCreateArgs>(args: SelectSubset<T, CompteCreateArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comptes.
     * @param {CompteCreateManyArgs} args - Arguments to create many Comptes.
     * @example
     * // Create many Comptes
     * const compte = await prisma.compte.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompteCreateManyArgs>(args?: SelectSubset<T, CompteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comptes and returns the data saved in the database.
     * @param {CompteCreateManyAndReturnArgs} args - Arguments to create many Comptes.
     * @example
     * // Create many Comptes
     * const compte = await prisma.compte.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comptes and only return the `id`
     * const compteWithIdOnly = await prisma.compte.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompteCreateManyAndReturnArgs>(args?: SelectSubset<T, CompteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Compte.
     * @param {CompteDeleteArgs} args - Arguments to delete one Compte.
     * @example
     * // Delete one Compte
     * const Compte = await prisma.compte.delete({
     *   where: {
     *     // ... filter to delete one Compte
     *   }
     * })
     * 
     */
    delete<T extends CompteDeleteArgs>(args: SelectSubset<T, CompteDeleteArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compte.
     * @param {CompteUpdateArgs} args - Arguments to update one Compte.
     * @example
     * // Update one Compte
     * const compte = await prisma.compte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompteUpdateArgs>(args: SelectSubset<T, CompteUpdateArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comptes.
     * @param {CompteDeleteManyArgs} args - Arguments to filter Comptes to delete.
     * @example
     * // Delete a few Comptes
     * const { count } = await prisma.compte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompteDeleteManyArgs>(args?: SelectSubset<T, CompteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comptes
     * const compte = await prisma.compte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompteUpdateManyArgs>(args: SelectSubset<T, CompteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comptes and returns the data updated in the database.
     * @param {CompteUpdateManyAndReturnArgs} args - Arguments to update many Comptes.
     * @example
     * // Update many Comptes
     * const compte = await prisma.compte.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comptes and only return the `id`
     * const compteWithIdOnly = await prisma.compte.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompteUpdateManyAndReturnArgs>(args: SelectSubset<T, CompteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Compte.
     * @param {CompteUpsertArgs} args - Arguments to update or create a Compte.
     * @example
     * // Update or create a Compte
     * const compte = await prisma.compte.upsert({
     *   create: {
     *     // ... data to create a Compte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compte we want to update
     *   }
     * })
     */
    upsert<T extends CompteUpsertArgs>(args: SelectSubset<T, CompteUpsertArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comptes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteCountArgs} args - Arguments to filter Comptes to count.
     * @example
     * // Count the number of Comptes
     * const count = await prisma.compte.count({
     *   where: {
     *     // ... the filter for the Comptes we want to count
     *   }
     * })
    **/
    count<T extends CompteCountArgs>(
      args?: Subset<T, CompteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompteAggregateArgs>(args: Subset<T, CompteAggregateArgs>): Prisma.PrismaPromise<GetCompteAggregateType<T>>

    /**
     * Group by Compte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompteGroupByArgs['orderBy'] }
        : { orderBy?: CompteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Compte model
   */
  readonly fields: CompteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Compte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collaborateur<T extends CollaborateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollaborateurDefaultArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    collaborateursGeres<T extends Compte$collaborateursGeresArgs<ExtArgs> = {}>(args?: Subset<T, Compte$collaborateursGeresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    demandesConges<T extends Compte$demandesCongesArgs<ExtArgs> = {}>(args?: Subset<T, Compte$demandesCongesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Compte$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Compte$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Compte$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Compte$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Compte model
   */
  interface CompteFieldRefs {
    readonly id: FieldRef<"Compte", 'String'>
    readonly identifiant: FieldRef<"Compte", 'String'>
    readonly motDePasse: FieldRef<"Compte", 'String'>
    readonly role: FieldRef<"Compte", 'Role'>
    readonly collaborateurId: FieldRef<"Compte", 'String'>
    readonly createdAt: FieldRef<"Compte", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Compte findUnique
   */
  export type CompteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * Filter, which Compte to fetch.
     */
    where: CompteWhereUniqueInput
  }

  /**
   * Compte findUniqueOrThrow
   */
  export type CompteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * Filter, which Compte to fetch.
     */
    where: CompteWhereUniqueInput
  }

  /**
   * Compte findFirst
   */
  export type CompteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * Filter, which Compte to fetch.
     */
    where?: CompteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comptes to fetch.
     */
    orderBy?: CompteOrderByWithRelationInput | CompteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comptes.
     */
    cursor?: CompteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comptes.
     */
    distinct?: CompteScalarFieldEnum | CompteScalarFieldEnum[]
  }

  /**
   * Compte findFirstOrThrow
   */
  export type CompteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * Filter, which Compte to fetch.
     */
    where?: CompteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comptes to fetch.
     */
    orderBy?: CompteOrderByWithRelationInput | CompteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comptes.
     */
    cursor?: CompteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comptes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comptes.
     */
    distinct?: CompteScalarFieldEnum | CompteScalarFieldEnum[]
  }

  /**
   * Compte findMany
   */
  export type CompteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * Filter, which Comptes to fetch.
     */
    where?: CompteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comptes to fetch.
     */
    orderBy?: CompteOrderByWithRelationInput | CompteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comptes.
     */
    cursor?: CompteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comptes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comptes.
     */
    skip?: number
    distinct?: CompteScalarFieldEnum | CompteScalarFieldEnum[]
  }

  /**
   * Compte create
   */
  export type CompteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * The data needed to create a Compte.
     */
    data: XOR<CompteCreateInput, CompteUncheckedCreateInput>
  }

  /**
   * Compte createMany
   */
  export type CompteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comptes.
     */
    data: CompteCreateManyInput | CompteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Compte createManyAndReturn
   */
  export type CompteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * The data used to create many Comptes.
     */
    data: CompteCreateManyInput | CompteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Compte update
   */
  export type CompteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * The data needed to update a Compte.
     */
    data: XOR<CompteUpdateInput, CompteUncheckedUpdateInput>
    /**
     * Choose, which Compte to update.
     */
    where: CompteWhereUniqueInput
  }

  /**
   * Compte updateMany
   */
  export type CompteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comptes.
     */
    data: XOR<CompteUpdateManyMutationInput, CompteUncheckedUpdateManyInput>
    /**
     * Filter which Comptes to update
     */
    where?: CompteWhereInput
    /**
     * Limit how many Comptes to update.
     */
    limit?: number
  }

  /**
   * Compte updateManyAndReturn
   */
  export type CompteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * The data used to update Comptes.
     */
    data: XOR<CompteUpdateManyMutationInput, CompteUncheckedUpdateManyInput>
    /**
     * Filter which Comptes to update
     */
    where?: CompteWhereInput
    /**
     * Limit how many Comptes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Compte upsert
   */
  export type CompteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * The filter to search for the Compte to update in case it exists.
     */
    where: CompteWhereUniqueInput
    /**
     * In case the Compte found by the `where` argument doesn't exist, create a new Compte with this data.
     */
    create: XOR<CompteCreateInput, CompteUncheckedCreateInput>
    /**
     * In case the Compte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompteUpdateInput, CompteUncheckedUpdateInput>
  }

  /**
   * Compte delete
   */
  export type CompteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
    /**
     * Filter which Compte to delete.
     */
    where: CompteWhereUniqueInput
  }

  /**
   * Compte deleteMany
   */
  export type CompteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comptes to delete
     */
    where?: CompteWhereInput
    /**
     * Limit how many Comptes to delete.
     */
    limit?: number
  }

  /**
   * Compte.collaborateursGeres
   */
  export type Compte$collaborateursGeresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    where?: CollaborateurWhereInput
    orderBy?: CollaborateurOrderByWithRelationInput | CollaborateurOrderByWithRelationInput[]
    cursor?: CollaborateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollaborateurScalarFieldEnum | CollaborateurScalarFieldEnum[]
  }

  /**
   * Compte.demandesConges
   */
  export type Compte$demandesCongesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    where?: DemandeCongeWhereInput
    orderBy?: DemandeCongeOrderByWithRelationInput | DemandeCongeOrderByWithRelationInput[]
    cursor?: DemandeCongeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DemandeCongeScalarFieldEnum | DemandeCongeScalarFieldEnum[]
  }

  /**
   * Compte.contacts
   */
  export type Compte$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Compte.notifications
   */
  export type Compte$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Compte without action
   */
  export type CompteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compte
     */
    select?: CompteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compte
     */
    omit?: CompteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteInclude<ExtArgs> | null
  }


  /**
   * Model Evenement
   */

  export type AggregateEvenement = {
    _count: EvenementCountAggregateOutputType | null
    _avg: EvenementAvgAggregateOutputType | null
    _sum: EvenementSumAggregateOutputType | null
    _min: EvenementMinAggregateOutputType | null
    _max: EvenementMaxAggregateOutputType | null
  }

  export type EvenementAvgAggregateOutputType = {
    heuresSupplementaires: number | null
    nombrePrgd: number | null
    latitude: number | null
    longitude: number | null
  }

  export type EvenementSumAggregateOutputType = {
    heuresSupplementaires: number | null
    nombrePrgd: number | null
    latitude: number | null
    longitude: number | null
  }

  export type EvenementMinAggregateOutputType = {
    id: string | null
    title: string | null
    start: Date | null
    end: Date | null
    collaborateurId: string | null
    typeEvenement: string | null
    lieuChantier: string | null
    zoneTrajet: string | null
    panierRepas: boolean | null
    ticketRestaurant: boolean | null
    heuresSupplementaires: number | null
    grandDeplacement: boolean | null
    prgd: boolean | null
    nombrePrgd: number | null
    typeAbsence: string | null
    verrouille: boolean | null
    latitude: number | null
    longitude: number | null
    adresseComplete: string | null
    createdAt: Date | null
  }

  export type EvenementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    start: Date | null
    end: Date | null
    collaborateurId: string | null
    typeEvenement: string | null
    lieuChantier: string | null
    zoneTrajet: string | null
    panierRepas: boolean | null
    ticketRestaurant: boolean | null
    heuresSupplementaires: number | null
    grandDeplacement: boolean | null
    prgd: boolean | null
    nombrePrgd: number | null
    typeAbsence: string | null
    verrouille: boolean | null
    latitude: number | null
    longitude: number | null
    adresseComplete: string | null
    createdAt: Date | null
  }

  export type EvenementCountAggregateOutputType = {
    id: number
    title: number
    start: number
    end: number
    collaborateurId: number
    typeEvenement: number
    lieuChantier: number
    zoneTrajet: number
    panierRepas: number
    ticketRestaurant: number
    heuresSupplementaires: number
    grandDeplacement: number
    prgd: number
    nombrePrgd: number
    typeAbsence: number
    verrouille: number
    latitude: number
    longitude: number
    adresseComplete: number
    createdAt: number
    _all: number
  }


  export type EvenementAvgAggregateInputType = {
    heuresSupplementaires?: true
    nombrePrgd?: true
    latitude?: true
    longitude?: true
  }

  export type EvenementSumAggregateInputType = {
    heuresSupplementaires?: true
    nombrePrgd?: true
    latitude?: true
    longitude?: true
  }

  export type EvenementMinAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
    collaborateurId?: true
    typeEvenement?: true
    lieuChantier?: true
    zoneTrajet?: true
    panierRepas?: true
    ticketRestaurant?: true
    heuresSupplementaires?: true
    grandDeplacement?: true
    prgd?: true
    nombrePrgd?: true
    typeAbsence?: true
    verrouille?: true
    latitude?: true
    longitude?: true
    adresseComplete?: true
    createdAt?: true
  }

  export type EvenementMaxAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
    collaborateurId?: true
    typeEvenement?: true
    lieuChantier?: true
    zoneTrajet?: true
    panierRepas?: true
    ticketRestaurant?: true
    heuresSupplementaires?: true
    grandDeplacement?: true
    prgd?: true
    nombrePrgd?: true
    typeAbsence?: true
    verrouille?: true
    latitude?: true
    longitude?: true
    adresseComplete?: true
    createdAt?: true
  }

  export type EvenementCountAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
    collaborateurId?: true
    typeEvenement?: true
    lieuChantier?: true
    zoneTrajet?: true
    panierRepas?: true
    ticketRestaurant?: true
    heuresSupplementaires?: true
    grandDeplacement?: true
    prgd?: true
    nombrePrgd?: true
    typeAbsence?: true
    verrouille?: true
    latitude?: true
    longitude?: true
    adresseComplete?: true
    createdAt?: true
    _all?: true
  }

  export type EvenementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evenement to aggregate.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evenements
    **/
    _count?: true | EvenementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvenementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvenementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvenementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvenementMaxAggregateInputType
  }

  export type GetEvenementAggregateType<T extends EvenementAggregateArgs> = {
        [P in keyof T & keyof AggregateEvenement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvenement[P]>
      : GetScalarType<T[P], AggregateEvenement[P]>
  }




  export type EvenementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementWhereInput
    orderBy?: EvenementOrderByWithAggregationInput | EvenementOrderByWithAggregationInput[]
    by: EvenementScalarFieldEnum[] | EvenementScalarFieldEnum
    having?: EvenementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvenementCountAggregateInputType | true
    _avg?: EvenementAvgAggregateInputType
    _sum?: EvenementSumAggregateInputType
    _min?: EvenementMinAggregateInputType
    _max?: EvenementMaxAggregateInputType
  }

  export type EvenementGroupByOutputType = {
    id: string
    title: string
    start: Date
    end: Date
    collaborateurId: string
    typeEvenement: string
    lieuChantier: string | null
    zoneTrajet: string | null
    panierRepas: boolean
    ticketRestaurant: boolean
    heuresSupplementaires: number
    grandDeplacement: boolean
    prgd: boolean
    nombrePrgd: number
    typeAbsence: string | null
    verrouille: boolean
    latitude: number | null
    longitude: number | null
    adresseComplete: string | null
    createdAt: Date
    _count: EvenementCountAggregateOutputType | null
    _avg: EvenementAvgAggregateOutputType | null
    _sum: EvenementSumAggregateOutputType | null
    _min: EvenementMinAggregateOutputType | null
    _max: EvenementMaxAggregateOutputType | null
  }

  type GetEvenementGroupByPayload<T extends EvenementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvenementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvenementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvenementGroupByOutputType[P]>
            : GetScalarType<T[P], EvenementGroupByOutputType[P]>
        }
      >
    >


  export type EvenementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    collaborateurId?: boolean
    typeEvenement?: boolean
    lieuChantier?: boolean
    zoneTrajet?: boolean
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: boolean
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: boolean
    typeAbsence?: boolean
    verrouille?: boolean
    latitude?: boolean
    longitude?: boolean
    adresseComplete?: boolean
    createdAt?: boolean
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evenement"]>

  export type EvenementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    collaborateurId?: boolean
    typeEvenement?: boolean
    lieuChantier?: boolean
    zoneTrajet?: boolean
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: boolean
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: boolean
    typeAbsence?: boolean
    verrouille?: boolean
    latitude?: boolean
    longitude?: boolean
    adresseComplete?: boolean
    createdAt?: boolean
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evenement"]>

  export type EvenementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    collaborateurId?: boolean
    typeEvenement?: boolean
    lieuChantier?: boolean
    zoneTrajet?: boolean
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: boolean
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: boolean
    typeAbsence?: boolean
    verrouille?: boolean
    latitude?: boolean
    longitude?: boolean
    adresseComplete?: boolean
    createdAt?: boolean
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evenement"]>

  export type EvenementSelectScalar = {
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    collaborateurId?: boolean
    typeEvenement?: boolean
    lieuChantier?: boolean
    zoneTrajet?: boolean
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: boolean
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: boolean
    typeAbsence?: boolean
    verrouille?: boolean
    latitude?: boolean
    longitude?: boolean
    adresseComplete?: boolean
    createdAt?: boolean
  }

  export type EvenementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "start" | "end" | "collaborateurId" | "typeEvenement" | "lieuChantier" | "zoneTrajet" | "panierRepas" | "ticketRestaurant" | "heuresSupplementaires" | "grandDeplacement" | "prgd" | "nombrePrgd" | "typeAbsence" | "verrouille" | "latitude" | "longitude" | "adresseComplete" | "createdAt", ExtArgs["result"]["evenement"]>
  export type EvenementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }
  export type EvenementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }
  export type EvenementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }

  export type $EvenementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evenement"
    objects: {
      collaborateur: Prisma.$CollaborateurPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      start: Date
      end: Date
      collaborateurId: string
      typeEvenement: string
      lieuChantier: string | null
      zoneTrajet: string | null
      panierRepas: boolean
      ticketRestaurant: boolean
      heuresSupplementaires: number
      grandDeplacement: boolean
      prgd: boolean
      nombrePrgd: number
      typeAbsence: string | null
      verrouille: boolean
      latitude: number | null
      longitude: number | null
      adresseComplete: string | null
      createdAt: Date
    }, ExtArgs["result"]["evenement"]>
    composites: {}
  }

  type EvenementGetPayload<S extends boolean | null | undefined | EvenementDefaultArgs> = $Result.GetResult<Prisma.$EvenementPayload, S>

  type EvenementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvenementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvenementCountAggregateInputType | true
    }

  export interface EvenementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evenement'], meta: { name: 'Evenement' } }
    /**
     * Find zero or one Evenement that matches the filter.
     * @param {EvenementFindUniqueArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvenementFindUniqueArgs>(args: SelectSubset<T, EvenementFindUniqueArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evenement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvenementFindUniqueOrThrowArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvenementFindUniqueOrThrowArgs>(args: SelectSubset<T, EvenementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evenement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementFindFirstArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvenementFindFirstArgs>(args?: SelectSubset<T, EvenementFindFirstArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evenement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementFindFirstOrThrowArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvenementFindFirstOrThrowArgs>(args?: SelectSubset<T, EvenementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evenements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evenements
     * const evenements = await prisma.evenement.findMany()
     * 
     * // Get first 10 Evenements
     * const evenements = await prisma.evenement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evenementWithIdOnly = await prisma.evenement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvenementFindManyArgs>(args?: SelectSubset<T, EvenementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evenement.
     * @param {EvenementCreateArgs} args - Arguments to create a Evenement.
     * @example
     * // Create one Evenement
     * const Evenement = await prisma.evenement.create({
     *   data: {
     *     // ... data to create a Evenement
     *   }
     * })
     * 
     */
    create<T extends EvenementCreateArgs>(args: SelectSubset<T, EvenementCreateArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evenements.
     * @param {EvenementCreateManyArgs} args - Arguments to create many Evenements.
     * @example
     * // Create many Evenements
     * const evenement = await prisma.evenement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvenementCreateManyArgs>(args?: SelectSubset<T, EvenementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evenements and returns the data saved in the database.
     * @param {EvenementCreateManyAndReturnArgs} args - Arguments to create many Evenements.
     * @example
     * // Create many Evenements
     * const evenement = await prisma.evenement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evenements and only return the `id`
     * const evenementWithIdOnly = await prisma.evenement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvenementCreateManyAndReturnArgs>(args?: SelectSubset<T, EvenementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evenement.
     * @param {EvenementDeleteArgs} args - Arguments to delete one Evenement.
     * @example
     * // Delete one Evenement
     * const Evenement = await prisma.evenement.delete({
     *   where: {
     *     // ... filter to delete one Evenement
     *   }
     * })
     * 
     */
    delete<T extends EvenementDeleteArgs>(args: SelectSubset<T, EvenementDeleteArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evenement.
     * @param {EvenementUpdateArgs} args - Arguments to update one Evenement.
     * @example
     * // Update one Evenement
     * const evenement = await prisma.evenement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvenementUpdateArgs>(args: SelectSubset<T, EvenementUpdateArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evenements.
     * @param {EvenementDeleteManyArgs} args - Arguments to filter Evenements to delete.
     * @example
     * // Delete a few Evenements
     * const { count } = await prisma.evenement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvenementDeleteManyArgs>(args?: SelectSubset<T, EvenementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evenements
     * const evenement = await prisma.evenement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvenementUpdateManyArgs>(args: SelectSubset<T, EvenementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evenements and returns the data updated in the database.
     * @param {EvenementUpdateManyAndReturnArgs} args - Arguments to update many Evenements.
     * @example
     * // Update many Evenements
     * const evenement = await prisma.evenement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evenements and only return the `id`
     * const evenementWithIdOnly = await prisma.evenement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvenementUpdateManyAndReturnArgs>(args: SelectSubset<T, EvenementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evenement.
     * @param {EvenementUpsertArgs} args - Arguments to update or create a Evenement.
     * @example
     * // Update or create a Evenement
     * const evenement = await prisma.evenement.upsert({
     *   create: {
     *     // ... data to create a Evenement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evenement we want to update
     *   }
     * })
     */
    upsert<T extends EvenementUpsertArgs>(args: SelectSubset<T, EvenementUpsertArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementCountArgs} args - Arguments to filter Evenements to count.
     * @example
     * // Count the number of Evenements
     * const count = await prisma.evenement.count({
     *   where: {
     *     // ... the filter for the Evenements we want to count
     *   }
     * })
    **/
    count<T extends EvenementCountArgs>(
      args?: Subset<T, EvenementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvenementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evenement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvenementAggregateArgs>(args: Subset<T, EvenementAggregateArgs>): Prisma.PrismaPromise<GetEvenementAggregateType<T>>

    /**
     * Group by Evenement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvenementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvenementGroupByArgs['orderBy'] }
        : { orderBy?: EvenementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvenementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvenementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evenement model
   */
  readonly fields: EvenementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evenement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvenementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collaborateur<T extends CollaborateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollaborateurDefaultArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evenement model
   */
  interface EvenementFieldRefs {
    readonly id: FieldRef<"Evenement", 'String'>
    readonly title: FieldRef<"Evenement", 'String'>
    readonly start: FieldRef<"Evenement", 'DateTime'>
    readonly end: FieldRef<"Evenement", 'DateTime'>
    readonly collaborateurId: FieldRef<"Evenement", 'String'>
    readonly typeEvenement: FieldRef<"Evenement", 'String'>
    readonly lieuChantier: FieldRef<"Evenement", 'String'>
    readonly zoneTrajet: FieldRef<"Evenement", 'String'>
    readonly panierRepas: FieldRef<"Evenement", 'Boolean'>
    readonly ticketRestaurant: FieldRef<"Evenement", 'Boolean'>
    readonly heuresSupplementaires: FieldRef<"Evenement", 'Float'>
    readonly grandDeplacement: FieldRef<"Evenement", 'Boolean'>
    readonly prgd: FieldRef<"Evenement", 'Boolean'>
    readonly nombrePrgd: FieldRef<"Evenement", 'Int'>
    readonly typeAbsence: FieldRef<"Evenement", 'String'>
    readonly verrouille: FieldRef<"Evenement", 'Boolean'>
    readonly latitude: FieldRef<"Evenement", 'Float'>
    readonly longitude: FieldRef<"Evenement", 'Float'>
    readonly adresseComplete: FieldRef<"Evenement", 'String'>
    readonly createdAt: FieldRef<"Evenement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evenement findUnique
   */
  export type EvenementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement findUniqueOrThrow
   */
  export type EvenementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement findFirst
   */
  export type EvenementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evenements.
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evenements.
     */
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Evenement findFirstOrThrow
   */
  export type EvenementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evenements.
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evenements.
     */
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Evenement findMany
   */
  export type EvenementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenements to fetch.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evenements.
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Evenement create
   */
  export type EvenementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * The data needed to create a Evenement.
     */
    data: XOR<EvenementCreateInput, EvenementUncheckedCreateInput>
  }

  /**
   * Evenement createMany
   */
  export type EvenementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evenements.
     */
    data: EvenementCreateManyInput | EvenementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evenement createManyAndReturn
   */
  export type EvenementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * The data used to create many Evenements.
     */
    data: EvenementCreateManyInput | EvenementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evenement update
   */
  export type EvenementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * The data needed to update a Evenement.
     */
    data: XOR<EvenementUpdateInput, EvenementUncheckedUpdateInput>
    /**
     * Choose, which Evenement to update.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement updateMany
   */
  export type EvenementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evenements.
     */
    data: XOR<EvenementUpdateManyMutationInput, EvenementUncheckedUpdateManyInput>
    /**
     * Filter which Evenements to update
     */
    where?: EvenementWhereInput
    /**
     * Limit how many Evenements to update.
     */
    limit?: number
  }

  /**
   * Evenement updateManyAndReturn
   */
  export type EvenementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * The data used to update Evenements.
     */
    data: XOR<EvenementUpdateManyMutationInput, EvenementUncheckedUpdateManyInput>
    /**
     * Filter which Evenements to update
     */
    where?: EvenementWhereInput
    /**
     * Limit how many Evenements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evenement upsert
   */
  export type EvenementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * The filter to search for the Evenement to update in case it exists.
     */
    where: EvenementWhereUniqueInput
    /**
     * In case the Evenement found by the `where` argument doesn't exist, create a new Evenement with this data.
     */
    create: XOR<EvenementCreateInput, EvenementUncheckedCreateInput>
    /**
     * In case the Evenement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvenementUpdateInput, EvenementUncheckedUpdateInput>
  }

  /**
   * Evenement delete
   */
  export type EvenementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter which Evenement to delete.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement deleteMany
   */
  export type EvenementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evenements to delete
     */
    where?: EvenementWhereInput
    /**
     * Limit how many Evenements to delete.
     */
    limit?: number
  }

  /**
   * Evenement without action
   */
  export type EvenementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evenement
     */
    omit?: EvenementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
  }


  /**
   * Model Salarie
   */

  export type AggregateSalarie = {
    _count: SalarieCountAggregateOutputType | null
    _min: SalarieMinAggregateOutputType | null
    _max: SalarieMaxAggregateOutputType | null
  }

  export type SalarieMinAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    classification: string | null
    dateEntree: Date | null
    typeContrat: string | null
    dureeContrat: string | null
    entreprise: string | null
    poste: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    codePostal: string | null
    ville: string | null
    dateNaissance: Date | null
    numeroSecu: string | null
    collaborateurId: string | null
    createdAt: Date | null
  }

  export type SalarieMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    classification: string | null
    dateEntree: Date | null
    typeContrat: string | null
    dureeContrat: string | null
    entreprise: string | null
    poste: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    codePostal: string | null
    ville: string | null
    dateNaissance: Date | null
    numeroSecu: string | null
    collaborateurId: string | null
    createdAt: Date | null
  }

  export type SalarieCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    classification: number
    dateEntree: number
    typeContrat: number
    dureeContrat: number
    certifications: number
    habilitations: number
    entreprise: number
    poste: number
    email: number
    telephone: number
    adresse: number
    codePostal: number
    ville: number
    dateNaissance: number
    numeroSecu: number
    collaborateurId: number
    createdAt: number
    _all: number
  }


  export type SalarieMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    classification?: true
    dateEntree?: true
    typeContrat?: true
    dureeContrat?: true
    entreprise?: true
    poste?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    dateNaissance?: true
    numeroSecu?: true
    collaborateurId?: true
    createdAt?: true
  }

  export type SalarieMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    classification?: true
    dateEntree?: true
    typeContrat?: true
    dureeContrat?: true
    entreprise?: true
    poste?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    dateNaissance?: true
    numeroSecu?: true
    collaborateurId?: true
    createdAt?: true
  }

  export type SalarieCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    classification?: true
    dateEntree?: true
    typeContrat?: true
    dureeContrat?: true
    certifications?: true
    habilitations?: true
    entreprise?: true
    poste?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    dateNaissance?: true
    numeroSecu?: true
    collaborateurId?: true
    createdAt?: true
    _all?: true
  }

  export type SalarieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salarie to aggregate.
     */
    where?: SalarieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalarieOrderByWithRelationInput | SalarieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalarieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salaries
    **/
    _count?: true | SalarieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalarieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalarieMaxAggregateInputType
  }

  export type GetSalarieAggregateType<T extends SalarieAggregateArgs> = {
        [P in keyof T & keyof AggregateSalarie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalarie[P]>
      : GetScalarType<T[P], AggregateSalarie[P]>
  }




  export type SalarieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalarieWhereInput
    orderBy?: SalarieOrderByWithAggregationInput | SalarieOrderByWithAggregationInput[]
    by: SalarieScalarFieldEnum[] | SalarieScalarFieldEnum
    having?: SalarieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalarieCountAggregateInputType | true
    _min?: SalarieMinAggregateInputType
    _max?: SalarieMaxAggregateInputType
  }

  export type SalarieGroupByOutputType = {
    id: string
    nom: string
    prenom: string
    classification: string
    dateEntree: Date
    typeContrat: string
    dureeContrat: string | null
    certifications: string[]
    habilitations: string[]
    entreprise: string
    poste: string
    email: string
    telephone: string
    adresse: string | null
    codePostal: string | null
    ville: string | null
    dateNaissance: Date | null
    numeroSecu: string | null
    collaborateurId: string | null
    createdAt: Date
    _count: SalarieCountAggregateOutputType | null
    _min: SalarieMinAggregateOutputType | null
    _max: SalarieMaxAggregateOutputType | null
  }

  type GetSalarieGroupByPayload<T extends SalarieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalarieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalarieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalarieGroupByOutputType[P]>
            : GetScalarType<T[P], SalarieGroupByOutputType[P]>
        }
      >
    >


  export type SalarieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    classification?: boolean
    dateEntree?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    entreprise?: boolean
    poste?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
    collaborateur?: boolean | Salarie$collaborateurArgs<ExtArgs>
  }, ExtArgs["result"]["salarie"]>

  export type SalarieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    classification?: boolean
    dateEntree?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    entreprise?: boolean
    poste?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
    collaborateur?: boolean | Salarie$collaborateurArgs<ExtArgs>
  }, ExtArgs["result"]["salarie"]>

  export type SalarieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    classification?: boolean
    dateEntree?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    entreprise?: boolean
    poste?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
    collaborateur?: boolean | Salarie$collaborateurArgs<ExtArgs>
  }, ExtArgs["result"]["salarie"]>

  export type SalarieSelectScalar = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    classification?: boolean
    dateEntree?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    entreprise?: boolean
    poste?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    collaborateurId?: boolean
    createdAt?: boolean
  }

  export type SalarieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "prenom" | "classification" | "dateEntree" | "typeContrat" | "dureeContrat" | "certifications" | "habilitations" | "entreprise" | "poste" | "email" | "telephone" | "adresse" | "codePostal" | "ville" | "dateNaissance" | "numeroSecu" | "collaborateurId" | "createdAt", ExtArgs["result"]["salarie"]>
  export type SalarieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | Salarie$collaborateurArgs<ExtArgs>
  }
  export type SalarieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | Salarie$collaborateurArgs<ExtArgs>
  }
  export type SalarieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | Salarie$collaborateurArgs<ExtArgs>
  }

  export type $SalariePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salarie"
    objects: {
      collaborateur: Prisma.$CollaborateurPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      prenom: string
      classification: string
      dateEntree: Date
      typeContrat: string
      dureeContrat: string | null
      certifications: string[]
      habilitations: string[]
      entreprise: string
      poste: string
      email: string
      telephone: string
      adresse: string | null
      codePostal: string | null
      ville: string | null
      dateNaissance: Date | null
      numeroSecu: string | null
      collaborateurId: string | null
      createdAt: Date
    }, ExtArgs["result"]["salarie"]>
    composites: {}
  }

  type SalarieGetPayload<S extends boolean | null | undefined | SalarieDefaultArgs> = $Result.GetResult<Prisma.$SalariePayload, S>

  type SalarieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalarieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalarieCountAggregateInputType | true
    }

  export interface SalarieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salarie'], meta: { name: 'Salarie' } }
    /**
     * Find zero or one Salarie that matches the filter.
     * @param {SalarieFindUniqueArgs} args - Arguments to find a Salarie
     * @example
     * // Get one Salarie
     * const salarie = await prisma.salarie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalarieFindUniqueArgs>(args: SelectSubset<T, SalarieFindUniqueArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Salarie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalarieFindUniqueOrThrowArgs} args - Arguments to find a Salarie
     * @example
     * // Get one Salarie
     * const salarie = await prisma.salarie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalarieFindUniqueOrThrowArgs>(args: SelectSubset<T, SalarieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salarie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalarieFindFirstArgs} args - Arguments to find a Salarie
     * @example
     * // Get one Salarie
     * const salarie = await prisma.salarie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalarieFindFirstArgs>(args?: SelectSubset<T, SalarieFindFirstArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salarie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalarieFindFirstOrThrowArgs} args - Arguments to find a Salarie
     * @example
     * // Get one Salarie
     * const salarie = await prisma.salarie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalarieFindFirstOrThrowArgs>(args?: SelectSubset<T, SalarieFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalarieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salaries
     * const salaries = await prisma.salarie.findMany()
     * 
     * // Get first 10 Salaries
     * const salaries = await prisma.salarie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salarieWithIdOnly = await prisma.salarie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalarieFindManyArgs>(args?: SelectSubset<T, SalarieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Salarie.
     * @param {SalarieCreateArgs} args - Arguments to create a Salarie.
     * @example
     * // Create one Salarie
     * const Salarie = await prisma.salarie.create({
     *   data: {
     *     // ... data to create a Salarie
     *   }
     * })
     * 
     */
    create<T extends SalarieCreateArgs>(args: SelectSubset<T, SalarieCreateArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Salaries.
     * @param {SalarieCreateManyArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salarie = await prisma.salarie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalarieCreateManyArgs>(args?: SelectSubset<T, SalarieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Salaries and returns the data saved in the database.
     * @param {SalarieCreateManyAndReturnArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salarie = await prisma.salarie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Salaries and only return the `id`
     * const salarieWithIdOnly = await prisma.salarie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalarieCreateManyAndReturnArgs>(args?: SelectSubset<T, SalarieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Salarie.
     * @param {SalarieDeleteArgs} args - Arguments to delete one Salarie.
     * @example
     * // Delete one Salarie
     * const Salarie = await prisma.salarie.delete({
     *   where: {
     *     // ... filter to delete one Salarie
     *   }
     * })
     * 
     */
    delete<T extends SalarieDeleteArgs>(args: SelectSubset<T, SalarieDeleteArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Salarie.
     * @param {SalarieUpdateArgs} args - Arguments to update one Salarie.
     * @example
     * // Update one Salarie
     * const salarie = await prisma.salarie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalarieUpdateArgs>(args: SelectSubset<T, SalarieUpdateArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Salaries.
     * @param {SalarieDeleteManyArgs} args - Arguments to filter Salaries to delete.
     * @example
     * // Delete a few Salaries
     * const { count } = await prisma.salarie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalarieDeleteManyArgs>(args?: SelectSubset<T, SalarieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalarieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salaries
     * const salarie = await prisma.salarie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalarieUpdateManyArgs>(args: SelectSubset<T, SalarieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries and returns the data updated in the database.
     * @param {SalarieUpdateManyAndReturnArgs} args - Arguments to update many Salaries.
     * @example
     * // Update many Salaries
     * const salarie = await prisma.salarie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Salaries and only return the `id`
     * const salarieWithIdOnly = await prisma.salarie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalarieUpdateManyAndReturnArgs>(args: SelectSubset<T, SalarieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Salarie.
     * @param {SalarieUpsertArgs} args - Arguments to update or create a Salarie.
     * @example
     * // Update or create a Salarie
     * const salarie = await prisma.salarie.upsert({
     *   create: {
     *     // ... data to create a Salarie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salarie we want to update
     *   }
     * })
     */
    upsert<T extends SalarieUpsertArgs>(args: SelectSubset<T, SalarieUpsertArgs<ExtArgs>>): Prisma__SalarieClient<$Result.GetResult<Prisma.$SalariePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalarieCountArgs} args - Arguments to filter Salaries to count.
     * @example
     * // Count the number of Salaries
     * const count = await prisma.salarie.count({
     *   where: {
     *     // ... the filter for the Salaries we want to count
     *   }
     * })
    **/
    count<T extends SalarieCountArgs>(
      args?: Subset<T, SalarieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalarieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salarie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalarieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalarieAggregateArgs>(args: Subset<T, SalarieAggregateArgs>): Prisma.PrismaPromise<GetSalarieAggregateType<T>>

    /**
     * Group by Salarie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalarieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalarieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalarieGroupByArgs['orderBy'] }
        : { orderBy?: SalarieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalarieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalarieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salarie model
   */
  readonly fields: SalarieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salarie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalarieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collaborateur<T extends Salarie$collaborateurArgs<ExtArgs> = {}>(args?: Subset<T, Salarie$collaborateurArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Salarie model
   */
  interface SalarieFieldRefs {
    readonly id: FieldRef<"Salarie", 'String'>
    readonly nom: FieldRef<"Salarie", 'String'>
    readonly prenom: FieldRef<"Salarie", 'String'>
    readonly classification: FieldRef<"Salarie", 'String'>
    readonly dateEntree: FieldRef<"Salarie", 'DateTime'>
    readonly typeContrat: FieldRef<"Salarie", 'String'>
    readonly dureeContrat: FieldRef<"Salarie", 'String'>
    readonly certifications: FieldRef<"Salarie", 'String[]'>
    readonly habilitations: FieldRef<"Salarie", 'String[]'>
    readonly entreprise: FieldRef<"Salarie", 'String'>
    readonly poste: FieldRef<"Salarie", 'String'>
    readonly email: FieldRef<"Salarie", 'String'>
    readonly telephone: FieldRef<"Salarie", 'String'>
    readonly adresse: FieldRef<"Salarie", 'String'>
    readonly codePostal: FieldRef<"Salarie", 'String'>
    readonly ville: FieldRef<"Salarie", 'String'>
    readonly dateNaissance: FieldRef<"Salarie", 'DateTime'>
    readonly numeroSecu: FieldRef<"Salarie", 'String'>
    readonly collaborateurId: FieldRef<"Salarie", 'String'>
    readonly createdAt: FieldRef<"Salarie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Salarie findUnique
   */
  export type SalarieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * Filter, which Salarie to fetch.
     */
    where: SalarieWhereUniqueInput
  }

  /**
   * Salarie findUniqueOrThrow
   */
  export type SalarieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * Filter, which Salarie to fetch.
     */
    where: SalarieWhereUniqueInput
  }

  /**
   * Salarie findFirst
   */
  export type SalarieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * Filter, which Salarie to fetch.
     */
    where?: SalarieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalarieOrderByWithRelationInput | SalarieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalarieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalarieScalarFieldEnum | SalarieScalarFieldEnum[]
  }

  /**
   * Salarie findFirstOrThrow
   */
  export type SalarieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * Filter, which Salarie to fetch.
     */
    where?: SalarieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalarieOrderByWithRelationInput | SalarieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalarieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalarieScalarFieldEnum | SalarieScalarFieldEnum[]
  }

  /**
   * Salarie findMany
   */
  export type SalarieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * Filter, which Salaries to fetch.
     */
    where?: SalarieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalarieOrderByWithRelationInput | SalarieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salaries.
     */
    cursor?: SalarieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    distinct?: SalarieScalarFieldEnum | SalarieScalarFieldEnum[]
  }

  /**
   * Salarie create
   */
  export type SalarieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * The data needed to create a Salarie.
     */
    data: XOR<SalarieCreateInput, SalarieUncheckedCreateInput>
  }

  /**
   * Salarie createMany
   */
  export type SalarieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salaries.
     */
    data: SalarieCreateManyInput | SalarieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salarie createManyAndReturn
   */
  export type SalarieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * The data used to create many Salaries.
     */
    data: SalarieCreateManyInput | SalarieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Salarie update
   */
  export type SalarieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * The data needed to update a Salarie.
     */
    data: XOR<SalarieUpdateInput, SalarieUncheckedUpdateInput>
    /**
     * Choose, which Salarie to update.
     */
    where: SalarieWhereUniqueInput
  }

  /**
   * Salarie updateMany
   */
  export type SalarieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalarieUpdateManyMutationInput, SalarieUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalarieWhereInput
    /**
     * Limit how many Salaries to update.
     */
    limit?: number
  }

  /**
   * Salarie updateManyAndReturn
   */
  export type SalarieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalarieUpdateManyMutationInput, SalarieUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalarieWhereInput
    /**
     * Limit how many Salaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Salarie upsert
   */
  export type SalarieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * The filter to search for the Salarie to update in case it exists.
     */
    where: SalarieWhereUniqueInput
    /**
     * In case the Salarie found by the `where` argument doesn't exist, create a new Salarie with this data.
     */
    create: XOR<SalarieCreateInput, SalarieUncheckedCreateInput>
    /**
     * In case the Salarie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalarieUpdateInput, SalarieUncheckedUpdateInput>
  }

  /**
   * Salarie delete
   */
  export type SalarieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
    /**
     * Filter which Salarie to delete.
     */
    where: SalarieWhereUniqueInput
  }

  /**
   * Salarie deleteMany
   */
  export type SalarieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salaries to delete
     */
    where?: SalarieWhereInput
    /**
     * Limit how many Salaries to delete.
     */
    limit?: number
  }

  /**
   * Salarie.collaborateur
   */
  export type Salarie$collaborateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    where?: CollaborateurWhereInput
  }

  /**
   * Salarie without action
   */
  export type SalarieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salarie
     */
    select?: SalarieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salarie
     */
    omit?: SalarieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalarieInclude<ExtArgs> | null
  }


  /**
   * Model Vehicule
   */

  export type AggregateVehicule = {
    _count: VehiculeCountAggregateOutputType | null
    _avg: VehiculeAvgAggregateOutputType | null
    _sum: VehiculeSumAggregateOutputType | null
    _min: VehiculeMinAggregateOutputType | null
    _max: VehiculeMaxAggregateOutputType | null
  }

  export type VehiculeAvgAggregateOutputType = {
    kilometrage: number | null
    kmProchaineRevision: number | null
  }

  export type VehiculeSumAggregateOutputType = {
    kilometrage: number | null
    kmProchaineRevision: number | null
  }

  export type VehiculeMinAggregateOutputType = {
    id: string | null
    societe: string | null
    marque: string | null
    modele: string | null
    immatriculation: string | null
    etat: string | null
    proprietaire: string | null
    dateMiseEnCirculation: Date | null
    kilometrage: number | null
    kmProchaineRevision: number | null
    dateLimiteControleTechnique: Date | null
    dateLimiteControlePollution: Date | null
    typeVehicule: string | null
    createdAt: Date | null
  }

  export type VehiculeMaxAggregateOutputType = {
    id: string | null
    societe: string | null
    marque: string | null
    modele: string | null
    immatriculation: string | null
    etat: string | null
    proprietaire: string | null
    dateMiseEnCirculation: Date | null
    kilometrage: number | null
    kmProchaineRevision: number | null
    dateLimiteControleTechnique: Date | null
    dateLimiteControlePollution: Date | null
    typeVehicule: string | null
    createdAt: Date | null
  }

  export type VehiculeCountAggregateOutputType = {
    id: number
    societe: number
    marque: number
    modele: number
    immatriculation: number
    etat: number
    proprietaire: number
    dateMiseEnCirculation: number
    kilometrage: number
    kmProchaineRevision: number
    dateLimiteControleTechnique: number
    dateLimiteControlePollution: number
    typeVehicule: number
    createdAt: number
    _all: number
  }


  export type VehiculeAvgAggregateInputType = {
    kilometrage?: true
    kmProchaineRevision?: true
  }

  export type VehiculeSumAggregateInputType = {
    kilometrage?: true
    kmProchaineRevision?: true
  }

  export type VehiculeMinAggregateInputType = {
    id?: true
    societe?: true
    marque?: true
    modele?: true
    immatriculation?: true
    etat?: true
    proprietaire?: true
    dateMiseEnCirculation?: true
    kilometrage?: true
    kmProchaineRevision?: true
    dateLimiteControleTechnique?: true
    dateLimiteControlePollution?: true
    typeVehicule?: true
    createdAt?: true
  }

  export type VehiculeMaxAggregateInputType = {
    id?: true
    societe?: true
    marque?: true
    modele?: true
    immatriculation?: true
    etat?: true
    proprietaire?: true
    dateMiseEnCirculation?: true
    kilometrage?: true
    kmProchaineRevision?: true
    dateLimiteControleTechnique?: true
    dateLimiteControlePollution?: true
    typeVehicule?: true
    createdAt?: true
  }

  export type VehiculeCountAggregateInputType = {
    id?: true
    societe?: true
    marque?: true
    modele?: true
    immatriculation?: true
    etat?: true
    proprietaire?: true
    dateMiseEnCirculation?: true
    kilometrage?: true
    kmProchaineRevision?: true
    dateLimiteControleTechnique?: true
    dateLimiteControlePollution?: true
    typeVehicule?: true
    createdAt?: true
    _all?: true
  }

  export type VehiculeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicule to aggregate.
     */
    where?: VehiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicules to fetch.
     */
    orderBy?: VehiculeOrderByWithRelationInput | VehiculeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicules
    **/
    _count?: true | VehiculeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehiculeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehiculeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiculeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiculeMaxAggregateInputType
  }

  export type GetVehiculeAggregateType<T extends VehiculeAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicule[P]>
      : GetScalarType<T[P], AggregateVehicule[P]>
  }




  export type VehiculeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehiculeWhereInput
    orderBy?: VehiculeOrderByWithAggregationInput | VehiculeOrderByWithAggregationInput[]
    by: VehiculeScalarFieldEnum[] | VehiculeScalarFieldEnum
    having?: VehiculeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiculeCountAggregateInputType | true
    _avg?: VehiculeAvgAggregateInputType
    _sum?: VehiculeSumAggregateInputType
    _min?: VehiculeMinAggregateInputType
    _max?: VehiculeMaxAggregateInputType
  }

  export type VehiculeGroupByOutputType = {
    id: string
    societe: string
    marque: string
    modele: string
    immatriculation: string
    etat: string
    proprietaire: string
    dateMiseEnCirculation: Date | null
    kilometrage: number | null
    kmProchaineRevision: number | null
    dateLimiteControleTechnique: Date | null
    dateLimiteControlePollution: Date | null
    typeVehicule: string | null
    createdAt: Date
    _count: VehiculeCountAggregateOutputType | null
    _avg: VehiculeAvgAggregateOutputType | null
    _sum: VehiculeSumAggregateOutputType | null
    _min: VehiculeMinAggregateOutputType | null
    _max: VehiculeMaxAggregateOutputType | null
  }

  type GetVehiculeGroupByPayload<T extends VehiculeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiculeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiculeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiculeGroupByOutputType[P]>
            : GetScalarType<T[P], VehiculeGroupByOutputType[P]>
        }
      >
    >


  export type VehiculeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    societe?: boolean
    marque?: boolean
    modele?: boolean
    immatriculation?: boolean
    etat?: boolean
    proprietaire?: boolean
    dateMiseEnCirculation?: boolean
    kilometrage?: boolean
    kmProchaineRevision?: boolean
    dateLimiteControleTechnique?: boolean
    dateLimiteControlePollution?: boolean
    typeVehicule?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["vehicule"]>

  export type VehiculeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    societe?: boolean
    marque?: boolean
    modele?: boolean
    immatriculation?: boolean
    etat?: boolean
    proprietaire?: boolean
    dateMiseEnCirculation?: boolean
    kilometrage?: boolean
    kmProchaineRevision?: boolean
    dateLimiteControleTechnique?: boolean
    dateLimiteControlePollution?: boolean
    typeVehicule?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["vehicule"]>

  export type VehiculeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    societe?: boolean
    marque?: boolean
    modele?: boolean
    immatriculation?: boolean
    etat?: boolean
    proprietaire?: boolean
    dateMiseEnCirculation?: boolean
    kilometrage?: boolean
    kmProchaineRevision?: boolean
    dateLimiteControleTechnique?: boolean
    dateLimiteControlePollution?: boolean
    typeVehicule?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["vehicule"]>

  export type VehiculeSelectScalar = {
    id?: boolean
    societe?: boolean
    marque?: boolean
    modele?: boolean
    immatriculation?: boolean
    etat?: boolean
    proprietaire?: boolean
    dateMiseEnCirculation?: boolean
    kilometrage?: boolean
    kmProchaineRevision?: boolean
    dateLimiteControleTechnique?: boolean
    dateLimiteControlePollution?: boolean
    typeVehicule?: boolean
    createdAt?: boolean
  }

  export type VehiculeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "societe" | "marque" | "modele" | "immatriculation" | "etat" | "proprietaire" | "dateMiseEnCirculation" | "kilometrage" | "kmProchaineRevision" | "dateLimiteControleTechnique" | "dateLimiteControlePollution" | "typeVehicule" | "createdAt", ExtArgs["result"]["vehicule"]>

  export type $VehiculePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      societe: string
      marque: string
      modele: string
      immatriculation: string
      etat: string
      proprietaire: string
      dateMiseEnCirculation: Date | null
      kilometrage: number | null
      kmProchaineRevision: number | null
      dateLimiteControleTechnique: Date | null
      dateLimiteControlePollution: Date | null
      typeVehicule: string | null
      createdAt: Date
    }, ExtArgs["result"]["vehicule"]>
    composites: {}
  }

  type VehiculeGetPayload<S extends boolean | null | undefined | VehiculeDefaultArgs> = $Result.GetResult<Prisma.$VehiculePayload, S>

  type VehiculeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehiculeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehiculeCountAggregateInputType | true
    }

  export interface VehiculeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicule'], meta: { name: 'Vehicule' } }
    /**
     * Find zero or one Vehicule that matches the filter.
     * @param {VehiculeFindUniqueArgs} args - Arguments to find a Vehicule
     * @example
     * // Get one Vehicule
     * const vehicule = await prisma.vehicule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehiculeFindUniqueArgs>(args: SelectSubset<T, VehiculeFindUniqueArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehiculeFindUniqueOrThrowArgs} args - Arguments to find a Vehicule
     * @example
     * // Get one Vehicule
     * const vehicule = await prisma.vehicule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehiculeFindUniqueOrThrowArgs>(args: SelectSubset<T, VehiculeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculeFindFirstArgs} args - Arguments to find a Vehicule
     * @example
     * // Get one Vehicule
     * const vehicule = await prisma.vehicule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehiculeFindFirstArgs>(args?: SelectSubset<T, VehiculeFindFirstArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculeFindFirstOrThrowArgs} args - Arguments to find a Vehicule
     * @example
     * // Get one Vehicule
     * const vehicule = await prisma.vehicule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehiculeFindFirstOrThrowArgs>(args?: SelectSubset<T, VehiculeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicules
     * const vehicules = await prisma.vehicule.findMany()
     * 
     * // Get first 10 Vehicules
     * const vehicules = await prisma.vehicule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehiculeWithIdOnly = await prisma.vehicule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehiculeFindManyArgs>(args?: SelectSubset<T, VehiculeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicule.
     * @param {VehiculeCreateArgs} args - Arguments to create a Vehicule.
     * @example
     * // Create one Vehicule
     * const Vehicule = await prisma.vehicule.create({
     *   data: {
     *     // ... data to create a Vehicule
     *   }
     * })
     * 
     */
    create<T extends VehiculeCreateArgs>(args: SelectSubset<T, VehiculeCreateArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicules.
     * @param {VehiculeCreateManyArgs} args - Arguments to create many Vehicules.
     * @example
     * // Create many Vehicules
     * const vehicule = await prisma.vehicule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehiculeCreateManyArgs>(args?: SelectSubset<T, VehiculeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicules and returns the data saved in the database.
     * @param {VehiculeCreateManyAndReturnArgs} args - Arguments to create many Vehicules.
     * @example
     * // Create many Vehicules
     * const vehicule = await prisma.vehicule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicules and only return the `id`
     * const vehiculeWithIdOnly = await prisma.vehicule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehiculeCreateManyAndReturnArgs>(args?: SelectSubset<T, VehiculeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicule.
     * @param {VehiculeDeleteArgs} args - Arguments to delete one Vehicule.
     * @example
     * // Delete one Vehicule
     * const Vehicule = await prisma.vehicule.delete({
     *   where: {
     *     // ... filter to delete one Vehicule
     *   }
     * })
     * 
     */
    delete<T extends VehiculeDeleteArgs>(args: SelectSubset<T, VehiculeDeleteArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicule.
     * @param {VehiculeUpdateArgs} args - Arguments to update one Vehicule.
     * @example
     * // Update one Vehicule
     * const vehicule = await prisma.vehicule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehiculeUpdateArgs>(args: SelectSubset<T, VehiculeUpdateArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicules.
     * @param {VehiculeDeleteManyArgs} args - Arguments to filter Vehicules to delete.
     * @example
     * // Delete a few Vehicules
     * const { count } = await prisma.vehicule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehiculeDeleteManyArgs>(args?: SelectSubset<T, VehiculeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicules
     * const vehicule = await prisma.vehicule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehiculeUpdateManyArgs>(args: SelectSubset<T, VehiculeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicules and returns the data updated in the database.
     * @param {VehiculeUpdateManyAndReturnArgs} args - Arguments to update many Vehicules.
     * @example
     * // Update many Vehicules
     * const vehicule = await prisma.vehicule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicules and only return the `id`
     * const vehiculeWithIdOnly = await prisma.vehicule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehiculeUpdateManyAndReturnArgs>(args: SelectSubset<T, VehiculeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicule.
     * @param {VehiculeUpsertArgs} args - Arguments to update or create a Vehicule.
     * @example
     * // Update or create a Vehicule
     * const vehicule = await prisma.vehicule.upsert({
     *   create: {
     *     // ... data to create a Vehicule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicule we want to update
     *   }
     * })
     */
    upsert<T extends VehiculeUpsertArgs>(args: SelectSubset<T, VehiculeUpsertArgs<ExtArgs>>): Prisma__VehiculeClient<$Result.GetResult<Prisma.$VehiculePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculeCountArgs} args - Arguments to filter Vehicules to count.
     * @example
     * // Count the number of Vehicules
     * const count = await prisma.vehicule.count({
     *   where: {
     *     // ... the filter for the Vehicules we want to count
     *   }
     * })
    **/
    count<T extends VehiculeCountArgs>(
      args?: Subset<T, VehiculeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiculeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiculeAggregateArgs>(args: Subset<T, VehiculeAggregateArgs>): Prisma.PrismaPromise<GetVehiculeAggregateType<T>>

    /**
     * Group by Vehicule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehiculeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehiculeGroupByArgs['orderBy'] }
        : { orderBy?: VehiculeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehiculeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiculeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicule model
   */
  readonly fields: VehiculeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehiculeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicule model
   */
  interface VehiculeFieldRefs {
    readonly id: FieldRef<"Vehicule", 'String'>
    readonly societe: FieldRef<"Vehicule", 'String'>
    readonly marque: FieldRef<"Vehicule", 'String'>
    readonly modele: FieldRef<"Vehicule", 'String'>
    readonly immatriculation: FieldRef<"Vehicule", 'String'>
    readonly etat: FieldRef<"Vehicule", 'String'>
    readonly proprietaire: FieldRef<"Vehicule", 'String'>
    readonly dateMiseEnCirculation: FieldRef<"Vehicule", 'DateTime'>
    readonly kilometrage: FieldRef<"Vehicule", 'Int'>
    readonly kmProchaineRevision: FieldRef<"Vehicule", 'Int'>
    readonly dateLimiteControleTechnique: FieldRef<"Vehicule", 'DateTime'>
    readonly dateLimiteControlePollution: FieldRef<"Vehicule", 'DateTime'>
    readonly typeVehicule: FieldRef<"Vehicule", 'String'>
    readonly createdAt: FieldRef<"Vehicule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicule findUnique
   */
  export type VehiculeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * Filter, which Vehicule to fetch.
     */
    where: VehiculeWhereUniqueInput
  }

  /**
   * Vehicule findUniqueOrThrow
   */
  export type VehiculeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * Filter, which Vehicule to fetch.
     */
    where: VehiculeWhereUniqueInput
  }

  /**
   * Vehicule findFirst
   */
  export type VehiculeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * Filter, which Vehicule to fetch.
     */
    where?: VehiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicules to fetch.
     */
    orderBy?: VehiculeOrderByWithRelationInput | VehiculeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicules.
     */
    cursor?: VehiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicules.
     */
    distinct?: VehiculeScalarFieldEnum | VehiculeScalarFieldEnum[]
  }

  /**
   * Vehicule findFirstOrThrow
   */
  export type VehiculeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * Filter, which Vehicule to fetch.
     */
    where?: VehiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicules to fetch.
     */
    orderBy?: VehiculeOrderByWithRelationInput | VehiculeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicules.
     */
    cursor?: VehiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicules.
     */
    distinct?: VehiculeScalarFieldEnum | VehiculeScalarFieldEnum[]
  }

  /**
   * Vehicule findMany
   */
  export type VehiculeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * Filter, which Vehicules to fetch.
     */
    where?: VehiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicules to fetch.
     */
    orderBy?: VehiculeOrderByWithRelationInput | VehiculeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicules.
     */
    cursor?: VehiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicules.
     */
    skip?: number
    distinct?: VehiculeScalarFieldEnum | VehiculeScalarFieldEnum[]
  }

  /**
   * Vehicule create
   */
  export type VehiculeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * The data needed to create a Vehicule.
     */
    data: XOR<VehiculeCreateInput, VehiculeUncheckedCreateInput>
  }

  /**
   * Vehicule createMany
   */
  export type VehiculeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicules.
     */
    data: VehiculeCreateManyInput | VehiculeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicule createManyAndReturn
   */
  export type VehiculeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicules.
     */
    data: VehiculeCreateManyInput | VehiculeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicule update
   */
  export type VehiculeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * The data needed to update a Vehicule.
     */
    data: XOR<VehiculeUpdateInput, VehiculeUncheckedUpdateInput>
    /**
     * Choose, which Vehicule to update.
     */
    where: VehiculeWhereUniqueInput
  }

  /**
   * Vehicule updateMany
   */
  export type VehiculeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicules.
     */
    data: XOR<VehiculeUpdateManyMutationInput, VehiculeUncheckedUpdateManyInput>
    /**
     * Filter which Vehicules to update
     */
    where?: VehiculeWhereInput
    /**
     * Limit how many Vehicules to update.
     */
    limit?: number
  }

  /**
   * Vehicule updateManyAndReturn
   */
  export type VehiculeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * The data used to update Vehicules.
     */
    data: XOR<VehiculeUpdateManyMutationInput, VehiculeUncheckedUpdateManyInput>
    /**
     * Filter which Vehicules to update
     */
    where?: VehiculeWhereInput
    /**
     * Limit how many Vehicules to update.
     */
    limit?: number
  }

  /**
   * Vehicule upsert
   */
  export type VehiculeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * The filter to search for the Vehicule to update in case it exists.
     */
    where: VehiculeWhereUniqueInput
    /**
     * In case the Vehicule found by the `where` argument doesn't exist, create a new Vehicule with this data.
     */
    create: XOR<VehiculeCreateInput, VehiculeUncheckedCreateInput>
    /**
     * In case the Vehicule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehiculeUpdateInput, VehiculeUncheckedUpdateInput>
  }

  /**
   * Vehicule delete
   */
  export type VehiculeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
    /**
     * Filter which Vehicule to delete.
     */
    where: VehiculeWhereUniqueInput
  }

  /**
   * Vehicule deleteMany
   */
  export type VehiculeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicules to delete
     */
    where?: VehiculeWhereInput
    /**
     * Limit how many Vehicules to delete.
     */
    limit?: number
  }

  /**
   * Vehicule without action
   */
  export type VehiculeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicule
     */
    select?: VehiculeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicule
     */
    omit?: VehiculeOmit<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    montantDevis: number | null
  }

  export type ContactSumAggregateOutputType = {
    montantDevis: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    codePostal: string | null
    ville: string | null
    status: string | null
    commentaires: string | null
    dateCreation: Date | null
    dateDerniereModification: Date | null
    utilisateurId: string | null
    montantDevis: number | null
    archived: boolean | null
    archiveDate: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    codePostal: string | null
    ville: string | null
    status: string | null
    commentaires: string | null
    dateCreation: Date | null
    dateDerniereModification: Date | null
    utilisateurId: string | null
    montantDevis: number | null
    archived: boolean | null
    archiveDate: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    email: number
    telephone: number
    adresse: number
    codePostal: number
    ville: number
    categories: number
    status: number
    commentaires: number
    dateCreation: number
    dateDerniereModification: number
    utilisateurId: number
    collaborateursIds: number
    montantDevis: number
    archived: number
    archiveDate: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    montantDevis?: true
  }

  export type ContactSumAggregateInputType = {
    montantDevis?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    status?: true
    commentaires?: true
    dateCreation?: true
    dateDerniereModification?: true
    utilisateurId?: true
    montantDevis?: true
    archived?: true
    archiveDate?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    status?: true
    commentaires?: true
    dateCreation?: true
    dateDerniereModification?: true
    utilisateurId?: true
    montantDevis?: true
    archived?: true
    archiveDate?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    categories?: true
    status?: true
    commentaires?: true
    dateCreation?: true
    dateDerniereModification?: true
    utilisateurId?: true
    collaborateursIds?: true
    montantDevis?: true
    archived?: true
    archiveDate?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories: string[]
    status: string
    commentaires: string | null
    dateCreation: Date
    dateDerniereModification: Date
    utilisateurId: string
    collaborateursIds: string[]
    montantDevis: number | null
    archived: boolean
    archiveDate: Date | null
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    categories?: boolean
    status?: boolean
    commentaires?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
    utilisateurId?: boolean
    collaborateursIds?: boolean
    montantDevis?: boolean
    archived?: boolean
    archiveDate?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateurs?: boolean | Contact$collaborateursArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    categories?: boolean
    status?: boolean
    commentaires?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
    utilisateurId?: boolean
    collaborateursIds?: boolean
    montantDevis?: boolean
    archived?: boolean
    archiveDate?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    categories?: boolean
    status?: boolean
    commentaires?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
    utilisateurId?: boolean
    collaborateursIds?: boolean
    montantDevis?: boolean
    archived?: boolean
    archiveDate?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    categories?: boolean
    status?: boolean
    commentaires?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
    utilisateurId?: boolean
    collaborateursIds?: boolean
    montantDevis?: boolean
    archived?: boolean
    archiveDate?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "prenom" | "email" | "telephone" | "adresse" | "codePostal" | "ville" | "categories" | "status" | "commentaires" | "dateCreation" | "dateDerniereModification" | "utilisateurId" | "collaborateursIds" | "montantDevis" | "archived" | "archiveDate", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateurs?: boolean | Contact$collaborateursArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      utilisateur: Prisma.$ComptePayload<ExtArgs>
      collaborateurs: Prisma.$CollaborateurPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      prenom: string
      email: string
      telephone: string
      adresse: string
      codePostal: string
      ville: string
      categories: string[]
      status: string
      commentaires: string | null
      dateCreation: Date
      dateDerniereModification: Date
      utilisateurId: string
      collaborateursIds: string[]
      montantDevis: number | null
      archived: boolean
      archiveDate: Date | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends CompteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompteDefaultArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    collaborateurs<T extends Contact$collaborateursArgs<ExtArgs> = {}>(args?: Subset<T, Contact$collaborateursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly nom: FieldRef<"Contact", 'String'>
    readonly prenom: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly telephone: FieldRef<"Contact", 'String'>
    readonly adresse: FieldRef<"Contact", 'String'>
    readonly codePostal: FieldRef<"Contact", 'String'>
    readonly ville: FieldRef<"Contact", 'String'>
    readonly categories: FieldRef<"Contact", 'String[]'>
    readonly status: FieldRef<"Contact", 'String'>
    readonly commentaires: FieldRef<"Contact", 'String'>
    readonly dateCreation: FieldRef<"Contact", 'DateTime'>
    readonly dateDerniereModification: FieldRef<"Contact", 'DateTime'>
    readonly utilisateurId: FieldRef<"Contact", 'String'>
    readonly collaborateursIds: FieldRef<"Contact", 'String[]'>
    readonly montantDevis: FieldRef<"Contact", 'Float'>
    readonly archived: FieldRef<"Contact", 'Boolean'>
    readonly archiveDate: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.collaborateurs
   */
  export type Contact$collaborateursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    where?: CollaborateurWhereInput
    orderBy?: CollaborateurOrderByWithRelationInput | CollaborateurOrderByWithRelationInput[]
    cursor?: CollaborateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollaborateurScalarFieldEnum | CollaborateurScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model DemandeConge
   */

  export type AggregateDemandeConge = {
    _count: DemandeCongeCountAggregateOutputType | null
    _min: DemandeCongeMinAggregateOutputType | null
    _max: DemandeCongeMaxAggregateOutputType | null
  }

  export type DemandeCongeMinAggregateOutputType = {
    id: string | null
    utilisateurId: string | null
    collaborateurId: string | null
    collaborateurNom: string | null
    dateDebut: Date | null
    dateFin: Date | null
    typeConge: string | null
    motif: string | null
    statut: string | null
    commentaireAdmin: string | null
    dateCreation: Date | null
    dateModification: Date | null
    notificationLue: boolean | null
  }

  export type DemandeCongeMaxAggregateOutputType = {
    id: string | null
    utilisateurId: string | null
    collaborateurId: string | null
    collaborateurNom: string | null
    dateDebut: Date | null
    dateFin: Date | null
    typeConge: string | null
    motif: string | null
    statut: string | null
    commentaireAdmin: string | null
    dateCreation: Date | null
    dateModification: Date | null
    notificationLue: boolean | null
  }

  export type DemandeCongeCountAggregateOutputType = {
    id: number
    utilisateurId: number
    collaborateurId: number
    collaborateurNom: number
    dateDebut: number
    dateFin: number
    typeConge: number
    motif: number
    statut: number
    commentaireAdmin: number
    dateCreation: number
    dateModification: number
    notificationLue: number
    _all: number
  }


  export type DemandeCongeMinAggregateInputType = {
    id?: true
    utilisateurId?: true
    collaborateurId?: true
    collaborateurNom?: true
    dateDebut?: true
    dateFin?: true
    typeConge?: true
    motif?: true
    statut?: true
    commentaireAdmin?: true
    dateCreation?: true
    dateModification?: true
    notificationLue?: true
  }

  export type DemandeCongeMaxAggregateInputType = {
    id?: true
    utilisateurId?: true
    collaborateurId?: true
    collaborateurNom?: true
    dateDebut?: true
    dateFin?: true
    typeConge?: true
    motif?: true
    statut?: true
    commentaireAdmin?: true
    dateCreation?: true
    dateModification?: true
    notificationLue?: true
  }

  export type DemandeCongeCountAggregateInputType = {
    id?: true
    utilisateurId?: true
    collaborateurId?: true
    collaborateurNom?: true
    dateDebut?: true
    dateFin?: true
    typeConge?: true
    motif?: true
    statut?: true
    commentaireAdmin?: true
    dateCreation?: true
    dateModification?: true
    notificationLue?: true
    _all?: true
  }

  export type DemandeCongeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DemandeConge to aggregate.
     */
    where?: DemandeCongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemandeConges to fetch.
     */
    orderBy?: DemandeCongeOrderByWithRelationInput | DemandeCongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DemandeCongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemandeConges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemandeConges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DemandeConges
    **/
    _count?: true | DemandeCongeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DemandeCongeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DemandeCongeMaxAggregateInputType
  }

  export type GetDemandeCongeAggregateType<T extends DemandeCongeAggregateArgs> = {
        [P in keyof T & keyof AggregateDemandeConge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemandeConge[P]>
      : GetScalarType<T[P], AggregateDemandeConge[P]>
  }




  export type DemandeCongeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DemandeCongeWhereInput
    orderBy?: DemandeCongeOrderByWithAggregationInput | DemandeCongeOrderByWithAggregationInput[]
    by: DemandeCongeScalarFieldEnum[] | DemandeCongeScalarFieldEnum
    having?: DemandeCongeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DemandeCongeCountAggregateInputType | true
    _min?: DemandeCongeMinAggregateInputType
    _max?: DemandeCongeMaxAggregateInputType
  }

  export type DemandeCongeGroupByOutputType = {
    id: string
    utilisateurId: string
    collaborateurId: string
    collaborateurNom: string
    dateDebut: Date
    dateFin: Date
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin: string | null
    dateCreation: Date
    dateModification: Date
    notificationLue: boolean
    _count: DemandeCongeCountAggregateOutputType | null
    _min: DemandeCongeMinAggregateOutputType | null
    _max: DemandeCongeMaxAggregateOutputType | null
  }

  type GetDemandeCongeGroupByPayload<T extends DemandeCongeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DemandeCongeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DemandeCongeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DemandeCongeGroupByOutputType[P]>
            : GetScalarType<T[P], DemandeCongeGroupByOutputType[P]>
        }
      >
    >


  export type DemandeCongeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    collaborateurId?: boolean
    collaborateurNom?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    typeConge?: boolean
    motif?: boolean
    statut?: boolean
    commentaireAdmin?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    notificationLue?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
    notifications?: boolean | DemandeConge$notificationsArgs<ExtArgs>
    _count?: boolean | DemandeCongeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demandeConge"]>

  export type DemandeCongeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    collaborateurId?: boolean
    collaborateurNom?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    typeConge?: boolean
    motif?: boolean
    statut?: boolean
    commentaireAdmin?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    notificationLue?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demandeConge"]>

  export type DemandeCongeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    collaborateurId?: boolean
    collaborateurNom?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    typeConge?: boolean
    motif?: boolean
    statut?: boolean
    commentaireAdmin?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    notificationLue?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demandeConge"]>

  export type DemandeCongeSelectScalar = {
    id?: boolean
    utilisateurId?: boolean
    collaborateurId?: boolean
    collaborateurNom?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    typeConge?: boolean
    motif?: boolean
    statut?: boolean
    commentaireAdmin?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    notificationLue?: boolean
  }

  export type DemandeCongeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "utilisateurId" | "collaborateurId" | "collaborateurNom" | "dateDebut" | "dateFin" | "typeConge" | "motif" | "statut" | "commentaireAdmin" | "dateCreation" | "dateModification" | "notificationLue", ExtArgs["result"]["demandeConge"]>
  export type DemandeCongeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
    notifications?: boolean | DemandeConge$notificationsArgs<ExtArgs>
    _count?: boolean | DemandeCongeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DemandeCongeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }
  export type DemandeCongeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    collaborateur?: boolean | CollaborateurDefaultArgs<ExtArgs>
  }

  export type $DemandeCongePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DemandeConge"
    objects: {
      utilisateur: Prisma.$ComptePayload<ExtArgs>
      collaborateur: Prisma.$CollaborateurPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      utilisateurId: string
      collaborateurId: string
      collaborateurNom: string
      dateDebut: Date
      dateFin: Date
      typeConge: string
      motif: string
      statut: string
      commentaireAdmin: string | null
      dateCreation: Date
      dateModification: Date
      notificationLue: boolean
    }, ExtArgs["result"]["demandeConge"]>
    composites: {}
  }

  type DemandeCongeGetPayload<S extends boolean | null | undefined | DemandeCongeDefaultArgs> = $Result.GetResult<Prisma.$DemandeCongePayload, S>

  type DemandeCongeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DemandeCongeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DemandeCongeCountAggregateInputType | true
    }

  export interface DemandeCongeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DemandeConge'], meta: { name: 'DemandeConge' } }
    /**
     * Find zero or one DemandeConge that matches the filter.
     * @param {DemandeCongeFindUniqueArgs} args - Arguments to find a DemandeConge
     * @example
     * // Get one DemandeConge
     * const demandeConge = await prisma.demandeConge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DemandeCongeFindUniqueArgs>(args: SelectSubset<T, DemandeCongeFindUniqueArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DemandeConge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DemandeCongeFindUniqueOrThrowArgs} args - Arguments to find a DemandeConge
     * @example
     * // Get one DemandeConge
     * const demandeConge = await prisma.demandeConge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DemandeCongeFindUniqueOrThrowArgs>(args: SelectSubset<T, DemandeCongeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DemandeConge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemandeCongeFindFirstArgs} args - Arguments to find a DemandeConge
     * @example
     * // Get one DemandeConge
     * const demandeConge = await prisma.demandeConge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DemandeCongeFindFirstArgs>(args?: SelectSubset<T, DemandeCongeFindFirstArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DemandeConge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemandeCongeFindFirstOrThrowArgs} args - Arguments to find a DemandeConge
     * @example
     * // Get one DemandeConge
     * const demandeConge = await prisma.demandeConge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DemandeCongeFindFirstOrThrowArgs>(args?: SelectSubset<T, DemandeCongeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DemandeConges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemandeCongeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DemandeConges
     * const demandeConges = await prisma.demandeConge.findMany()
     * 
     * // Get first 10 DemandeConges
     * const demandeConges = await prisma.demandeConge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const demandeCongeWithIdOnly = await prisma.demandeConge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DemandeCongeFindManyArgs>(args?: SelectSubset<T, DemandeCongeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DemandeConge.
     * @param {DemandeCongeCreateArgs} args - Arguments to create a DemandeConge.
     * @example
     * // Create one DemandeConge
     * const DemandeConge = await prisma.demandeConge.create({
     *   data: {
     *     // ... data to create a DemandeConge
     *   }
     * })
     * 
     */
    create<T extends DemandeCongeCreateArgs>(args: SelectSubset<T, DemandeCongeCreateArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DemandeConges.
     * @param {DemandeCongeCreateManyArgs} args - Arguments to create many DemandeConges.
     * @example
     * // Create many DemandeConges
     * const demandeConge = await prisma.demandeConge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DemandeCongeCreateManyArgs>(args?: SelectSubset<T, DemandeCongeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DemandeConges and returns the data saved in the database.
     * @param {DemandeCongeCreateManyAndReturnArgs} args - Arguments to create many DemandeConges.
     * @example
     * // Create many DemandeConges
     * const demandeConge = await prisma.demandeConge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DemandeConges and only return the `id`
     * const demandeCongeWithIdOnly = await prisma.demandeConge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DemandeCongeCreateManyAndReturnArgs>(args?: SelectSubset<T, DemandeCongeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DemandeConge.
     * @param {DemandeCongeDeleteArgs} args - Arguments to delete one DemandeConge.
     * @example
     * // Delete one DemandeConge
     * const DemandeConge = await prisma.demandeConge.delete({
     *   where: {
     *     // ... filter to delete one DemandeConge
     *   }
     * })
     * 
     */
    delete<T extends DemandeCongeDeleteArgs>(args: SelectSubset<T, DemandeCongeDeleteArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DemandeConge.
     * @param {DemandeCongeUpdateArgs} args - Arguments to update one DemandeConge.
     * @example
     * // Update one DemandeConge
     * const demandeConge = await prisma.demandeConge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DemandeCongeUpdateArgs>(args: SelectSubset<T, DemandeCongeUpdateArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DemandeConges.
     * @param {DemandeCongeDeleteManyArgs} args - Arguments to filter DemandeConges to delete.
     * @example
     * // Delete a few DemandeConges
     * const { count } = await prisma.demandeConge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DemandeCongeDeleteManyArgs>(args?: SelectSubset<T, DemandeCongeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DemandeConges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemandeCongeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DemandeConges
     * const demandeConge = await prisma.demandeConge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DemandeCongeUpdateManyArgs>(args: SelectSubset<T, DemandeCongeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DemandeConges and returns the data updated in the database.
     * @param {DemandeCongeUpdateManyAndReturnArgs} args - Arguments to update many DemandeConges.
     * @example
     * // Update many DemandeConges
     * const demandeConge = await prisma.demandeConge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DemandeConges and only return the `id`
     * const demandeCongeWithIdOnly = await prisma.demandeConge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DemandeCongeUpdateManyAndReturnArgs>(args: SelectSubset<T, DemandeCongeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DemandeConge.
     * @param {DemandeCongeUpsertArgs} args - Arguments to update or create a DemandeConge.
     * @example
     * // Update or create a DemandeConge
     * const demandeConge = await prisma.demandeConge.upsert({
     *   create: {
     *     // ... data to create a DemandeConge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DemandeConge we want to update
     *   }
     * })
     */
    upsert<T extends DemandeCongeUpsertArgs>(args: SelectSubset<T, DemandeCongeUpsertArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DemandeConges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemandeCongeCountArgs} args - Arguments to filter DemandeConges to count.
     * @example
     * // Count the number of DemandeConges
     * const count = await prisma.demandeConge.count({
     *   where: {
     *     // ... the filter for the DemandeConges we want to count
     *   }
     * })
    **/
    count<T extends DemandeCongeCountArgs>(
      args?: Subset<T, DemandeCongeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DemandeCongeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DemandeConge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemandeCongeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DemandeCongeAggregateArgs>(args: Subset<T, DemandeCongeAggregateArgs>): Prisma.PrismaPromise<GetDemandeCongeAggregateType<T>>

    /**
     * Group by DemandeConge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemandeCongeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DemandeCongeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DemandeCongeGroupByArgs['orderBy'] }
        : { orderBy?: DemandeCongeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DemandeCongeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDemandeCongeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DemandeConge model
   */
  readonly fields: DemandeCongeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DemandeConge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DemandeCongeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends CompteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompteDefaultArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    collaborateur<T extends CollaborateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollaborateurDefaultArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends DemandeConge$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, DemandeConge$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DemandeConge model
   */
  interface DemandeCongeFieldRefs {
    readonly id: FieldRef<"DemandeConge", 'String'>
    readonly utilisateurId: FieldRef<"DemandeConge", 'String'>
    readonly collaborateurId: FieldRef<"DemandeConge", 'String'>
    readonly collaborateurNom: FieldRef<"DemandeConge", 'String'>
    readonly dateDebut: FieldRef<"DemandeConge", 'DateTime'>
    readonly dateFin: FieldRef<"DemandeConge", 'DateTime'>
    readonly typeConge: FieldRef<"DemandeConge", 'String'>
    readonly motif: FieldRef<"DemandeConge", 'String'>
    readonly statut: FieldRef<"DemandeConge", 'String'>
    readonly commentaireAdmin: FieldRef<"DemandeConge", 'String'>
    readonly dateCreation: FieldRef<"DemandeConge", 'DateTime'>
    readonly dateModification: FieldRef<"DemandeConge", 'DateTime'>
    readonly notificationLue: FieldRef<"DemandeConge", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DemandeConge findUnique
   */
  export type DemandeCongeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * Filter, which DemandeConge to fetch.
     */
    where: DemandeCongeWhereUniqueInput
  }

  /**
   * DemandeConge findUniqueOrThrow
   */
  export type DemandeCongeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * Filter, which DemandeConge to fetch.
     */
    where: DemandeCongeWhereUniqueInput
  }

  /**
   * DemandeConge findFirst
   */
  export type DemandeCongeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * Filter, which DemandeConge to fetch.
     */
    where?: DemandeCongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemandeConges to fetch.
     */
    orderBy?: DemandeCongeOrderByWithRelationInput | DemandeCongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DemandeConges.
     */
    cursor?: DemandeCongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemandeConges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemandeConges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DemandeConges.
     */
    distinct?: DemandeCongeScalarFieldEnum | DemandeCongeScalarFieldEnum[]
  }

  /**
   * DemandeConge findFirstOrThrow
   */
  export type DemandeCongeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * Filter, which DemandeConge to fetch.
     */
    where?: DemandeCongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemandeConges to fetch.
     */
    orderBy?: DemandeCongeOrderByWithRelationInput | DemandeCongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DemandeConges.
     */
    cursor?: DemandeCongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemandeConges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemandeConges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DemandeConges.
     */
    distinct?: DemandeCongeScalarFieldEnum | DemandeCongeScalarFieldEnum[]
  }

  /**
   * DemandeConge findMany
   */
  export type DemandeCongeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * Filter, which DemandeConges to fetch.
     */
    where?: DemandeCongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DemandeConges to fetch.
     */
    orderBy?: DemandeCongeOrderByWithRelationInput | DemandeCongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DemandeConges.
     */
    cursor?: DemandeCongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DemandeConges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DemandeConges.
     */
    skip?: number
    distinct?: DemandeCongeScalarFieldEnum | DemandeCongeScalarFieldEnum[]
  }

  /**
   * DemandeConge create
   */
  export type DemandeCongeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * The data needed to create a DemandeConge.
     */
    data: XOR<DemandeCongeCreateInput, DemandeCongeUncheckedCreateInput>
  }

  /**
   * DemandeConge createMany
   */
  export type DemandeCongeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DemandeConges.
     */
    data: DemandeCongeCreateManyInput | DemandeCongeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DemandeConge createManyAndReturn
   */
  export type DemandeCongeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * The data used to create many DemandeConges.
     */
    data: DemandeCongeCreateManyInput | DemandeCongeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DemandeConge update
   */
  export type DemandeCongeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * The data needed to update a DemandeConge.
     */
    data: XOR<DemandeCongeUpdateInput, DemandeCongeUncheckedUpdateInput>
    /**
     * Choose, which DemandeConge to update.
     */
    where: DemandeCongeWhereUniqueInput
  }

  /**
   * DemandeConge updateMany
   */
  export type DemandeCongeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DemandeConges.
     */
    data: XOR<DemandeCongeUpdateManyMutationInput, DemandeCongeUncheckedUpdateManyInput>
    /**
     * Filter which DemandeConges to update
     */
    where?: DemandeCongeWhereInput
    /**
     * Limit how many DemandeConges to update.
     */
    limit?: number
  }

  /**
   * DemandeConge updateManyAndReturn
   */
  export type DemandeCongeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * The data used to update DemandeConges.
     */
    data: XOR<DemandeCongeUpdateManyMutationInput, DemandeCongeUncheckedUpdateManyInput>
    /**
     * Filter which DemandeConges to update
     */
    where?: DemandeCongeWhereInput
    /**
     * Limit how many DemandeConges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DemandeConge upsert
   */
  export type DemandeCongeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * The filter to search for the DemandeConge to update in case it exists.
     */
    where: DemandeCongeWhereUniqueInput
    /**
     * In case the DemandeConge found by the `where` argument doesn't exist, create a new DemandeConge with this data.
     */
    create: XOR<DemandeCongeCreateInput, DemandeCongeUncheckedCreateInput>
    /**
     * In case the DemandeConge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DemandeCongeUpdateInput, DemandeCongeUncheckedUpdateInput>
  }

  /**
   * DemandeConge delete
   */
  export type DemandeCongeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    /**
     * Filter which DemandeConge to delete.
     */
    where: DemandeCongeWhereUniqueInput
  }

  /**
   * DemandeConge deleteMany
   */
  export type DemandeCongeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DemandeConges to delete
     */
    where?: DemandeCongeWhereInput
    /**
     * Limit how many DemandeConges to delete.
     */
    limit?: number
  }

  /**
   * DemandeConge.notifications
   */
  export type DemandeConge$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * DemandeConge without action
   */
  export type DemandeCongeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    utilisateurId: string | null
    message: string | null
    lien: string | null
    dateCreation: Date | null
    lue: boolean | null
    type: string | null
    demandeId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    utilisateurId: string | null
    message: string | null
    lien: string | null
    dateCreation: Date | null
    lue: boolean | null
    type: string | null
    demandeId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    utilisateurId: number
    message: number
    lien: number
    dateCreation: number
    lue: number
    type: number
    demandeId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    utilisateurId?: true
    message?: true
    lien?: true
    dateCreation?: true
    lue?: true
    type?: true
    demandeId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    utilisateurId?: true
    message?: true
    lien?: true
    dateCreation?: true
    lue?: true
    type?: true
    demandeId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    utilisateurId?: true
    message?: true
    lien?: true
    dateCreation?: true
    lue?: true
    type?: true
    demandeId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    utilisateurId: string
    message: string
    lien: string
    dateCreation: Date
    lue: boolean
    type: string
    demandeId: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    message?: boolean
    lien?: boolean
    dateCreation?: boolean
    lue?: boolean
    type?: boolean
    demandeId?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    demandeConge?: boolean | Notification$demandeCongeArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    message?: boolean
    lien?: boolean
    dateCreation?: boolean
    lue?: boolean
    type?: boolean
    demandeId?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    demandeConge?: boolean | Notification$demandeCongeArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    message?: boolean
    lien?: boolean
    dateCreation?: boolean
    lue?: boolean
    type?: boolean
    demandeId?: boolean
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    demandeConge?: boolean | Notification$demandeCongeArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    utilisateurId?: boolean
    message?: boolean
    lien?: boolean
    dateCreation?: boolean
    lue?: boolean
    type?: boolean
    demandeId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "utilisateurId" | "message" | "lien" | "dateCreation" | "lue" | "type" | "demandeId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    demandeConge?: boolean | Notification$demandeCongeArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    demandeConge?: boolean | Notification$demandeCongeArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | CompteDefaultArgs<ExtArgs>
    demandeConge?: boolean | Notification$demandeCongeArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      utilisateur: Prisma.$ComptePayload<ExtArgs>
      demandeConge: Prisma.$DemandeCongePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      utilisateurId: string
      message: string
      lien: string
      dateCreation: Date
      lue: boolean
      type: string
      demandeId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends CompteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompteDefaultArgs<ExtArgs>>): Prisma__CompteClient<$Result.GetResult<Prisma.$ComptePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    demandeConge<T extends Notification$demandeCongeArgs<ExtArgs> = {}>(args?: Subset<T, Notification$demandeCongeArgs<ExtArgs>>): Prisma__DemandeCongeClient<$Result.GetResult<Prisma.$DemandeCongePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly utilisateurId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly lien: FieldRef<"Notification", 'String'>
    readonly dateCreation: FieldRef<"Notification", 'DateTime'>
    readonly lue: FieldRef<"Notification", 'Boolean'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly demandeId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.demandeConge
   */
  export type Notification$demandeCongeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DemandeConge
     */
    select?: DemandeCongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DemandeConge
     */
    omit?: DemandeCongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DemandeCongeInclude<ExtArgs> | null
    where?: DemandeCongeWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ContratMaintenance
   */

  export type AggregateContratMaintenance = {
    _count: ContratMaintenanceCountAggregateOutputType | null
    _avg: ContratMaintenanceAvgAggregateOutputType | null
    _sum: ContratMaintenanceSumAggregateOutputType | null
    _min: ContratMaintenanceMinAggregateOutputType | null
    _max: ContratMaintenanceMaxAggregateOutputType | null
  }

  export type ContratMaintenanceAvgAggregateOutputType = {
    montant: number | null
  }

  export type ContratMaintenanceSumAggregateOutputType = {
    montant: number | null
  }

  export type ContratMaintenanceMinAggregateOutputType = {
    id: string | null
    client: string | null
    reference: string | null
    type: string | null
    montant: number | null
    dateDebut: Date | null
    dateEcheance: Date | null
    statut: string | null
    description: string | null
    contactClient: string | null
    emailContact: string | null
    telephoneContact: string | null
    notes: string | null
    dateCreation: Date | null
    dateDerniereModification: Date | null
  }

  export type ContratMaintenanceMaxAggregateOutputType = {
    id: string | null
    client: string | null
    reference: string | null
    type: string | null
    montant: number | null
    dateDebut: Date | null
    dateEcheance: Date | null
    statut: string | null
    description: string | null
    contactClient: string | null
    emailContact: string | null
    telephoneContact: string | null
    notes: string | null
    dateCreation: Date | null
    dateDerniereModification: Date | null
  }

  export type ContratMaintenanceCountAggregateOutputType = {
    id: number
    client: number
    reference: number
    type: number
    montant: number
    dateDebut: number
    dateEcheance: number
    statut: number
    description: number
    contactClient: number
    emailContact: number
    telephoneContact: number
    notes: number
    dateCreation: number
    dateDerniereModification: number
    _all: number
  }


  export type ContratMaintenanceAvgAggregateInputType = {
    montant?: true
  }

  export type ContratMaintenanceSumAggregateInputType = {
    montant?: true
  }

  export type ContratMaintenanceMinAggregateInputType = {
    id?: true
    client?: true
    reference?: true
    type?: true
    montant?: true
    dateDebut?: true
    dateEcheance?: true
    statut?: true
    description?: true
    contactClient?: true
    emailContact?: true
    telephoneContact?: true
    notes?: true
    dateCreation?: true
    dateDerniereModification?: true
  }

  export type ContratMaintenanceMaxAggregateInputType = {
    id?: true
    client?: true
    reference?: true
    type?: true
    montant?: true
    dateDebut?: true
    dateEcheance?: true
    statut?: true
    description?: true
    contactClient?: true
    emailContact?: true
    telephoneContact?: true
    notes?: true
    dateCreation?: true
    dateDerniereModification?: true
  }

  export type ContratMaintenanceCountAggregateInputType = {
    id?: true
    client?: true
    reference?: true
    type?: true
    montant?: true
    dateDebut?: true
    dateEcheance?: true
    statut?: true
    description?: true
    contactClient?: true
    emailContact?: true
    telephoneContact?: true
    notes?: true
    dateCreation?: true
    dateDerniereModification?: true
    _all?: true
  }

  export type ContratMaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContratMaintenance to aggregate.
     */
    where?: ContratMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContratMaintenances to fetch.
     */
    orderBy?: ContratMaintenanceOrderByWithRelationInput | ContratMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContratMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContratMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContratMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContratMaintenances
    **/
    _count?: true | ContratMaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContratMaintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContratMaintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContratMaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContratMaintenanceMaxAggregateInputType
  }

  export type GetContratMaintenanceAggregateType<T extends ContratMaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateContratMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContratMaintenance[P]>
      : GetScalarType<T[P], AggregateContratMaintenance[P]>
  }




  export type ContratMaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratMaintenanceWhereInput
    orderBy?: ContratMaintenanceOrderByWithAggregationInput | ContratMaintenanceOrderByWithAggregationInput[]
    by: ContratMaintenanceScalarFieldEnum[] | ContratMaintenanceScalarFieldEnum
    having?: ContratMaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContratMaintenanceCountAggregateInputType | true
    _avg?: ContratMaintenanceAvgAggregateInputType
    _sum?: ContratMaintenanceSumAggregateInputType
    _min?: ContratMaintenanceMinAggregateInputType
    _max?: ContratMaintenanceMaxAggregateInputType
  }

  export type ContratMaintenanceGroupByOutputType = {
    id: string
    client: string
    reference: string
    type: string
    montant: number
    dateDebut: Date
    dateEcheance: Date
    statut: string
    description: string
    contactClient: string
    emailContact: string
    telephoneContact: string
    notes: string | null
    dateCreation: Date
    dateDerniereModification: Date
    _count: ContratMaintenanceCountAggregateOutputType | null
    _avg: ContratMaintenanceAvgAggregateOutputType | null
    _sum: ContratMaintenanceSumAggregateOutputType | null
    _min: ContratMaintenanceMinAggregateOutputType | null
    _max: ContratMaintenanceMaxAggregateOutputType | null
  }

  type GetContratMaintenanceGroupByPayload<T extends ContratMaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContratMaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContratMaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContratMaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], ContratMaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type ContratMaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client?: boolean
    reference?: boolean
    type?: boolean
    montant?: boolean
    dateDebut?: boolean
    dateEcheance?: boolean
    statut?: boolean
    description?: boolean
    contactClient?: boolean
    emailContact?: boolean
    telephoneContact?: boolean
    notes?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
  }, ExtArgs["result"]["contratMaintenance"]>

  export type ContratMaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client?: boolean
    reference?: boolean
    type?: boolean
    montant?: boolean
    dateDebut?: boolean
    dateEcheance?: boolean
    statut?: boolean
    description?: boolean
    contactClient?: boolean
    emailContact?: boolean
    telephoneContact?: boolean
    notes?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
  }, ExtArgs["result"]["contratMaintenance"]>

  export type ContratMaintenanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client?: boolean
    reference?: boolean
    type?: boolean
    montant?: boolean
    dateDebut?: boolean
    dateEcheance?: boolean
    statut?: boolean
    description?: boolean
    contactClient?: boolean
    emailContact?: boolean
    telephoneContact?: boolean
    notes?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
  }, ExtArgs["result"]["contratMaintenance"]>

  export type ContratMaintenanceSelectScalar = {
    id?: boolean
    client?: boolean
    reference?: boolean
    type?: boolean
    montant?: boolean
    dateDebut?: boolean
    dateEcheance?: boolean
    statut?: boolean
    description?: boolean
    contactClient?: boolean
    emailContact?: boolean
    telephoneContact?: boolean
    notes?: boolean
    dateCreation?: boolean
    dateDerniereModification?: boolean
  }

  export type ContratMaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client" | "reference" | "type" | "montant" | "dateDebut" | "dateEcheance" | "statut" | "description" | "contactClient" | "emailContact" | "telephoneContact" | "notes" | "dateCreation" | "dateDerniereModification", ExtArgs["result"]["contratMaintenance"]>

  export type $ContratMaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContratMaintenance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client: string
      reference: string
      type: string
      montant: number
      dateDebut: Date
      dateEcheance: Date
      statut: string
      description: string
      contactClient: string
      emailContact: string
      telephoneContact: string
      notes: string | null
      dateCreation: Date
      dateDerniereModification: Date
    }, ExtArgs["result"]["contratMaintenance"]>
    composites: {}
  }

  type ContratMaintenanceGetPayload<S extends boolean | null | undefined | ContratMaintenanceDefaultArgs> = $Result.GetResult<Prisma.$ContratMaintenancePayload, S>

  type ContratMaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContratMaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContratMaintenanceCountAggregateInputType | true
    }

  export interface ContratMaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContratMaintenance'], meta: { name: 'ContratMaintenance' } }
    /**
     * Find zero or one ContratMaintenance that matches the filter.
     * @param {ContratMaintenanceFindUniqueArgs} args - Arguments to find a ContratMaintenance
     * @example
     * // Get one ContratMaintenance
     * const contratMaintenance = await prisma.contratMaintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContratMaintenanceFindUniqueArgs>(args: SelectSubset<T, ContratMaintenanceFindUniqueArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContratMaintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContratMaintenanceFindUniqueOrThrowArgs} args - Arguments to find a ContratMaintenance
     * @example
     * // Get one ContratMaintenance
     * const contratMaintenance = await prisma.contratMaintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContratMaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, ContratMaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContratMaintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratMaintenanceFindFirstArgs} args - Arguments to find a ContratMaintenance
     * @example
     * // Get one ContratMaintenance
     * const contratMaintenance = await prisma.contratMaintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContratMaintenanceFindFirstArgs>(args?: SelectSubset<T, ContratMaintenanceFindFirstArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContratMaintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratMaintenanceFindFirstOrThrowArgs} args - Arguments to find a ContratMaintenance
     * @example
     * // Get one ContratMaintenance
     * const contratMaintenance = await prisma.contratMaintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContratMaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, ContratMaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContratMaintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratMaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContratMaintenances
     * const contratMaintenances = await prisma.contratMaintenance.findMany()
     * 
     * // Get first 10 ContratMaintenances
     * const contratMaintenances = await prisma.contratMaintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contratMaintenanceWithIdOnly = await prisma.contratMaintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContratMaintenanceFindManyArgs>(args?: SelectSubset<T, ContratMaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContratMaintenance.
     * @param {ContratMaintenanceCreateArgs} args - Arguments to create a ContratMaintenance.
     * @example
     * // Create one ContratMaintenance
     * const ContratMaintenance = await prisma.contratMaintenance.create({
     *   data: {
     *     // ... data to create a ContratMaintenance
     *   }
     * })
     * 
     */
    create<T extends ContratMaintenanceCreateArgs>(args: SelectSubset<T, ContratMaintenanceCreateArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContratMaintenances.
     * @param {ContratMaintenanceCreateManyArgs} args - Arguments to create many ContratMaintenances.
     * @example
     * // Create many ContratMaintenances
     * const contratMaintenance = await prisma.contratMaintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContratMaintenanceCreateManyArgs>(args?: SelectSubset<T, ContratMaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContratMaintenances and returns the data saved in the database.
     * @param {ContratMaintenanceCreateManyAndReturnArgs} args - Arguments to create many ContratMaintenances.
     * @example
     * // Create many ContratMaintenances
     * const contratMaintenance = await prisma.contratMaintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContratMaintenances and only return the `id`
     * const contratMaintenanceWithIdOnly = await prisma.contratMaintenance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContratMaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, ContratMaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContratMaintenance.
     * @param {ContratMaintenanceDeleteArgs} args - Arguments to delete one ContratMaintenance.
     * @example
     * // Delete one ContratMaintenance
     * const ContratMaintenance = await prisma.contratMaintenance.delete({
     *   where: {
     *     // ... filter to delete one ContratMaintenance
     *   }
     * })
     * 
     */
    delete<T extends ContratMaintenanceDeleteArgs>(args: SelectSubset<T, ContratMaintenanceDeleteArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContratMaintenance.
     * @param {ContratMaintenanceUpdateArgs} args - Arguments to update one ContratMaintenance.
     * @example
     * // Update one ContratMaintenance
     * const contratMaintenance = await prisma.contratMaintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContratMaintenanceUpdateArgs>(args: SelectSubset<T, ContratMaintenanceUpdateArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContratMaintenances.
     * @param {ContratMaintenanceDeleteManyArgs} args - Arguments to filter ContratMaintenances to delete.
     * @example
     * // Delete a few ContratMaintenances
     * const { count } = await prisma.contratMaintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContratMaintenanceDeleteManyArgs>(args?: SelectSubset<T, ContratMaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContratMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratMaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContratMaintenances
     * const contratMaintenance = await prisma.contratMaintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContratMaintenanceUpdateManyArgs>(args: SelectSubset<T, ContratMaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContratMaintenances and returns the data updated in the database.
     * @param {ContratMaintenanceUpdateManyAndReturnArgs} args - Arguments to update many ContratMaintenances.
     * @example
     * // Update many ContratMaintenances
     * const contratMaintenance = await prisma.contratMaintenance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContratMaintenances and only return the `id`
     * const contratMaintenanceWithIdOnly = await prisma.contratMaintenance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContratMaintenanceUpdateManyAndReturnArgs>(args: SelectSubset<T, ContratMaintenanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContratMaintenance.
     * @param {ContratMaintenanceUpsertArgs} args - Arguments to update or create a ContratMaintenance.
     * @example
     * // Update or create a ContratMaintenance
     * const contratMaintenance = await prisma.contratMaintenance.upsert({
     *   create: {
     *     // ... data to create a ContratMaintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContratMaintenance we want to update
     *   }
     * })
     */
    upsert<T extends ContratMaintenanceUpsertArgs>(args: SelectSubset<T, ContratMaintenanceUpsertArgs<ExtArgs>>): Prisma__ContratMaintenanceClient<$Result.GetResult<Prisma.$ContratMaintenancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContratMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratMaintenanceCountArgs} args - Arguments to filter ContratMaintenances to count.
     * @example
     * // Count the number of ContratMaintenances
     * const count = await prisma.contratMaintenance.count({
     *   where: {
     *     // ... the filter for the ContratMaintenances we want to count
     *   }
     * })
    **/
    count<T extends ContratMaintenanceCountArgs>(
      args?: Subset<T, ContratMaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContratMaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContratMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratMaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContratMaintenanceAggregateArgs>(args: Subset<T, ContratMaintenanceAggregateArgs>): Prisma.PrismaPromise<GetContratMaintenanceAggregateType<T>>

    /**
     * Group by ContratMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratMaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContratMaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContratMaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: ContratMaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContratMaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContratMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContratMaintenance model
   */
  readonly fields: ContratMaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContratMaintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContratMaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContratMaintenance model
   */
  interface ContratMaintenanceFieldRefs {
    readonly id: FieldRef<"ContratMaintenance", 'String'>
    readonly client: FieldRef<"ContratMaintenance", 'String'>
    readonly reference: FieldRef<"ContratMaintenance", 'String'>
    readonly type: FieldRef<"ContratMaintenance", 'String'>
    readonly montant: FieldRef<"ContratMaintenance", 'Float'>
    readonly dateDebut: FieldRef<"ContratMaintenance", 'DateTime'>
    readonly dateEcheance: FieldRef<"ContratMaintenance", 'DateTime'>
    readonly statut: FieldRef<"ContratMaintenance", 'String'>
    readonly description: FieldRef<"ContratMaintenance", 'String'>
    readonly contactClient: FieldRef<"ContratMaintenance", 'String'>
    readonly emailContact: FieldRef<"ContratMaintenance", 'String'>
    readonly telephoneContact: FieldRef<"ContratMaintenance", 'String'>
    readonly notes: FieldRef<"ContratMaintenance", 'String'>
    readonly dateCreation: FieldRef<"ContratMaintenance", 'DateTime'>
    readonly dateDerniereModification: FieldRef<"ContratMaintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContratMaintenance findUnique
   */
  export type ContratMaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which ContratMaintenance to fetch.
     */
    where: ContratMaintenanceWhereUniqueInput
  }

  /**
   * ContratMaintenance findUniqueOrThrow
   */
  export type ContratMaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which ContratMaintenance to fetch.
     */
    where: ContratMaintenanceWhereUniqueInput
  }

  /**
   * ContratMaintenance findFirst
   */
  export type ContratMaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which ContratMaintenance to fetch.
     */
    where?: ContratMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContratMaintenances to fetch.
     */
    orderBy?: ContratMaintenanceOrderByWithRelationInput | ContratMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContratMaintenances.
     */
    cursor?: ContratMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContratMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContratMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContratMaintenances.
     */
    distinct?: ContratMaintenanceScalarFieldEnum | ContratMaintenanceScalarFieldEnum[]
  }

  /**
   * ContratMaintenance findFirstOrThrow
   */
  export type ContratMaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which ContratMaintenance to fetch.
     */
    where?: ContratMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContratMaintenances to fetch.
     */
    orderBy?: ContratMaintenanceOrderByWithRelationInput | ContratMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContratMaintenances.
     */
    cursor?: ContratMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContratMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContratMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContratMaintenances.
     */
    distinct?: ContratMaintenanceScalarFieldEnum | ContratMaintenanceScalarFieldEnum[]
  }

  /**
   * ContratMaintenance findMany
   */
  export type ContratMaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * Filter, which ContratMaintenances to fetch.
     */
    where?: ContratMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContratMaintenances to fetch.
     */
    orderBy?: ContratMaintenanceOrderByWithRelationInput | ContratMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContratMaintenances.
     */
    cursor?: ContratMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContratMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContratMaintenances.
     */
    skip?: number
    distinct?: ContratMaintenanceScalarFieldEnum | ContratMaintenanceScalarFieldEnum[]
  }

  /**
   * ContratMaintenance create
   */
  export type ContratMaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * The data needed to create a ContratMaintenance.
     */
    data: XOR<ContratMaintenanceCreateInput, ContratMaintenanceUncheckedCreateInput>
  }

  /**
   * ContratMaintenance createMany
   */
  export type ContratMaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContratMaintenances.
     */
    data: ContratMaintenanceCreateManyInput | ContratMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContratMaintenance createManyAndReturn
   */
  export type ContratMaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * The data used to create many ContratMaintenances.
     */
    data: ContratMaintenanceCreateManyInput | ContratMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContratMaintenance update
   */
  export type ContratMaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * The data needed to update a ContratMaintenance.
     */
    data: XOR<ContratMaintenanceUpdateInput, ContratMaintenanceUncheckedUpdateInput>
    /**
     * Choose, which ContratMaintenance to update.
     */
    where: ContratMaintenanceWhereUniqueInput
  }

  /**
   * ContratMaintenance updateMany
   */
  export type ContratMaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContratMaintenances.
     */
    data: XOR<ContratMaintenanceUpdateManyMutationInput, ContratMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which ContratMaintenances to update
     */
    where?: ContratMaintenanceWhereInput
    /**
     * Limit how many ContratMaintenances to update.
     */
    limit?: number
  }

  /**
   * ContratMaintenance updateManyAndReturn
   */
  export type ContratMaintenanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * The data used to update ContratMaintenances.
     */
    data: XOR<ContratMaintenanceUpdateManyMutationInput, ContratMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which ContratMaintenances to update
     */
    where?: ContratMaintenanceWhereInput
    /**
     * Limit how many ContratMaintenances to update.
     */
    limit?: number
  }

  /**
   * ContratMaintenance upsert
   */
  export type ContratMaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * The filter to search for the ContratMaintenance to update in case it exists.
     */
    where: ContratMaintenanceWhereUniqueInput
    /**
     * In case the ContratMaintenance found by the `where` argument doesn't exist, create a new ContratMaintenance with this data.
     */
    create: XOR<ContratMaintenanceCreateInput, ContratMaintenanceUncheckedCreateInput>
    /**
     * In case the ContratMaintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContratMaintenanceUpdateInput, ContratMaintenanceUncheckedUpdateInput>
  }

  /**
   * ContratMaintenance delete
   */
  export type ContratMaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
    /**
     * Filter which ContratMaintenance to delete.
     */
    where: ContratMaintenanceWhereUniqueInput
  }

  /**
   * ContratMaintenance deleteMany
   */
  export type ContratMaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContratMaintenances to delete
     */
    where?: ContratMaintenanceWhereInput
    /**
     * Limit how many ContratMaintenances to delete.
     */
    limit?: number
  }

  /**
   * ContratMaintenance without action
   */
  export type ContratMaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContratMaintenance
     */
    select?: ContratMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContratMaintenance
     */
    omit?: ContratMaintenanceOmit<ExtArgs> | null
  }


  /**
   * Model StockItem
   */

  export type AggregateStockItem = {
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  export type StockItemAvgAggregateOutputType = {
    longueur: number | null
  }

  export type StockItemSumAggregateOutputType = {
    longueur: number | null
  }

  export type StockItemMinAggregateOutputType = {
    id: string | null
    cableType: string | null
    typeM: string | null
    typeG: string | null
    enroulement: string | null
    longueur: number | null
    createdAt: Date | null
  }

  export type StockItemMaxAggregateOutputType = {
    id: string | null
    cableType: string | null
    typeM: string | null
    typeG: string | null
    enroulement: string | null
    longueur: number | null
    createdAt: Date | null
  }

  export type StockItemCountAggregateOutputType = {
    id: number
    cableType: number
    typeM: number
    typeG: number
    enroulement: number
    longueur: number
    createdAt: number
    _all: number
  }


  export type StockItemAvgAggregateInputType = {
    longueur?: true
  }

  export type StockItemSumAggregateInputType = {
    longueur?: true
  }

  export type StockItemMinAggregateInputType = {
    id?: true
    cableType?: true
    typeM?: true
    typeG?: true
    enroulement?: true
    longueur?: true
    createdAt?: true
  }

  export type StockItemMaxAggregateInputType = {
    id?: true
    cableType?: true
    typeM?: true
    typeG?: true
    enroulement?: true
    longueur?: true
    createdAt?: true
  }

  export type StockItemCountAggregateInputType = {
    id?: true
    cableType?: true
    typeM?: true
    typeG?: true
    enroulement?: true
    longueur?: true
    createdAt?: true
    _all?: true
  }

  export type StockItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockItem to aggregate.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockItems
    **/
    _count?: true | StockItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockItemMaxAggregateInputType
  }

  export type GetStockItemAggregateType<T extends StockItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStockItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockItem[P]>
      : GetScalarType<T[P], AggregateStockItem[P]>
  }




  export type StockItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockItemWhereInput
    orderBy?: StockItemOrderByWithAggregationInput | StockItemOrderByWithAggregationInput[]
    by: StockItemScalarFieldEnum[] | StockItemScalarFieldEnum
    having?: StockItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockItemCountAggregateInputType | true
    _avg?: StockItemAvgAggregateInputType
    _sum?: StockItemSumAggregateInputType
    _min?: StockItemMinAggregateInputType
    _max?: StockItemMaxAggregateInputType
  }

  export type StockItemGroupByOutputType = {
    id: string
    cableType: string
    typeM: string
    typeG: string
    enroulement: string
    longueur: number
    createdAt: Date
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  type GetStockItemGroupByPayload<T extends StockItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockItemGroupByOutputType[P]>
            : GetScalarType<T[P], StockItemGroupByOutputType[P]>
        }
      >
    >


  export type StockItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cableType?: boolean
    typeM?: boolean
    typeG?: boolean
    enroulement?: boolean
    longueur?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stockItem"]>

  export type StockItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cableType?: boolean
    typeM?: boolean
    typeG?: boolean
    enroulement?: boolean
    longueur?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stockItem"]>

  export type StockItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cableType?: boolean
    typeM?: boolean
    typeG?: boolean
    enroulement?: boolean
    longueur?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stockItem"]>

  export type StockItemSelectScalar = {
    id?: boolean
    cableType?: boolean
    typeM?: boolean
    typeG?: boolean
    enroulement?: boolean
    longueur?: boolean
    createdAt?: boolean
  }

  export type StockItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cableType" | "typeM" | "typeG" | "enroulement" | "longueur" | "createdAt", ExtArgs["result"]["stockItem"]>

  export type $StockItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cableType: string
      typeM: string
      typeG: string
      enroulement: string
      longueur: number
      createdAt: Date
    }, ExtArgs["result"]["stockItem"]>
    composites: {}
  }

  type StockItemGetPayload<S extends boolean | null | undefined | StockItemDefaultArgs> = $Result.GetResult<Prisma.$StockItemPayload, S>

  type StockItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockItemCountAggregateInputType | true
    }

  export interface StockItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockItem'], meta: { name: 'StockItem' } }
    /**
     * Find zero or one StockItem that matches the filter.
     * @param {StockItemFindUniqueArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockItemFindUniqueArgs>(args: SelectSubset<T, StockItemFindUniqueArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockItemFindUniqueOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StockItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockItemFindFirstArgs>(args?: SelectSubset<T, StockItemFindFirstArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StockItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockItems
     * const stockItems = await prisma.stockItem.findMany()
     * 
     * // Get first 10 StockItems
     * const stockItems = await prisma.stockItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockItemWithIdOnly = await prisma.stockItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockItemFindManyArgs>(args?: SelectSubset<T, StockItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockItem.
     * @param {StockItemCreateArgs} args - Arguments to create a StockItem.
     * @example
     * // Create one StockItem
     * const StockItem = await prisma.stockItem.create({
     *   data: {
     *     // ... data to create a StockItem
     *   }
     * })
     * 
     */
    create<T extends StockItemCreateArgs>(args: SelectSubset<T, StockItemCreateArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockItems.
     * @param {StockItemCreateManyArgs} args - Arguments to create many StockItems.
     * @example
     * // Create many StockItems
     * const stockItem = await prisma.stockItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockItemCreateManyArgs>(args?: SelectSubset<T, StockItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockItems and returns the data saved in the database.
     * @param {StockItemCreateManyAndReturnArgs} args - Arguments to create many StockItems.
     * @example
     * // Create many StockItems
     * const stockItem = await prisma.stockItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockItems and only return the `id`
     * const stockItemWithIdOnly = await prisma.stockItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockItemCreateManyAndReturnArgs>(args?: SelectSubset<T, StockItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockItem.
     * @param {StockItemDeleteArgs} args - Arguments to delete one StockItem.
     * @example
     * // Delete one StockItem
     * const StockItem = await prisma.stockItem.delete({
     *   where: {
     *     // ... filter to delete one StockItem
     *   }
     * })
     * 
     */
    delete<T extends StockItemDeleteArgs>(args: SelectSubset<T, StockItemDeleteArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockItem.
     * @param {StockItemUpdateArgs} args - Arguments to update one StockItem.
     * @example
     * // Update one StockItem
     * const stockItem = await prisma.stockItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockItemUpdateArgs>(args: SelectSubset<T, StockItemUpdateArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockItems.
     * @param {StockItemDeleteManyArgs} args - Arguments to filter StockItems to delete.
     * @example
     * // Delete a few StockItems
     * const { count } = await prisma.stockItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockItemDeleteManyArgs>(args?: SelectSubset<T, StockItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockItems
     * const stockItem = await prisma.stockItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockItemUpdateManyArgs>(args: SelectSubset<T, StockItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockItems and returns the data updated in the database.
     * @param {StockItemUpdateManyAndReturnArgs} args - Arguments to update many StockItems.
     * @example
     * // Update many StockItems
     * const stockItem = await prisma.stockItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockItems and only return the `id`
     * const stockItemWithIdOnly = await prisma.stockItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockItemUpdateManyAndReturnArgs>(args: SelectSubset<T, StockItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockItem.
     * @param {StockItemUpsertArgs} args - Arguments to update or create a StockItem.
     * @example
     * // Update or create a StockItem
     * const stockItem = await prisma.stockItem.upsert({
     *   create: {
     *     // ... data to create a StockItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockItem we want to update
     *   }
     * })
     */
    upsert<T extends StockItemUpsertArgs>(args: SelectSubset<T, StockItemUpsertArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemCountArgs} args - Arguments to filter StockItems to count.
     * @example
     * // Count the number of StockItems
     * const count = await prisma.stockItem.count({
     *   where: {
     *     // ... the filter for the StockItems we want to count
     *   }
     * })
    **/
    count<T extends StockItemCountArgs>(
      args?: Subset<T, StockItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockItemAggregateArgs>(args: Subset<T, StockItemAggregateArgs>): Prisma.PrismaPromise<GetStockItemAggregateType<T>>

    /**
     * Group by StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockItemGroupByArgs['orderBy'] }
        : { orderBy?: StockItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockItem model
   */
  readonly fields: StockItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockItem model
   */
  interface StockItemFieldRefs {
    readonly id: FieldRef<"StockItem", 'String'>
    readonly cableType: FieldRef<"StockItem", 'String'>
    readonly typeM: FieldRef<"StockItem", 'String'>
    readonly typeG: FieldRef<"StockItem", 'String'>
    readonly enroulement: FieldRef<"StockItem", 'String'>
    readonly longueur: FieldRef<"StockItem", 'Int'>
    readonly createdAt: FieldRef<"StockItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockItem findUnique
   */
  export type StockItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem findUniqueOrThrow
   */
  export type StockItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem findFirst
   */
  export type StockItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockItems.
     */
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }

  /**
   * StockItem findFirstOrThrow
   */
  export type StockItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockItems.
     */
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }

  /**
   * StockItem findMany
   */
  export type StockItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Filter, which StockItems to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }

  /**
   * StockItem create
   */
  export type StockItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * The data needed to create a StockItem.
     */
    data: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
  }

  /**
   * StockItem createMany
   */
  export type StockItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockItems.
     */
    data: StockItemCreateManyInput | StockItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockItem createManyAndReturn
   */
  export type StockItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * The data used to create many StockItems.
     */
    data: StockItemCreateManyInput | StockItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockItem update
   */
  export type StockItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * The data needed to update a StockItem.
     */
    data: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
    /**
     * Choose, which StockItem to update.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem updateMany
   */
  export type StockItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockItems.
     */
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyInput>
    /**
     * Filter which StockItems to update
     */
    where?: StockItemWhereInput
    /**
     * Limit how many StockItems to update.
     */
    limit?: number
  }

  /**
   * StockItem updateManyAndReturn
   */
  export type StockItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * The data used to update StockItems.
     */
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyInput>
    /**
     * Filter which StockItems to update
     */
    where?: StockItemWhereInput
    /**
     * Limit how many StockItems to update.
     */
    limit?: number
  }

  /**
   * StockItem upsert
   */
  export type StockItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * The filter to search for the StockItem to update in case it exists.
     */
    where: StockItemWhereUniqueInput
    /**
     * In case the StockItem found by the `where` argument doesn't exist, create a new StockItem with this data.
     */
    create: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
    /**
     * In case the StockItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
  }

  /**
   * StockItem delete
   */
  export type StockItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Filter which StockItem to delete.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem deleteMany
   */
  export type StockItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockItems to delete
     */
    where?: StockItemWhereInput
    /**
     * Limit how many StockItems to delete.
     */
    limit?: number
  }

  /**
   * StockItem without action
   */
  export type StockItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
  }


  /**
   * Model FicheDePoste
   */

  export type AggregateFicheDePoste = {
    _count: FicheDePosteCountAggregateOutputType | null
    _min: FicheDePosteMinAggregateOutputType | null
    _max: FicheDePosteMaxAggregateOutputType | null
  }

  export type FicheDePosteMinAggregateOutputType = {
    id: string | null
    classification: string | null
    poste: string | null
    entreprise: string | null
    typeContrat: string | null
    dureeContrat: string | null
    description: string | null
    experience: string | null
    formation: string | null
    remuneration: string | null
    avantages: string | null
    horaires: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    codePostal: string | null
    ville: string | null
    dateNaissance: Date | null
    numeroSecu: string | null
    lieuTravail: string | null
    dateCreation: Date | null
    dateModification: Date | null
    estActive: boolean | null
    collaborateurId: string | null
  }

  export type FicheDePosteMaxAggregateOutputType = {
    id: string | null
    classification: string | null
    poste: string | null
    entreprise: string | null
    typeContrat: string | null
    dureeContrat: string | null
    description: string | null
    experience: string | null
    formation: string | null
    remuneration: string | null
    avantages: string | null
    horaires: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    codePostal: string | null
    ville: string | null
    dateNaissance: Date | null
    numeroSecu: string | null
    lieuTravail: string | null
    dateCreation: Date | null
    dateModification: Date | null
    estActive: boolean | null
    collaborateurId: string | null
  }

  export type FicheDePosteCountAggregateOutputType = {
    id: number
    classification: number
    poste: number
    entreprise: number
    typeContrat: number
    dureeContrat: number
    certifications: number
    habilitations: number
    competencesRequises: number
    description: number
    missions: number
    experience: number
    formation: number
    remuneration: number
    avantages: number
    horaires: number
    email: number
    telephone: number
    adresse: number
    codePostal: number
    ville: number
    dateNaissance: number
    numeroSecu: number
    lieuTravail: number
    dateCreation: number
    dateModification: number
    estActive: number
    collaborateurId: number
    _all: number
  }


  export type FicheDePosteMinAggregateInputType = {
    id?: true
    classification?: true
    poste?: true
    entreprise?: true
    typeContrat?: true
    dureeContrat?: true
    description?: true
    experience?: true
    formation?: true
    remuneration?: true
    avantages?: true
    horaires?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    dateNaissance?: true
    numeroSecu?: true
    lieuTravail?: true
    dateCreation?: true
    dateModification?: true
    estActive?: true
    collaborateurId?: true
  }

  export type FicheDePosteMaxAggregateInputType = {
    id?: true
    classification?: true
    poste?: true
    entreprise?: true
    typeContrat?: true
    dureeContrat?: true
    description?: true
    experience?: true
    formation?: true
    remuneration?: true
    avantages?: true
    horaires?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    dateNaissance?: true
    numeroSecu?: true
    lieuTravail?: true
    dateCreation?: true
    dateModification?: true
    estActive?: true
    collaborateurId?: true
  }

  export type FicheDePosteCountAggregateInputType = {
    id?: true
    classification?: true
    poste?: true
    entreprise?: true
    typeContrat?: true
    dureeContrat?: true
    certifications?: true
    habilitations?: true
    competencesRequises?: true
    description?: true
    missions?: true
    experience?: true
    formation?: true
    remuneration?: true
    avantages?: true
    horaires?: true
    email?: true
    telephone?: true
    adresse?: true
    codePostal?: true
    ville?: true
    dateNaissance?: true
    numeroSecu?: true
    lieuTravail?: true
    dateCreation?: true
    dateModification?: true
    estActive?: true
    collaborateurId?: true
    _all?: true
  }

  export type FicheDePosteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FicheDePoste to aggregate.
     */
    where?: FicheDePosteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheDePostes to fetch.
     */
    orderBy?: FicheDePosteOrderByWithRelationInput | FicheDePosteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FicheDePosteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheDePostes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheDePostes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FicheDePostes
    **/
    _count?: true | FicheDePosteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FicheDePosteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FicheDePosteMaxAggregateInputType
  }

  export type GetFicheDePosteAggregateType<T extends FicheDePosteAggregateArgs> = {
        [P in keyof T & keyof AggregateFicheDePoste]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFicheDePoste[P]>
      : GetScalarType<T[P], AggregateFicheDePoste[P]>
  }




  export type FicheDePosteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FicheDePosteWhereInput
    orderBy?: FicheDePosteOrderByWithAggregationInput | FicheDePosteOrderByWithAggregationInput[]
    by: FicheDePosteScalarFieldEnum[] | FicheDePosteScalarFieldEnum
    having?: FicheDePosteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FicheDePosteCountAggregateInputType | true
    _min?: FicheDePosteMinAggregateInputType
    _max?: FicheDePosteMaxAggregateInputType
  }

  export type FicheDePosteGroupByOutputType = {
    id: string
    classification: string
    poste: string
    entreprise: string
    typeContrat: string
    dureeContrat: string | null
    certifications: string[]
    habilitations: string[]
    competencesRequises: string[]
    description: string
    missions: string[]
    experience: string | null
    formation: string | null
    remuneration: string | null
    avantages: string | null
    horaires: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    codePostal: string | null
    ville: string | null
    dateNaissance: Date | null
    numeroSecu: string | null
    lieuTravail: string | null
    dateCreation: Date
    dateModification: Date
    estActive: boolean
    collaborateurId: string | null
    _count: FicheDePosteCountAggregateOutputType | null
    _min: FicheDePosteMinAggregateOutputType | null
    _max: FicheDePosteMaxAggregateOutputType | null
  }

  type GetFicheDePosteGroupByPayload<T extends FicheDePosteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FicheDePosteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FicheDePosteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FicheDePosteGroupByOutputType[P]>
            : GetScalarType<T[P], FicheDePosteGroupByOutputType[P]>
        }
      >
    >


  export type FicheDePosteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classification?: boolean
    poste?: boolean
    entreprise?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    competencesRequises?: boolean
    description?: boolean
    missions?: boolean
    experience?: boolean
    formation?: boolean
    remuneration?: boolean
    avantages?: boolean
    horaires?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    lieuTravail?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    estActive?: boolean
    collaborateurId?: boolean
    collaborateur?: boolean | FicheDePoste$collaborateurArgs<ExtArgs>
  }, ExtArgs["result"]["ficheDePoste"]>

  export type FicheDePosteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classification?: boolean
    poste?: boolean
    entreprise?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    competencesRequises?: boolean
    description?: boolean
    missions?: boolean
    experience?: boolean
    formation?: boolean
    remuneration?: boolean
    avantages?: boolean
    horaires?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    lieuTravail?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    estActive?: boolean
    collaborateurId?: boolean
    collaborateur?: boolean | FicheDePoste$collaborateurArgs<ExtArgs>
  }, ExtArgs["result"]["ficheDePoste"]>

  export type FicheDePosteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classification?: boolean
    poste?: boolean
    entreprise?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    competencesRequises?: boolean
    description?: boolean
    missions?: boolean
    experience?: boolean
    formation?: boolean
    remuneration?: boolean
    avantages?: boolean
    horaires?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    lieuTravail?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    estActive?: boolean
    collaborateurId?: boolean
    collaborateur?: boolean | FicheDePoste$collaborateurArgs<ExtArgs>
  }, ExtArgs["result"]["ficheDePoste"]>

  export type FicheDePosteSelectScalar = {
    id?: boolean
    classification?: boolean
    poste?: boolean
    entreprise?: boolean
    typeContrat?: boolean
    dureeContrat?: boolean
    certifications?: boolean
    habilitations?: boolean
    competencesRequises?: boolean
    description?: boolean
    missions?: boolean
    experience?: boolean
    formation?: boolean
    remuneration?: boolean
    avantages?: boolean
    horaires?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    codePostal?: boolean
    ville?: boolean
    dateNaissance?: boolean
    numeroSecu?: boolean
    lieuTravail?: boolean
    dateCreation?: boolean
    dateModification?: boolean
    estActive?: boolean
    collaborateurId?: boolean
  }

  export type FicheDePosteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classification" | "poste" | "entreprise" | "typeContrat" | "dureeContrat" | "certifications" | "habilitations" | "competencesRequises" | "description" | "missions" | "experience" | "formation" | "remuneration" | "avantages" | "horaires" | "email" | "telephone" | "adresse" | "codePostal" | "ville" | "dateNaissance" | "numeroSecu" | "lieuTravail" | "dateCreation" | "dateModification" | "estActive" | "collaborateurId", ExtArgs["result"]["ficheDePoste"]>
  export type FicheDePosteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | FicheDePoste$collaborateurArgs<ExtArgs>
  }
  export type FicheDePosteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | FicheDePoste$collaborateurArgs<ExtArgs>
  }
  export type FicheDePosteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborateur?: boolean | FicheDePoste$collaborateurArgs<ExtArgs>
  }

  export type $FicheDePostePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FicheDePoste"
    objects: {
      collaborateur: Prisma.$CollaborateurPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classification: string
      poste: string
      entreprise: string
      typeContrat: string
      dureeContrat: string | null
      certifications: string[]
      habilitations: string[]
      competencesRequises: string[]
      description: string
      missions: string[]
      experience: string | null
      formation: string | null
      remuneration: string | null
      avantages: string | null
      horaires: string | null
      email: string | null
      telephone: string | null
      adresse: string | null
      codePostal: string | null
      ville: string | null
      dateNaissance: Date | null
      numeroSecu: string | null
      lieuTravail: string | null
      dateCreation: Date
      dateModification: Date
      estActive: boolean
      collaborateurId: string | null
    }, ExtArgs["result"]["ficheDePoste"]>
    composites: {}
  }

  type FicheDePosteGetPayload<S extends boolean | null | undefined | FicheDePosteDefaultArgs> = $Result.GetResult<Prisma.$FicheDePostePayload, S>

  type FicheDePosteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FicheDePosteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FicheDePosteCountAggregateInputType | true
    }

  export interface FicheDePosteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FicheDePoste'], meta: { name: 'FicheDePoste' } }
    /**
     * Find zero or one FicheDePoste that matches the filter.
     * @param {FicheDePosteFindUniqueArgs} args - Arguments to find a FicheDePoste
     * @example
     * // Get one FicheDePoste
     * const ficheDePoste = await prisma.ficheDePoste.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FicheDePosteFindUniqueArgs>(args: SelectSubset<T, FicheDePosteFindUniqueArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FicheDePoste that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FicheDePosteFindUniqueOrThrowArgs} args - Arguments to find a FicheDePoste
     * @example
     * // Get one FicheDePoste
     * const ficheDePoste = await prisma.ficheDePoste.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FicheDePosteFindUniqueOrThrowArgs>(args: SelectSubset<T, FicheDePosteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FicheDePoste that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheDePosteFindFirstArgs} args - Arguments to find a FicheDePoste
     * @example
     * // Get one FicheDePoste
     * const ficheDePoste = await prisma.ficheDePoste.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FicheDePosteFindFirstArgs>(args?: SelectSubset<T, FicheDePosteFindFirstArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FicheDePoste that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheDePosteFindFirstOrThrowArgs} args - Arguments to find a FicheDePoste
     * @example
     * // Get one FicheDePoste
     * const ficheDePoste = await prisma.ficheDePoste.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FicheDePosteFindFirstOrThrowArgs>(args?: SelectSubset<T, FicheDePosteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FicheDePostes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheDePosteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FicheDePostes
     * const ficheDePostes = await prisma.ficheDePoste.findMany()
     * 
     * // Get first 10 FicheDePostes
     * const ficheDePostes = await prisma.ficheDePoste.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ficheDePosteWithIdOnly = await prisma.ficheDePoste.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FicheDePosteFindManyArgs>(args?: SelectSubset<T, FicheDePosteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FicheDePoste.
     * @param {FicheDePosteCreateArgs} args - Arguments to create a FicheDePoste.
     * @example
     * // Create one FicheDePoste
     * const FicheDePoste = await prisma.ficheDePoste.create({
     *   data: {
     *     // ... data to create a FicheDePoste
     *   }
     * })
     * 
     */
    create<T extends FicheDePosteCreateArgs>(args: SelectSubset<T, FicheDePosteCreateArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FicheDePostes.
     * @param {FicheDePosteCreateManyArgs} args - Arguments to create many FicheDePostes.
     * @example
     * // Create many FicheDePostes
     * const ficheDePoste = await prisma.ficheDePoste.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FicheDePosteCreateManyArgs>(args?: SelectSubset<T, FicheDePosteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FicheDePostes and returns the data saved in the database.
     * @param {FicheDePosteCreateManyAndReturnArgs} args - Arguments to create many FicheDePostes.
     * @example
     * // Create many FicheDePostes
     * const ficheDePoste = await prisma.ficheDePoste.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FicheDePostes and only return the `id`
     * const ficheDePosteWithIdOnly = await prisma.ficheDePoste.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FicheDePosteCreateManyAndReturnArgs>(args?: SelectSubset<T, FicheDePosteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FicheDePoste.
     * @param {FicheDePosteDeleteArgs} args - Arguments to delete one FicheDePoste.
     * @example
     * // Delete one FicheDePoste
     * const FicheDePoste = await prisma.ficheDePoste.delete({
     *   where: {
     *     // ... filter to delete one FicheDePoste
     *   }
     * })
     * 
     */
    delete<T extends FicheDePosteDeleteArgs>(args: SelectSubset<T, FicheDePosteDeleteArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FicheDePoste.
     * @param {FicheDePosteUpdateArgs} args - Arguments to update one FicheDePoste.
     * @example
     * // Update one FicheDePoste
     * const ficheDePoste = await prisma.ficheDePoste.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FicheDePosteUpdateArgs>(args: SelectSubset<T, FicheDePosteUpdateArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FicheDePostes.
     * @param {FicheDePosteDeleteManyArgs} args - Arguments to filter FicheDePostes to delete.
     * @example
     * // Delete a few FicheDePostes
     * const { count } = await prisma.ficheDePoste.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FicheDePosteDeleteManyArgs>(args?: SelectSubset<T, FicheDePosteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FicheDePostes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheDePosteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FicheDePostes
     * const ficheDePoste = await prisma.ficheDePoste.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FicheDePosteUpdateManyArgs>(args: SelectSubset<T, FicheDePosteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FicheDePostes and returns the data updated in the database.
     * @param {FicheDePosteUpdateManyAndReturnArgs} args - Arguments to update many FicheDePostes.
     * @example
     * // Update many FicheDePostes
     * const ficheDePoste = await prisma.ficheDePoste.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FicheDePostes and only return the `id`
     * const ficheDePosteWithIdOnly = await prisma.ficheDePoste.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FicheDePosteUpdateManyAndReturnArgs>(args: SelectSubset<T, FicheDePosteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FicheDePoste.
     * @param {FicheDePosteUpsertArgs} args - Arguments to update or create a FicheDePoste.
     * @example
     * // Update or create a FicheDePoste
     * const ficheDePoste = await prisma.ficheDePoste.upsert({
     *   create: {
     *     // ... data to create a FicheDePoste
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FicheDePoste we want to update
     *   }
     * })
     */
    upsert<T extends FicheDePosteUpsertArgs>(args: SelectSubset<T, FicheDePosteUpsertArgs<ExtArgs>>): Prisma__FicheDePosteClient<$Result.GetResult<Prisma.$FicheDePostePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FicheDePostes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheDePosteCountArgs} args - Arguments to filter FicheDePostes to count.
     * @example
     * // Count the number of FicheDePostes
     * const count = await prisma.ficheDePoste.count({
     *   where: {
     *     // ... the filter for the FicheDePostes we want to count
     *   }
     * })
    **/
    count<T extends FicheDePosteCountArgs>(
      args?: Subset<T, FicheDePosteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FicheDePosteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FicheDePoste.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheDePosteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FicheDePosteAggregateArgs>(args: Subset<T, FicheDePosteAggregateArgs>): Prisma.PrismaPromise<GetFicheDePosteAggregateType<T>>

    /**
     * Group by FicheDePoste.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheDePosteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FicheDePosteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FicheDePosteGroupByArgs['orderBy'] }
        : { orderBy?: FicheDePosteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FicheDePosteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFicheDePosteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FicheDePoste model
   */
  readonly fields: FicheDePosteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FicheDePoste.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FicheDePosteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collaborateur<T extends FicheDePoste$collaborateurArgs<ExtArgs> = {}>(args?: Subset<T, FicheDePoste$collaborateurArgs<ExtArgs>>): Prisma__CollaborateurClient<$Result.GetResult<Prisma.$CollaborateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FicheDePoste model
   */
  interface FicheDePosteFieldRefs {
    readonly id: FieldRef<"FicheDePoste", 'String'>
    readonly classification: FieldRef<"FicheDePoste", 'String'>
    readonly poste: FieldRef<"FicheDePoste", 'String'>
    readonly entreprise: FieldRef<"FicheDePoste", 'String'>
    readonly typeContrat: FieldRef<"FicheDePoste", 'String'>
    readonly dureeContrat: FieldRef<"FicheDePoste", 'String'>
    readonly certifications: FieldRef<"FicheDePoste", 'String[]'>
    readonly habilitations: FieldRef<"FicheDePoste", 'String[]'>
    readonly competencesRequises: FieldRef<"FicheDePoste", 'String[]'>
    readonly description: FieldRef<"FicheDePoste", 'String'>
    readonly missions: FieldRef<"FicheDePoste", 'String[]'>
    readonly experience: FieldRef<"FicheDePoste", 'String'>
    readonly formation: FieldRef<"FicheDePoste", 'String'>
    readonly remuneration: FieldRef<"FicheDePoste", 'String'>
    readonly avantages: FieldRef<"FicheDePoste", 'String'>
    readonly horaires: FieldRef<"FicheDePoste", 'String'>
    readonly email: FieldRef<"FicheDePoste", 'String'>
    readonly telephone: FieldRef<"FicheDePoste", 'String'>
    readonly adresse: FieldRef<"FicheDePoste", 'String'>
    readonly codePostal: FieldRef<"FicheDePoste", 'String'>
    readonly ville: FieldRef<"FicheDePoste", 'String'>
    readonly dateNaissance: FieldRef<"FicheDePoste", 'DateTime'>
    readonly numeroSecu: FieldRef<"FicheDePoste", 'String'>
    readonly lieuTravail: FieldRef<"FicheDePoste", 'String'>
    readonly dateCreation: FieldRef<"FicheDePoste", 'DateTime'>
    readonly dateModification: FieldRef<"FicheDePoste", 'DateTime'>
    readonly estActive: FieldRef<"FicheDePoste", 'Boolean'>
    readonly collaborateurId: FieldRef<"FicheDePoste", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FicheDePoste findUnique
   */
  export type FicheDePosteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * Filter, which FicheDePoste to fetch.
     */
    where: FicheDePosteWhereUniqueInput
  }

  /**
   * FicheDePoste findUniqueOrThrow
   */
  export type FicheDePosteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * Filter, which FicheDePoste to fetch.
     */
    where: FicheDePosteWhereUniqueInput
  }

  /**
   * FicheDePoste findFirst
   */
  export type FicheDePosteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * Filter, which FicheDePoste to fetch.
     */
    where?: FicheDePosteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheDePostes to fetch.
     */
    orderBy?: FicheDePosteOrderByWithRelationInput | FicheDePosteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FicheDePostes.
     */
    cursor?: FicheDePosteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheDePostes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheDePostes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FicheDePostes.
     */
    distinct?: FicheDePosteScalarFieldEnum | FicheDePosteScalarFieldEnum[]
  }

  /**
   * FicheDePoste findFirstOrThrow
   */
  export type FicheDePosteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * Filter, which FicheDePoste to fetch.
     */
    where?: FicheDePosteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheDePostes to fetch.
     */
    orderBy?: FicheDePosteOrderByWithRelationInput | FicheDePosteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FicheDePostes.
     */
    cursor?: FicheDePosteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheDePostes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheDePostes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FicheDePostes.
     */
    distinct?: FicheDePosteScalarFieldEnum | FicheDePosteScalarFieldEnum[]
  }

  /**
   * FicheDePoste findMany
   */
  export type FicheDePosteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * Filter, which FicheDePostes to fetch.
     */
    where?: FicheDePosteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FicheDePostes to fetch.
     */
    orderBy?: FicheDePosteOrderByWithRelationInput | FicheDePosteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FicheDePostes.
     */
    cursor?: FicheDePosteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FicheDePostes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FicheDePostes.
     */
    skip?: number
    distinct?: FicheDePosteScalarFieldEnum | FicheDePosteScalarFieldEnum[]
  }

  /**
   * FicheDePoste create
   */
  export type FicheDePosteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * The data needed to create a FicheDePoste.
     */
    data: XOR<FicheDePosteCreateInput, FicheDePosteUncheckedCreateInput>
  }

  /**
   * FicheDePoste createMany
   */
  export type FicheDePosteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FicheDePostes.
     */
    data: FicheDePosteCreateManyInput | FicheDePosteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FicheDePoste createManyAndReturn
   */
  export type FicheDePosteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * The data used to create many FicheDePostes.
     */
    data: FicheDePosteCreateManyInput | FicheDePosteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FicheDePoste update
   */
  export type FicheDePosteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * The data needed to update a FicheDePoste.
     */
    data: XOR<FicheDePosteUpdateInput, FicheDePosteUncheckedUpdateInput>
    /**
     * Choose, which FicheDePoste to update.
     */
    where: FicheDePosteWhereUniqueInput
  }

  /**
   * FicheDePoste updateMany
   */
  export type FicheDePosteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FicheDePostes.
     */
    data: XOR<FicheDePosteUpdateManyMutationInput, FicheDePosteUncheckedUpdateManyInput>
    /**
     * Filter which FicheDePostes to update
     */
    where?: FicheDePosteWhereInput
    /**
     * Limit how many FicheDePostes to update.
     */
    limit?: number
  }

  /**
   * FicheDePoste updateManyAndReturn
   */
  export type FicheDePosteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * The data used to update FicheDePostes.
     */
    data: XOR<FicheDePosteUpdateManyMutationInput, FicheDePosteUncheckedUpdateManyInput>
    /**
     * Filter which FicheDePostes to update
     */
    where?: FicheDePosteWhereInput
    /**
     * Limit how many FicheDePostes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FicheDePoste upsert
   */
  export type FicheDePosteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * The filter to search for the FicheDePoste to update in case it exists.
     */
    where: FicheDePosteWhereUniqueInput
    /**
     * In case the FicheDePoste found by the `where` argument doesn't exist, create a new FicheDePoste with this data.
     */
    create: XOR<FicheDePosteCreateInput, FicheDePosteUncheckedCreateInput>
    /**
     * In case the FicheDePoste was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FicheDePosteUpdateInput, FicheDePosteUncheckedUpdateInput>
  }

  /**
   * FicheDePoste delete
   */
  export type FicheDePosteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
    /**
     * Filter which FicheDePoste to delete.
     */
    where: FicheDePosteWhereUniqueInput
  }

  /**
   * FicheDePoste deleteMany
   */
  export type FicheDePosteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FicheDePostes to delete
     */
    where?: FicheDePosteWhereInput
    /**
     * Limit how many FicheDePostes to delete.
     */
    limit?: number
  }

  /**
   * FicheDePoste.collaborateur
   */
  export type FicheDePoste$collaborateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborateur
     */
    select?: CollaborateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborateur
     */
    omit?: CollaborateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaborateurInclude<ExtArgs> | null
    where?: CollaborateurWhereInput
  }

  /**
   * FicheDePoste without action
   */
  export type FicheDePosteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheDePoste
     */
    select?: FicheDePosteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FicheDePoste
     */
    omit?: FicheDePosteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FicheDePosteInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    role: $Enums.RoleAdmin | null
    departement: string | null
    dateCreation: Date | null
    dernierAcces: Date | null
    estActif: boolean | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    role: $Enums.RoleAdmin | null
    departement: string | null
    dateCreation: Date | null
    dernierAcces: Date | null
    estActif: boolean | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    email: number
    telephone: number
    role: number
    departement: number
    dateCreation: number
    dernierAcces: number
    estActif: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    role?: true
    departement?: true
    dateCreation?: true
    dernierAcces?: true
    estActif?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    role?: true
    departement?: true
    dateCreation?: true
    dernierAcces?: true
    estActif?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    role?: true
    departement?: true
    dateCreation?: true
    dernierAcces?: true
    estActif?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    nom: string
    prenom: string
    email: string
    telephone: string
    role: $Enums.RoleAdmin
    departement: string
    dateCreation: Date
    dernierAcces: Date
    estActif: boolean
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    role?: boolean
    departement?: boolean
    dateCreation?: boolean
    dernierAcces?: boolean
    estActif?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    role?: boolean
    departement?: boolean
    dateCreation?: boolean
    dernierAcces?: boolean
    estActif?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    role?: boolean
    departement?: boolean
    dateCreation?: boolean
    dernierAcces?: boolean
    estActif?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    role?: boolean
    departement?: boolean
    dateCreation?: boolean
    dernierAcces?: boolean
    estActif?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "prenom" | "email" | "telephone" | "role" | "departement" | "dateCreation" | "dernierAcces" | "estActif", ExtArgs["result"]["admin"]>

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      prenom: string
      email: string
      telephone: string
      role: $Enums.RoleAdmin
      departement: string
      dateCreation: Date
      dernierAcces: Date
      estActif: boolean
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly nom: FieldRef<"Admin", 'String'>
    readonly prenom: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly telephone: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'RoleAdmin'>
    readonly departement: FieldRef<"Admin", 'String'>
    readonly dateCreation: FieldRef<"Admin", 'DateTime'>
    readonly dernierAcces: FieldRef<"Admin", 'DateTime'>
    readonly estActif: FieldRef<"Admin", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CollaborateurScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    couleur: 'couleur',
    entreprise: 'entreprise',
    aCompte: 'aCompte',
    createdAt: 'createdAt'
  };

  export type CollaborateurScalarFieldEnum = (typeof CollaborateurScalarFieldEnum)[keyof typeof CollaborateurScalarFieldEnum]


  export const CompteScalarFieldEnum: {
    id: 'id',
    identifiant: 'identifiant',
    motDePasse: 'motDePasse',
    role: 'role',
    collaborateurId: 'collaborateurId',
    createdAt: 'createdAt'
  };

  export type CompteScalarFieldEnum = (typeof CompteScalarFieldEnum)[keyof typeof CompteScalarFieldEnum]


  export const EvenementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    start: 'start',
    end: 'end',
    collaborateurId: 'collaborateurId',
    typeEvenement: 'typeEvenement',
    lieuChantier: 'lieuChantier',
    zoneTrajet: 'zoneTrajet',
    panierRepas: 'panierRepas',
    ticketRestaurant: 'ticketRestaurant',
    heuresSupplementaires: 'heuresSupplementaires',
    grandDeplacement: 'grandDeplacement',
    prgd: 'prgd',
    nombrePrgd: 'nombrePrgd',
    typeAbsence: 'typeAbsence',
    verrouille: 'verrouille',
    latitude: 'latitude',
    longitude: 'longitude',
    adresseComplete: 'adresseComplete',
    createdAt: 'createdAt'
  };

  export type EvenementScalarFieldEnum = (typeof EvenementScalarFieldEnum)[keyof typeof EvenementScalarFieldEnum]


  export const SalarieScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    classification: 'classification',
    dateEntree: 'dateEntree',
    typeContrat: 'typeContrat',
    dureeContrat: 'dureeContrat',
    certifications: 'certifications',
    habilitations: 'habilitations',
    entreprise: 'entreprise',
    poste: 'poste',
    email: 'email',
    telephone: 'telephone',
    adresse: 'adresse',
    codePostal: 'codePostal',
    ville: 'ville',
    dateNaissance: 'dateNaissance',
    numeroSecu: 'numeroSecu',
    collaborateurId: 'collaborateurId',
    createdAt: 'createdAt'
  };

  export type SalarieScalarFieldEnum = (typeof SalarieScalarFieldEnum)[keyof typeof SalarieScalarFieldEnum]


  export const VehiculeScalarFieldEnum: {
    id: 'id',
    societe: 'societe',
    marque: 'marque',
    modele: 'modele',
    immatriculation: 'immatriculation',
    etat: 'etat',
    proprietaire: 'proprietaire',
    dateMiseEnCirculation: 'dateMiseEnCirculation',
    kilometrage: 'kilometrage',
    kmProchaineRevision: 'kmProchaineRevision',
    dateLimiteControleTechnique: 'dateLimiteControleTechnique',
    dateLimiteControlePollution: 'dateLimiteControlePollution',
    typeVehicule: 'typeVehicule',
    createdAt: 'createdAt'
  };

  export type VehiculeScalarFieldEnum = (typeof VehiculeScalarFieldEnum)[keyof typeof VehiculeScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    telephone: 'telephone',
    adresse: 'adresse',
    codePostal: 'codePostal',
    ville: 'ville',
    categories: 'categories',
    status: 'status',
    commentaires: 'commentaires',
    dateCreation: 'dateCreation',
    dateDerniereModification: 'dateDerniereModification',
    utilisateurId: 'utilisateurId',
    collaborateursIds: 'collaborateursIds',
    montantDevis: 'montantDevis',
    archived: 'archived',
    archiveDate: 'archiveDate'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const DemandeCongeScalarFieldEnum: {
    id: 'id',
    utilisateurId: 'utilisateurId',
    collaborateurId: 'collaborateurId',
    collaborateurNom: 'collaborateurNom',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    typeConge: 'typeConge',
    motif: 'motif',
    statut: 'statut',
    commentaireAdmin: 'commentaireAdmin',
    dateCreation: 'dateCreation',
    dateModification: 'dateModification',
    notificationLue: 'notificationLue'
  };

  export type DemandeCongeScalarFieldEnum = (typeof DemandeCongeScalarFieldEnum)[keyof typeof DemandeCongeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    utilisateurId: 'utilisateurId',
    message: 'message',
    lien: 'lien',
    dateCreation: 'dateCreation',
    lue: 'lue',
    type: 'type',
    demandeId: 'demandeId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ContratMaintenanceScalarFieldEnum: {
    id: 'id',
    client: 'client',
    reference: 'reference',
    type: 'type',
    montant: 'montant',
    dateDebut: 'dateDebut',
    dateEcheance: 'dateEcheance',
    statut: 'statut',
    description: 'description',
    contactClient: 'contactClient',
    emailContact: 'emailContact',
    telephoneContact: 'telephoneContact',
    notes: 'notes',
    dateCreation: 'dateCreation',
    dateDerniereModification: 'dateDerniereModification'
  };

  export type ContratMaintenanceScalarFieldEnum = (typeof ContratMaintenanceScalarFieldEnum)[keyof typeof ContratMaintenanceScalarFieldEnum]


  export const StockItemScalarFieldEnum: {
    id: 'id',
    cableType: 'cableType',
    typeM: 'typeM',
    typeG: 'typeG',
    enroulement: 'enroulement',
    longueur: 'longueur',
    createdAt: 'createdAt'
  };

  export type StockItemScalarFieldEnum = (typeof StockItemScalarFieldEnum)[keyof typeof StockItemScalarFieldEnum]


  export const FicheDePosteScalarFieldEnum: {
    id: 'id',
    classification: 'classification',
    poste: 'poste',
    entreprise: 'entreprise',
    typeContrat: 'typeContrat',
    dureeContrat: 'dureeContrat',
    certifications: 'certifications',
    habilitations: 'habilitations',
    competencesRequises: 'competencesRequises',
    description: 'description',
    missions: 'missions',
    experience: 'experience',
    formation: 'formation',
    remuneration: 'remuneration',
    avantages: 'avantages',
    horaires: 'horaires',
    email: 'email',
    telephone: 'telephone',
    adresse: 'adresse',
    codePostal: 'codePostal',
    ville: 'ville',
    dateNaissance: 'dateNaissance',
    numeroSecu: 'numeroSecu',
    lieuTravail: 'lieuTravail',
    dateCreation: 'dateCreation',
    dateModification: 'dateModification',
    estActive: 'estActive',
    collaborateurId: 'collaborateurId'
  };

  export type FicheDePosteScalarFieldEnum = (typeof FicheDePosteScalarFieldEnum)[keyof typeof FicheDePosteScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    telephone: 'telephone',
    role: 'role',
    departement: 'departement',
    dateCreation: 'dateCreation',
    dernierAcces: 'dernierAcces',
    estActif: 'estActif'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RoleAdmin'
   */
  export type EnumRoleAdminFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleAdmin'>
    


  /**
   * Reference to a field of type 'RoleAdmin[]'
   */
  export type ListEnumRoleAdminFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleAdmin[]'>
    
  /**
   * Deep Input Types
   */


  export type CollaborateurWhereInput = {
    AND?: CollaborateurWhereInput | CollaborateurWhereInput[]
    OR?: CollaborateurWhereInput[]
    NOT?: CollaborateurWhereInput | CollaborateurWhereInput[]
    id?: StringFilter<"Collaborateur"> | string
    nom?: StringFilter<"Collaborateur"> | string
    couleur?: StringFilter<"Collaborateur"> | string
    entreprise?: StringFilter<"Collaborateur"> | string
    aCompte?: BoolFilter<"Collaborateur"> | boolean
    createdAt?: DateTimeFilter<"Collaborateur"> | Date | string
    evenements?: EvenementListRelationFilter
    compte?: XOR<CompteNullableScalarRelationFilter, CompteWhereInput> | null
    managersPar?: CompteListRelationFilter
    contactsGeres?: ContactListRelationFilter
    demandesConges?: DemandeCongeListRelationFilter
    salarie?: XOR<SalarieNullableScalarRelationFilter, SalarieWhereInput> | null
    ficheDePoste?: XOR<FicheDePosteNullableScalarRelationFilter, FicheDePosteWhereInput> | null
  }

  export type CollaborateurOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    couleur?: SortOrder
    entreprise?: SortOrder
    aCompte?: SortOrder
    createdAt?: SortOrder
    evenements?: EvenementOrderByRelationAggregateInput
    compte?: CompteOrderByWithRelationInput
    managersPar?: CompteOrderByRelationAggregateInput
    contactsGeres?: ContactOrderByRelationAggregateInput
    demandesConges?: DemandeCongeOrderByRelationAggregateInput
    salarie?: SalarieOrderByWithRelationInput
    ficheDePoste?: FicheDePosteOrderByWithRelationInput
  }

  export type CollaborateurWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollaborateurWhereInput | CollaborateurWhereInput[]
    OR?: CollaborateurWhereInput[]
    NOT?: CollaborateurWhereInput | CollaborateurWhereInput[]
    nom?: StringFilter<"Collaborateur"> | string
    couleur?: StringFilter<"Collaborateur"> | string
    entreprise?: StringFilter<"Collaborateur"> | string
    aCompte?: BoolFilter<"Collaborateur"> | boolean
    createdAt?: DateTimeFilter<"Collaborateur"> | Date | string
    evenements?: EvenementListRelationFilter
    compte?: XOR<CompteNullableScalarRelationFilter, CompteWhereInput> | null
    managersPar?: CompteListRelationFilter
    contactsGeres?: ContactListRelationFilter
    demandesConges?: DemandeCongeListRelationFilter
    salarie?: XOR<SalarieNullableScalarRelationFilter, SalarieWhereInput> | null
    ficheDePoste?: XOR<FicheDePosteNullableScalarRelationFilter, FicheDePosteWhereInput> | null
  }, "id">

  export type CollaborateurOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    couleur?: SortOrder
    entreprise?: SortOrder
    aCompte?: SortOrder
    createdAt?: SortOrder
    _count?: CollaborateurCountOrderByAggregateInput
    _max?: CollaborateurMaxOrderByAggregateInput
    _min?: CollaborateurMinOrderByAggregateInput
  }

  export type CollaborateurScalarWhereWithAggregatesInput = {
    AND?: CollaborateurScalarWhereWithAggregatesInput | CollaborateurScalarWhereWithAggregatesInput[]
    OR?: CollaborateurScalarWhereWithAggregatesInput[]
    NOT?: CollaborateurScalarWhereWithAggregatesInput | CollaborateurScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Collaborateur"> | string
    nom?: StringWithAggregatesFilter<"Collaborateur"> | string
    couleur?: StringWithAggregatesFilter<"Collaborateur"> | string
    entreprise?: StringWithAggregatesFilter<"Collaborateur"> | string
    aCompte?: BoolWithAggregatesFilter<"Collaborateur"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Collaborateur"> | Date | string
  }

  export type CompteWhereInput = {
    AND?: CompteWhereInput | CompteWhereInput[]
    OR?: CompteWhereInput[]
    NOT?: CompteWhereInput | CompteWhereInput[]
    id?: StringFilter<"Compte"> | string
    identifiant?: StringFilter<"Compte"> | string
    motDePasse?: StringFilter<"Compte"> | string
    role?: EnumRoleFilter<"Compte"> | $Enums.Role
    collaborateurId?: StringFilter<"Compte"> | string
    createdAt?: DateTimeFilter<"Compte"> | Date | string
    collaborateur?: XOR<CollaborateurScalarRelationFilter, CollaborateurWhereInput>
    collaborateursGeres?: CollaborateurListRelationFilter
    demandesConges?: DemandeCongeListRelationFilter
    contacts?: ContactListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type CompteOrderByWithRelationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    motDePasse?: SortOrder
    role?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
    collaborateur?: CollaborateurOrderByWithRelationInput
    collaborateursGeres?: CollaborateurOrderByRelationAggregateInput
    demandesConges?: DemandeCongeOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type CompteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifiant?: string
    collaborateurId?: string
    AND?: CompteWhereInput | CompteWhereInput[]
    OR?: CompteWhereInput[]
    NOT?: CompteWhereInput | CompteWhereInput[]
    motDePasse?: StringFilter<"Compte"> | string
    role?: EnumRoleFilter<"Compte"> | $Enums.Role
    createdAt?: DateTimeFilter<"Compte"> | Date | string
    collaborateur?: XOR<CollaborateurScalarRelationFilter, CollaborateurWhereInput>
    collaborateursGeres?: CollaborateurListRelationFilter
    demandesConges?: DemandeCongeListRelationFilter
    contacts?: ContactListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "identifiant" | "collaborateurId">

  export type CompteOrderByWithAggregationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    motDePasse?: SortOrder
    role?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
    _count?: CompteCountOrderByAggregateInput
    _max?: CompteMaxOrderByAggregateInput
    _min?: CompteMinOrderByAggregateInput
  }

  export type CompteScalarWhereWithAggregatesInput = {
    AND?: CompteScalarWhereWithAggregatesInput | CompteScalarWhereWithAggregatesInput[]
    OR?: CompteScalarWhereWithAggregatesInput[]
    NOT?: CompteScalarWhereWithAggregatesInput | CompteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Compte"> | string
    identifiant?: StringWithAggregatesFilter<"Compte"> | string
    motDePasse?: StringWithAggregatesFilter<"Compte"> | string
    role?: EnumRoleWithAggregatesFilter<"Compte"> | $Enums.Role
    collaborateurId?: StringWithAggregatesFilter<"Compte"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Compte"> | Date | string
  }

  export type EvenementWhereInput = {
    AND?: EvenementWhereInput | EvenementWhereInput[]
    OR?: EvenementWhereInput[]
    NOT?: EvenementWhereInput | EvenementWhereInput[]
    id?: StringFilter<"Evenement"> | string
    title?: StringFilter<"Evenement"> | string
    start?: DateTimeFilter<"Evenement"> | Date | string
    end?: DateTimeFilter<"Evenement"> | Date | string
    collaborateurId?: StringFilter<"Evenement"> | string
    typeEvenement?: StringFilter<"Evenement"> | string
    lieuChantier?: StringNullableFilter<"Evenement"> | string | null
    zoneTrajet?: StringNullableFilter<"Evenement"> | string | null
    panierRepas?: BoolFilter<"Evenement"> | boolean
    ticketRestaurant?: BoolFilter<"Evenement"> | boolean
    heuresSupplementaires?: FloatFilter<"Evenement"> | number
    grandDeplacement?: BoolFilter<"Evenement"> | boolean
    prgd?: BoolFilter<"Evenement"> | boolean
    nombrePrgd?: IntFilter<"Evenement"> | number
    typeAbsence?: StringNullableFilter<"Evenement"> | string | null
    verrouille?: BoolFilter<"Evenement"> | boolean
    latitude?: FloatNullableFilter<"Evenement"> | number | null
    longitude?: FloatNullableFilter<"Evenement"> | number | null
    adresseComplete?: StringNullableFilter<"Evenement"> | string | null
    createdAt?: DateTimeFilter<"Evenement"> | Date | string
    collaborateur?: XOR<CollaborateurScalarRelationFilter, CollaborateurWhereInput>
  }

  export type EvenementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    collaborateurId?: SortOrder
    typeEvenement?: SortOrder
    lieuChantier?: SortOrderInput | SortOrder
    zoneTrajet?: SortOrderInput | SortOrder
    panierRepas?: SortOrder
    ticketRestaurant?: SortOrder
    heuresSupplementaires?: SortOrder
    grandDeplacement?: SortOrder
    prgd?: SortOrder
    nombrePrgd?: SortOrder
    typeAbsence?: SortOrderInput | SortOrder
    verrouille?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    adresseComplete?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    collaborateur?: CollaborateurOrderByWithRelationInput
  }

  export type EvenementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvenementWhereInput | EvenementWhereInput[]
    OR?: EvenementWhereInput[]
    NOT?: EvenementWhereInput | EvenementWhereInput[]
    title?: StringFilter<"Evenement"> | string
    start?: DateTimeFilter<"Evenement"> | Date | string
    end?: DateTimeFilter<"Evenement"> | Date | string
    collaborateurId?: StringFilter<"Evenement"> | string
    typeEvenement?: StringFilter<"Evenement"> | string
    lieuChantier?: StringNullableFilter<"Evenement"> | string | null
    zoneTrajet?: StringNullableFilter<"Evenement"> | string | null
    panierRepas?: BoolFilter<"Evenement"> | boolean
    ticketRestaurant?: BoolFilter<"Evenement"> | boolean
    heuresSupplementaires?: FloatFilter<"Evenement"> | number
    grandDeplacement?: BoolFilter<"Evenement"> | boolean
    prgd?: BoolFilter<"Evenement"> | boolean
    nombrePrgd?: IntFilter<"Evenement"> | number
    typeAbsence?: StringNullableFilter<"Evenement"> | string | null
    verrouille?: BoolFilter<"Evenement"> | boolean
    latitude?: FloatNullableFilter<"Evenement"> | number | null
    longitude?: FloatNullableFilter<"Evenement"> | number | null
    adresseComplete?: StringNullableFilter<"Evenement"> | string | null
    createdAt?: DateTimeFilter<"Evenement"> | Date | string
    collaborateur?: XOR<CollaborateurScalarRelationFilter, CollaborateurWhereInput>
  }, "id">

  export type EvenementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    collaborateurId?: SortOrder
    typeEvenement?: SortOrder
    lieuChantier?: SortOrderInput | SortOrder
    zoneTrajet?: SortOrderInput | SortOrder
    panierRepas?: SortOrder
    ticketRestaurant?: SortOrder
    heuresSupplementaires?: SortOrder
    grandDeplacement?: SortOrder
    prgd?: SortOrder
    nombrePrgd?: SortOrder
    typeAbsence?: SortOrderInput | SortOrder
    verrouille?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    adresseComplete?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EvenementCountOrderByAggregateInput
    _avg?: EvenementAvgOrderByAggregateInput
    _max?: EvenementMaxOrderByAggregateInput
    _min?: EvenementMinOrderByAggregateInput
    _sum?: EvenementSumOrderByAggregateInput
  }

  export type EvenementScalarWhereWithAggregatesInput = {
    AND?: EvenementScalarWhereWithAggregatesInput | EvenementScalarWhereWithAggregatesInput[]
    OR?: EvenementScalarWhereWithAggregatesInput[]
    NOT?: EvenementScalarWhereWithAggregatesInput | EvenementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evenement"> | string
    title?: StringWithAggregatesFilter<"Evenement"> | string
    start?: DateTimeWithAggregatesFilter<"Evenement"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Evenement"> | Date | string
    collaborateurId?: StringWithAggregatesFilter<"Evenement"> | string
    typeEvenement?: StringWithAggregatesFilter<"Evenement"> | string
    lieuChantier?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    zoneTrajet?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    panierRepas?: BoolWithAggregatesFilter<"Evenement"> | boolean
    ticketRestaurant?: BoolWithAggregatesFilter<"Evenement"> | boolean
    heuresSupplementaires?: FloatWithAggregatesFilter<"Evenement"> | number
    grandDeplacement?: BoolWithAggregatesFilter<"Evenement"> | boolean
    prgd?: BoolWithAggregatesFilter<"Evenement"> | boolean
    nombrePrgd?: IntWithAggregatesFilter<"Evenement"> | number
    typeAbsence?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    verrouille?: BoolWithAggregatesFilter<"Evenement"> | boolean
    latitude?: FloatNullableWithAggregatesFilter<"Evenement"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Evenement"> | number | null
    adresseComplete?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evenement"> | Date | string
  }

  export type SalarieWhereInput = {
    AND?: SalarieWhereInput | SalarieWhereInput[]
    OR?: SalarieWhereInput[]
    NOT?: SalarieWhereInput | SalarieWhereInput[]
    id?: StringFilter<"Salarie"> | string
    nom?: StringFilter<"Salarie"> | string
    prenom?: StringFilter<"Salarie"> | string
    classification?: StringFilter<"Salarie"> | string
    dateEntree?: DateTimeFilter<"Salarie"> | Date | string
    typeContrat?: StringFilter<"Salarie"> | string
    dureeContrat?: StringNullableFilter<"Salarie"> | string | null
    certifications?: StringNullableListFilter<"Salarie">
    habilitations?: StringNullableListFilter<"Salarie">
    entreprise?: StringFilter<"Salarie"> | string
    poste?: StringFilter<"Salarie"> | string
    email?: StringFilter<"Salarie"> | string
    telephone?: StringFilter<"Salarie"> | string
    adresse?: StringNullableFilter<"Salarie"> | string | null
    codePostal?: StringNullableFilter<"Salarie"> | string | null
    ville?: StringNullableFilter<"Salarie"> | string | null
    dateNaissance?: DateTimeNullableFilter<"Salarie"> | Date | string | null
    numeroSecu?: StringNullableFilter<"Salarie"> | string | null
    collaborateurId?: StringNullableFilter<"Salarie"> | string | null
    createdAt?: DateTimeFilter<"Salarie"> | Date | string
    collaborateur?: XOR<CollaborateurNullableScalarRelationFilter, CollaborateurWhereInput> | null
  }

  export type SalarieOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    classification?: SortOrder
    dateEntree?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrderInput | SortOrder
    certifications?: SortOrder
    habilitations?: SortOrder
    entreprise?: SortOrder
    poste?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    numeroSecu?: SortOrderInput | SortOrder
    collaborateurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    collaborateur?: CollaborateurOrderByWithRelationInput
  }

  export type SalarieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    collaborateurId?: string
    AND?: SalarieWhereInput | SalarieWhereInput[]
    OR?: SalarieWhereInput[]
    NOT?: SalarieWhereInput | SalarieWhereInput[]
    nom?: StringFilter<"Salarie"> | string
    prenom?: StringFilter<"Salarie"> | string
    classification?: StringFilter<"Salarie"> | string
    dateEntree?: DateTimeFilter<"Salarie"> | Date | string
    typeContrat?: StringFilter<"Salarie"> | string
    dureeContrat?: StringNullableFilter<"Salarie"> | string | null
    certifications?: StringNullableListFilter<"Salarie">
    habilitations?: StringNullableListFilter<"Salarie">
    entreprise?: StringFilter<"Salarie"> | string
    poste?: StringFilter<"Salarie"> | string
    email?: StringFilter<"Salarie"> | string
    telephone?: StringFilter<"Salarie"> | string
    adresse?: StringNullableFilter<"Salarie"> | string | null
    codePostal?: StringNullableFilter<"Salarie"> | string | null
    ville?: StringNullableFilter<"Salarie"> | string | null
    dateNaissance?: DateTimeNullableFilter<"Salarie"> | Date | string | null
    numeroSecu?: StringNullableFilter<"Salarie"> | string | null
    createdAt?: DateTimeFilter<"Salarie"> | Date | string
    collaborateur?: XOR<CollaborateurNullableScalarRelationFilter, CollaborateurWhereInput> | null
  }, "id" | "collaborateurId">

  export type SalarieOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    classification?: SortOrder
    dateEntree?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrderInput | SortOrder
    certifications?: SortOrder
    habilitations?: SortOrder
    entreprise?: SortOrder
    poste?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    numeroSecu?: SortOrderInput | SortOrder
    collaborateurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SalarieCountOrderByAggregateInput
    _max?: SalarieMaxOrderByAggregateInput
    _min?: SalarieMinOrderByAggregateInput
  }

  export type SalarieScalarWhereWithAggregatesInput = {
    AND?: SalarieScalarWhereWithAggregatesInput | SalarieScalarWhereWithAggregatesInput[]
    OR?: SalarieScalarWhereWithAggregatesInput[]
    NOT?: SalarieScalarWhereWithAggregatesInput | SalarieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Salarie"> | string
    nom?: StringWithAggregatesFilter<"Salarie"> | string
    prenom?: StringWithAggregatesFilter<"Salarie"> | string
    classification?: StringWithAggregatesFilter<"Salarie"> | string
    dateEntree?: DateTimeWithAggregatesFilter<"Salarie"> | Date | string
    typeContrat?: StringWithAggregatesFilter<"Salarie"> | string
    dureeContrat?: StringNullableWithAggregatesFilter<"Salarie"> | string | null
    certifications?: StringNullableListFilter<"Salarie">
    habilitations?: StringNullableListFilter<"Salarie">
    entreprise?: StringWithAggregatesFilter<"Salarie"> | string
    poste?: StringWithAggregatesFilter<"Salarie"> | string
    email?: StringWithAggregatesFilter<"Salarie"> | string
    telephone?: StringWithAggregatesFilter<"Salarie"> | string
    adresse?: StringNullableWithAggregatesFilter<"Salarie"> | string | null
    codePostal?: StringNullableWithAggregatesFilter<"Salarie"> | string | null
    ville?: StringNullableWithAggregatesFilter<"Salarie"> | string | null
    dateNaissance?: DateTimeNullableWithAggregatesFilter<"Salarie"> | Date | string | null
    numeroSecu?: StringNullableWithAggregatesFilter<"Salarie"> | string | null
    collaborateurId?: StringNullableWithAggregatesFilter<"Salarie"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Salarie"> | Date | string
  }

  export type VehiculeWhereInput = {
    AND?: VehiculeWhereInput | VehiculeWhereInput[]
    OR?: VehiculeWhereInput[]
    NOT?: VehiculeWhereInput | VehiculeWhereInput[]
    id?: StringFilter<"Vehicule"> | string
    societe?: StringFilter<"Vehicule"> | string
    marque?: StringFilter<"Vehicule"> | string
    modele?: StringFilter<"Vehicule"> | string
    immatriculation?: StringFilter<"Vehicule"> | string
    etat?: StringFilter<"Vehicule"> | string
    proprietaire?: StringFilter<"Vehicule"> | string
    dateMiseEnCirculation?: DateTimeNullableFilter<"Vehicule"> | Date | string | null
    kilometrage?: IntNullableFilter<"Vehicule"> | number | null
    kmProchaineRevision?: IntNullableFilter<"Vehicule"> | number | null
    dateLimiteControleTechnique?: DateTimeNullableFilter<"Vehicule"> | Date | string | null
    dateLimiteControlePollution?: DateTimeNullableFilter<"Vehicule"> | Date | string | null
    typeVehicule?: StringNullableFilter<"Vehicule"> | string | null
    createdAt?: DateTimeFilter<"Vehicule"> | Date | string
  }

  export type VehiculeOrderByWithRelationInput = {
    id?: SortOrder
    societe?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    immatriculation?: SortOrder
    etat?: SortOrder
    proprietaire?: SortOrder
    dateMiseEnCirculation?: SortOrderInput | SortOrder
    kilometrage?: SortOrderInput | SortOrder
    kmProchaineRevision?: SortOrderInput | SortOrder
    dateLimiteControleTechnique?: SortOrderInput | SortOrder
    dateLimiteControlePollution?: SortOrderInput | SortOrder
    typeVehicule?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type VehiculeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    immatriculation?: string
    AND?: VehiculeWhereInput | VehiculeWhereInput[]
    OR?: VehiculeWhereInput[]
    NOT?: VehiculeWhereInput | VehiculeWhereInput[]
    societe?: StringFilter<"Vehicule"> | string
    marque?: StringFilter<"Vehicule"> | string
    modele?: StringFilter<"Vehicule"> | string
    etat?: StringFilter<"Vehicule"> | string
    proprietaire?: StringFilter<"Vehicule"> | string
    dateMiseEnCirculation?: DateTimeNullableFilter<"Vehicule"> | Date | string | null
    kilometrage?: IntNullableFilter<"Vehicule"> | number | null
    kmProchaineRevision?: IntNullableFilter<"Vehicule"> | number | null
    dateLimiteControleTechnique?: DateTimeNullableFilter<"Vehicule"> | Date | string | null
    dateLimiteControlePollution?: DateTimeNullableFilter<"Vehicule"> | Date | string | null
    typeVehicule?: StringNullableFilter<"Vehicule"> | string | null
    createdAt?: DateTimeFilter<"Vehicule"> | Date | string
  }, "id" | "immatriculation">

  export type VehiculeOrderByWithAggregationInput = {
    id?: SortOrder
    societe?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    immatriculation?: SortOrder
    etat?: SortOrder
    proprietaire?: SortOrder
    dateMiseEnCirculation?: SortOrderInput | SortOrder
    kilometrage?: SortOrderInput | SortOrder
    kmProchaineRevision?: SortOrderInput | SortOrder
    dateLimiteControleTechnique?: SortOrderInput | SortOrder
    dateLimiteControlePollution?: SortOrderInput | SortOrder
    typeVehicule?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VehiculeCountOrderByAggregateInput
    _avg?: VehiculeAvgOrderByAggregateInput
    _max?: VehiculeMaxOrderByAggregateInput
    _min?: VehiculeMinOrderByAggregateInput
    _sum?: VehiculeSumOrderByAggregateInput
  }

  export type VehiculeScalarWhereWithAggregatesInput = {
    AND?: VehiculeScalarWhereWithAggregatesInput | VehiculeScalarWhereWithAggregatesInput[]
    OR?: VehiculeScalarWhereWithAggregatesInput[]
    NOT?: VehiculeScalarWhereWithAggregatesInput | VehiculeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicule"> | string
    societe?: StringWithAggregatesFilter<"Vehicule"> | string
    marque?: StringWithAggregatesFilter<"Vehicule"> | string
    modele?: StringWithAggregatesFilter<"Vehicule"> | string
    immatriculation?: StringWithAggregatesFilter<"Vehicule"> | string
    etat?: StringWithAggregatesFilter<"Vehicule"> | string
    proprietaire?: StringWithAggregatesFilter<"Vehicule"> | string
    dateMiseEnCirculation?: DateTimeNullableWithAggregatesFilter<"Vehicule"> | Date | string | null
    kilometrage?: IntNullableWithAggregatesFilter<"Vehicule"> | number | null
    kmProchaineRevision?: IntNullableWithAggregatesFilter<"Vehicule"> | number | null
    dateLimiteControleTechnique?: DateTimeNullableWithAggregatesFilter<"Vehicule"> | Date | string | null
    dateLimiteControlePollution?: DateTimeNullableWithAggregatesFilter<"Vehicule"> | Date | string | null
    typeVehicule?: StringNullableWithAggregatesFilter<"Vehicule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vehicule"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    nom?: StringFilter<"Contact"> | string
    prenom?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    telephone?: StringFilter<"Contact"> | string
    adresse?: StringFilter<"Contact"> | string
    codePostal?: StringFilter<"Contact"> | string
    ville?: StringFilter<"Contact"> | string
    categories?: StringNullableListFilter<"Contact">
    status?: StringFilter<"Contact"> | string
    commentaires?: StringNullableFilter<"Contact"> | string | null
    dateCreation?: DateTimeFilter<"Contact"> | Date | string
    dateDerniereModification?: DateTimeFilter<"Contact"> | Date | string
    utilisateurId?: StringFilter<"Contact"> | string
    collaborateursIds?: StringNullableListFilter<"Contact">
    montantDevis?: FloatNullableFilter<"Contact"> | number | null
    archived?: BoolFilter<"Contact"> | boolean
    archiveDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    utilisateur?: XOR<CompteScalarRelationFilter, CompteWhereInput>
    collaborateurs?: CollaborateurListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    categories?: SortOrder
    status?: SortOrder
    commentaires?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
    utilisateurId?: SortOrder
    collaborateursIds?: SortOrder
    montantDevis?: SortOrderInput | SortOrder
    archived?: SortOrder
    archiveDate?: SortOrderInput | SortOrder
    utilisateur?: CompteOrderByWithRelationInput
    collaborateurs?: CollaborateurOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    nom?: StringFilter<"Contact"> | string
    prenom?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    telephone?: StringFilter<"Contact"> | string
    adresse?: StringFilter<"Contact"> | string
    codePostal?: StringFilter<"Contact"> | string
    ville?: StringFilter<"Contact"> | string
    categories?: StringNullableListFilter<"Contact">
    status?: StringFilter<"Contact"> | string
    commentaires?: StringNullableFilter<"Contact"> | string | null
    dateCreation?: DateTimeFilter<"Contact"> | Date | string
    dateDerniereModification?: DateTimeFilter<"Contact"> | Date | string
    utilisateurId?: StringFilter<"Contact"> | string
    collaborateursIds?: StringNullableListFilter<"Contact">
    montantDevis?: FloatNullableFilter<"Contact"> | number | null
    archived?: BoolFilter<"Contact"> | boolean
    archiveDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    utilisateur?: XOR<CompteScalarRelationFilter, CompteWhereInput>
    collaborateurs?: CollaborateurListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    categories?: SortOrder
    status?: SortOrder
    commentaires?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
    utilisateurId?: SortOrder
    collaborateursIds?: SortOrder
    montantDevis?: SortOrderInput | SortOrder
    archived?: SortOrder
    archiveDate?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    nom?: StringWithAggregatesFilter<"Contact"> | string
    prenom?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    telephone?: StringWithAggregatesFilter<"Contact"> | string
    adresse?: StringWithAggregatesFilter<"Contact"> | string
    codePostal?: StringWithAggregatesFilter<"Contact"> | string
    ville?: StringWithAggregatesFilter<"Contact"> | string
    categories?: StringNullableListFilter<"Contact">
    status?: StringWithAggregatesFilter<"Contact"> | string
    commentaires?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    dateCreation?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    dateDerniereModification?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    utilisateurId?: StringWithAggregatesFilter<"Contact"> | string
    collaborateursIds?: StringNullableListFilter<"Contact">
    montantDevis?: FloatNullableWithAggregatesFilter<"Contact"> | number | null
    archived?: BoolWithAggregatesFilter<"Contact"> | boolean
    archiveDate?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
  }

  export type DemandeCongeWhereInput = {
    AND?: DemandeCongeWhereInput | DemandeCongeWhereInput[]
    OR?: DemandeCongeWhereInput[]
    NOT?: DemandeCongeWhereInput | DemandeCongeWhereInput[]
    id?: StringFilter<"DemandeConge"> | string
    utilisateurId?: StringFilter<"DemandeConge"> | string
    collaborateurId?: StringFilter<"DemandeConge"> | string
    collaborateurNom?: StringFilter<"DemandeConge"> | string
    dateDebut?: DateTimeFilter<"DemandeConge"> | Date | string
    dateFin?: DateTimeFilter<"DemandeConge"> | Date | string
    typeConge?: StringFilter<"DemandeConge"> | string
    motif?: StringFilter<"DemandeConge"> | string
    statut?: StringFilter<"DemandeConge"> | string
    commentaireAdmin?: StringNullableFilter<"DemandeConge"> | string | null
    dateCreation?: DateTimeFilter<"DemandeConge"> | Date | string
    dateModification?: DateTimeFilter<"DemandeConge"> | Date | string
    notificationLue?: BoolFilter<"DemandeConge"> | boolean
    utilisateur?: XOR<CompteScalarRelationFilter, CompteWhereInput>
    collaborateur?: XOR<CollaborateurScalarRelationFilter, CollaborateurWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type DemandeCongeOrderByWithRelationInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    collaborateurId?: SortOrder
    collaborateurNom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    typeConge?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    commentaireAdmin?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    notificationLue?: SortOrder
    utilisateur?: CompteOrderByWithRelationInput
    collaborateur?: CollaborateurOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type DemandeCongeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DemandeCongeWhereInput | DemandeCongeWhereInput[]
    OR?: DemandeCongeWhereInput[]
    NOT?: DemandeCongeWhereInput | DemandeCongeWhereInput[]
    utilisateurId?: StringFilter<"DemandeConge"> | string
    collaborateurId?: StringFilter<"DemandeConge"> | string
    collaborateurNom?: StringFilter<"DemandeConge"> | string
    dateDebut?: DateTimeFilter<"DemandeConge"> | Date | string
    dateFin?: DateTimeFilter<"DemandeConge"> | Date | string
    typeConge?: StringFilter<"DemandeConge"> | string
    motif?: StringFilter<"DemandeConge"> | string
    statut?: StringFilter<"DemandeConge"> | string
    commentaireAdmin?: StringNullableFilter<"DemandeConge"> | string | null
    dateCreation?: DateTimeFilter<"DemandeConge"> | Date | string
    dateModification?: DateTimeFilter<"DemandeConge"> | Date | string
    notificationLue?: BoolFilter<"DemandeConge"> | boolean
    utilisateur?: XOR<CompteScalarRelationFilter, CompteWhereInput>
    collaborateur?: XOR<CollaborateurScalarRelationFilter, CollaborateurWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type DemandeCongeOrderByWithAggregationInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    collaborateurId?: SortOrder
    collaborateurNom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    typeConge?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    commentaireAdmin?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    notificationLue?: SortOrder
    _count?: DemandeCongeCountOrderByAggregateInput
    _max?: DemandeCongeMaxOrderByAggregateInput
    _min?: DemandeCongeMinOrderByAggregateInput
  }

  export type DemandeCongeScalarWhereWithAggregatesInput = {
    AND?: DemandeCongeScalarWhereWithAggregatesInput | DemandeCongeScalarWhereWithAggregatesInput[]
    OR?: DemandeCongeScalarWhereWithAggregatesInput[]
    NOT?: DemandeCongeScalarWhereWithAggregatesInput | DemandeCongeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DemandeConge"> | string
    utilisateurId?: StringWithAggregatesFilter<"DemandeConge"> | string
    collaborateurId?: StringWithAggregatesFilter<"DemandeConge"> | string
    collaborateurNom?: StringWithAggregatesFilter<"DemandeConge"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"DemandeConge"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"DemandeConge"> | Date | string
    typeConge?: StringWithAggregatesFilter<"DemandeConge"> | string
    motif?: StringWithAggregatesFilter<"DemandeConge"> | string
    statut?: StringWithAggregatesFilter<"DemandeConge"> | string
    commentaireAdmin?: StringNullableWithAggregatesFilter<"DemandeConge"> | string | null
    dateCreation?: DateTimeWithAggregatesFilter<"DemandeConge"> | Date | string
    dateModification?: DateTimeWithAggregatesFilter<"DemandeConge"> | Date | string
    notificationLue?: BoolWithAggregatesFilter<"DemandeConge"> | boolean
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    utilisateurId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    lien?: StringFilter<"Notification"> | string
    dateCreation?: DateTimeFilter<"Notification"> | Date | string
    lue?: BoolFilter<"Notification"> | boolean
    type?: StringFilter<"Notification"> | string
    demandeId?: StringNullableFilter<"Notification"> | string | null
    utilisateur?: XOR<CompteScalarRelationFilter, CompteWhereInput>
    demandeConge?: XOR<DemandeCongeNullableScalarRelationFilter, DemandeCongeWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    message?: SortOrder
    lien?: SortOrder
    dateCreation?: SortOrder
    lue?: SortOrder
    type?: SortOrder
    demandeId?: SortOrderInput | SortOrder
    utilisateur?: CompteOrderByWithRelationInput
    demandeConge?: DemandeCongeOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    utilisateurId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    lien?: StringFilter<"Notification"> | string
    dateCreation?: DateTimeFilter<"Notification"> | Date | string
    lue?: BoolFilter<"Notification"> | boolean
    type?: StringFilter<"Notification"> | string
    demandeId?: StringNullableFilter<"Notification"> | string | null
    utilisateur?: XOR<CompteScalarRelationFilter, CompteWhereInput>
    demandeConge?: XOR<DemandeCongeNullableScalarRelationFilter, DemandeCongeWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    message?: SortOrder
    lien?: SortOrder
    dateCreation?: SortOrder
    lue?: SortOrder
    type?: SortOrder
    demandeId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    utilisateurId?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    lien?: StringWithAggregatesFilter<"Notification"> | string
    dateCreation?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    lue?: BoolWithAggregatesFilter<"Notification"> | boolean
    type?: StringWithAggregatesFilter<"Notification"> | string
    demandeId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type ContratMaintenanceWhereInput = {
    AND?: ContratMaintenanceWhereInput | ContratMaintenanceWhereInput[]
    OR?: ContratMaintenanceWhereInput[]
    NOT?: ContratMaintenanceWhereInput | ContratMaintenanceWhereInput[]
    id?: StringFilter<"ContratMaintenance"> | string
    client?: StringFilter<"ContratMaintenance"> | string
    reference?: StringFilter<"ContratMaintenance"> | string
    type?: StringFilter<"ContratMaintenance"> | string
    montant?: FloatFilter<"ContratMaintenance"> | number
    dateDebut?: DateTimeFilter<"ContratMaintenance"> | Date | string
    dateEcheance?: DateTimeFilter<"ContratMaintenance"> | Date | string
    statut?: StringFilter<"ContratMaintenance"> | string
    description?: StringFilter<"ContratMaintenance"> | string
    contactClient?: StringFilter<"ContratMaintenance"> | string
    emailContact?: StringFilter<"ContratMaintenance"> | string
    telephoneContact?: StringFilter<"ContratMaintenance"> | string
    notes?: StringNullableFilter<"ContratMaintenance"> | string | null
    dateCreation?: DateTimeFilter<"ContratMaintenance"> | Date | string
    dateDerniereModification?: DateTimeFilter<"ContratMaintenance"> | Date | string
  }

  export type ContratMaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    client?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateDebut?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    description?: SortOrder
    contactClient?: SortOrder
    emailContact?: SortOrder
    telephoneContact?: SortOrder
    notes?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
  }

  export type ContratMaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: ContratMaintenanceWhereInput | ContratMaintenanceWhereInput[]
    OR?: ContratMaintenanceWhereInput[]
    NOT?: ContratMaintenanceWhereInput | ContratMaintenanceWhereInput[]
    client?: StringFilter<"ContratMaintenance"> | string
    type?: StringFilter<"ContratMaintenance"> | string
    montant?: FloatFilter<"ContratMaintenance"> | number
    dateDebut?: DateTimeFilter<"ContratMaintenance"> | Date | string
    dateEcheance?: DateTimeFilter<"ContratMaintenance"> | Date | string
    statut?: StringFilter<"ContratMaintenance"> | string
    description?: StringFilter<"ContratMaintenance"> | string
    contactClient?: StringFilter<"ContratMaintenance"> | string
    emailContact?: StringFilter<"ContratMaintenance"> | string
    telephoneContact?: StringFilter<"ContratMaintenance"> | string
    notes?: StringNullableFilter<"ContratMaintenance"> | string | null
    dateCreation?: DateTimeFilter<"ContratMaintenance"> | Date | string
    dateDerniereModification?: DateTimeFilter<"ContratMaintenance"> | Date | string
  }, "id" | "reference">

  export type ContratMaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    client?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateDebut?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    description?: SortOrder
    contactClient?: SortOrder
    emailContact?: SortOrder
    telephoneContact?: SortOrder
    notes?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
    _count?: ContratMaintenanceCountOrderByAggregateInput
    _avg?: ContratMaintenanceAvgOrderByAggregateInput
    _max?: ContratMaintenanceMaxOrderByAggregateInput
    _min?: ContratMaintenanceMinOrderByAggregateInput
    _sum?: ContratMaintenanceSumOrderByAggregateInput
  }

  export type ContratMaintenanceScalarWhereWithAggregatesInput = {
    AND?: ContratMaintenanceScalarWhereWithAggregatesInput | ContratMaintenanceScalarWhereWithAggregatesInput[]
    OR?: ContratMaintenanceScalarWhereWithAggregatesInput[]
    NOT?: ContratMaintenanceScalarWhereWithAggregatesInput | ContratMaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    client?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    reference?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    type?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    montant?: FloatWithAggregatesFilter<"ContratMaintenance"> | number
    dateDebut?: DateTimeWithAggregatesFilter<"ContratMaintenance"> | Date | string
    dateEcheance?: DateTimeWithAggregatesFilter<"ContratMaintenance"> | Date | string
    statut?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    description?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    contactClient?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    emailContact?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    telephoneContact?: StringWithAggregatesFilter<"ContratMaintenance"> | string
    notes?: StringNullableWithAggregatesFilter<"ContratMaintenance"> | string | null
    dateCreation?: DateTimeWithAggregatesFilter<"ContratMaintenance"> | Date | string
    dateDerniereModification?: DateTimeWithAggregatesFilter<"ContratMaintenance"> | Date | string
  }

  export type StockItemWhereInput = {
    AND?: StockItemWhereInput | StockItemWhereInput[]
    OR?: StockItemWhereInput[]
    NOT?: StockItemWhereInput | StockItemWhereInput[]
    id?: StringFilter<"StockItem"> | string
    cableType?: StringFilter<"StockItem"> | string
    typeM?: StringFilter<"StockItem"> | string
    typeG?: StringFilter<"StockItem"> | string
    enroulement?: StringFilter<"StockItem"> | string
    longueur?: IntFilter<"StockItem"> | number
    createdAt?: DateTimeFilter<"StockItem"> | Date | string
  }

  export type StockItemOrderByWithRelationInput = {
    id?: SortOrder
    cableType?: SortOrder
    typeM?: SortOrder
    typeG?: SortOrder
    enroulement?: SortOrder
    longueur?: SortOrder
    createdAt?: SortOrder
  }

  export type StockItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockItemWhereInput | StockItemWhereInput[]
    OR?: StockItemWhereInput[]
    NOT?: StockItemWhereInput | StockItemWhereInput[]
    cableType?: StringFilter<"StockItem"> | string
    typeM?: StringFilter<"StockItem"> | string
    typeG?: StringFilter<"StockItem"> | string
    enroulement?: StringFilter<"StockItem"> | string
    longueur?: IntFilter<"StockItem"> | number
    createdAt?: DateTimeFilter<"StockItem"> | Date | string
  }, "id">

  export type StockItemOrderByWithAggregationInput = {
    id?: SortOrder
    cableType?: SortOrder
    typeM?: SortOrder
    typeG?: SortOrder
    enroulement?: SortOrder
    longueur?: SortOrder
    createdAt?: SortOrder
    _count?: StockItemCountOrderByAggregateInput
    _avg?: StockItemAvgOrderByAggregateInput
    _max?: StockItemMaxOrderByAggregateInput
    _min?: StockItemMinOrderByAggregateInput
    _sum?: StockItemSumOrderByAggregateInput
  }

  export type StockItemScalarWhereWithAggregatesInput = {
    AND?: StockItemScalarWhereWithAggregatesInput | StockItemScalarWhereWithAggregatesInput[]
    OR?: StockItemScalarWhereWithAggregatesInput[]
    NOT?: StockItemScalarWhereWithAggregatesInput | StockItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockItem"> | string
    cableType?: StringWithAggregatesFilter<"StockItem"> | string
    typeM?: StringWithAggregatesFilter<"StockItem"> | string
    typeG?: StringWithAggregatesFilter<"StockItem"> | string
    enroulement?: StringWithAggregatesFilter<"StockItem"> | string
    longueur?: IntWithAggregatesFilter<"StockItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StockItem"> | Date | string
  }

  export type FicheDePosteWhereInput = {
    AND?: FicheDePosteWhereInput | FicheDePosteWhereInput[]
    OR?: FicheDePosteWhereInput[]
    NOT?: FicheDePosteWhereInput | FicheDePosteWhereInput[]
    id?: StringFilter<"FicheDePoste"> | string
    classification?: StringFilter<"FicheDePoste"> | string
    poste?: StringFilter<"FicheDePoste"> | string
    entreprise?: StringFilter<"FicheDePoste"> | string
    typeContrat?: StringFilter<"FicheDePoste"> | string
    dureeContrat?: StringNullableFilter<"FicheDePoste"> | string | null
    certifications?: StringNullableListFilter<"FicheDePoste">
    habilitations?: StringNullableListFilter<"FicheDePoste">
    competencesRequises?: StringNullableListFilter<"FicheDePoste">
    description?: StringFilter<"FicheDePoste"> | string
    missions?: StringNullableListFilter<"FicheDePoste">
    experience?: StringNullableFilter<"FicheDePoste"> | string | null
    formation?: StringNullableFilter<"FicheDePoste"> | string | null
    remuneration?: StringNullableFilter<"FicheDePoste"> | string | null
    avantages?: StringNullableFilter<"FicheDePoste"> | string | null
    horaires?: StringNullableFilter<"FicheDePoste"> | string | null
    email?: StringNullableFilter<"FicheDePoste"> | string | null
    telephone?: StringNullableFilter<"FicheDePoste"> | string | null
    adresse?: StringNullableFilter<"FicheDePoste"> | string | null
    codePostal?: StringNullableFilter<"FicheDePoste"> | string | null
    ville?: StringNullableFilter<"FicheDePoste"> | string | null
    dateNaissance?: DateTimeNullableFilter<"FicheDePoste"> | Date | string | null
    numeroSecu?: StringNullableFilter<"FicheDePoste"> | string | null
    lieuTravail?: StringNullableFilter<"FicheDePoste"> | string | null
    dateCreation?: DateTimeFilter<"FicheDePoste"> | Date | string
    dateModification?: DateTimeFilter<"FicheDePoste"> | Date | string
    estActive?: BoolFilter<"FicheDePoste"> | boolean
    collaborateurId?: StringNullableFilter<"FicheDePoste"> | string | null
    collaborateur?: XOR<CollaborateurNullableScalarRelationFilter, CollaborateurWhereInput> | null
  }

  export type FicheDePosteOrderByWithRelationInput = {
    id?: SortOrder
    classification?: SortOrder
    poste?: SortOrder
    entreprise?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrderInput | SortOrder
    certifications?: SortOrder
    habilitations?: SortOrder
    competencesRequises?: SortOrder
    description?: SortOrder
    missions?: SortOrder
    experience?: SortOrderInput | SortOrder
    formation?: SortOrderInput | SortOrder
    remuneration?: SortOrderInput | SortOrder
    avantages?: SortOrderInput | SortOrder
    horaires?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    numeroSecu?: SortOrderInput | SortOrder
    lieuTravail?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    estActive?: SortOrder
    collaborateurId?: SortOrderInput | SortOrder
    collaborateur?: CollaborateurOrderByWithRelationInput
  }

  export type FicheDePosteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    collaborateurId?: string
    AND?: FicheDePosteWhereInput | FicheDePosteWhereInput[]
    OR?: FicheDePosteWhereInput[]
    NOT?: FicheDePosteWhereInput | FicheDePosteWhereInput[]
    classification?: StringFilter<"FicheDePoste"> | string
    poste?: StringFilter<"FicheDePoste"> | string
    entreprise?: StringFilter<"FicheDePoste"> | string
    typeContrat?: StringFilter<"FicheDePoste"> | string
    dureeContrat?: StringNullableFilter<"FicheDePoste"> | string | null
    certifications?: StringNullableListFilter<"FicheDePoste">
    habilitations?: StringNullableListFilter<"FicheDePoste">
    competencesRequises?: StringNullableListFilter<"FicheDePoste">
    description?: StringFilter<"FicheDePoste"> | string
    missions?: StringNullableListFilter<"FicheDePoste">
    experience?: StringNullableFilter<"FicheDePoste"> | string | null
    formation?: StringNullableFilter<"FicheDePoste"> | string | null
    remuneration?: StringNullableFilter<"FicheDePoste"> | string | null
    avantages?: StringNullableFilter<"FicheDePoste"> | string | null
    horaires?: StringNullableFilter<"FicheDePoste"> | string | null
    email?: StringNullableFilter<"FicheDePoste"> | string | null
    telephone?: StringNullableFilter<"FicheDePoste"> | string | null
    adresse?: StringNullableFilter<"FicheDePoste"> | string | null
    codePostal?: StringNullableFilter<"FicheDePoste"> | string | null
    ville?: StringNullableFilter<"FicheDePoste"> | string | null
    dateNaissance?: DateTimeNullableFilter<"FicheDePoste"> | Date | string | null
    numeroSecu?: StringNullableFilter<"FicheDePoste"> | string | null
    lieuTravail?: StringNullableFilter<"FicheDePoste"> | string | null
    dateCreation?: DateTimeFilter<"FicheDePoste"> | Date | string
    dateModification?: DateTimeFilter<"FicheDePoste"> | Date | string
    estActive?: BoolFilter<"FicheDePoste"> | boolean
    collaborateur?: XOR<CollaborateurNullableScalarRelationFilter, CollaborateurWhereInput> | null
  }, "id" | "collaborateurId">

  export type FicheDePosteOrderByWithAggregationInput = {
    id?: SortOrder
    classification?: SortOrder
    poste?: SortOrder
    entreprise?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrderInput | SortOrder
    certifications?: SortOrder
    habilitations?: SortOrder
    competencesRequises?: SortOrder
    description?: SortOrder
    missions?: SortOrder
    experience?: SortOrderInput | SortOrder
    formation?: SortOrderInput | SortOrder
    remuneration?: SortOrderInput | SortOrder
    avantages?: SortOrderInput | SortOrder
    horaires?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    numeroSecu?: SortOrderInput | SortOrder
    lieuTravail?: SortOrderInput | SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    estActive?: SortOrder
    collaborateurId?: SortOrderInput | SortOrder
    _count?: FicheDePosteCountOrderByAggregateInput
    _max?: FicheDePosteMaxOrderByAggregateInput
    _min?: FicheDePosteMinOrderByAggregateInput
  }

  export type FicheDePosteScalarWhereWithAggregatesInput = {
    AND?: FicheDePosteScalarWhereWithAggregatesInput | FicheDePosteScalarWhereWithAggregatesInput[]
    OR?: FicheDePosteScalarWhereWithAggregatesInput[]
    NOT?: FicheDePosteScalarWhereWithAggregatesInput | FicheDePosteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FicheDePoste"> | string
    classification?: StringWithAggregatesFilter<"FicheDePoste"> | string
    poste?: StringWithAggregatesFilter<"FicheDePoste"> | string
    entreprise?: StringWithAggregatesFilter<"FicheDePoste"> | string
    typeContrat?: StringWithAggregatesFilter<"FicheDePoste"> | string
    dureeContrat?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    certifications?: StringNullableListFilter<"FicheDePoste">
    habilitations?: StringNullableListFilter<"FicheDePoste">
    competencesRequises?: StringNullableListFilter<"FicheDePoste">
    description?: StringWithAggregatesFilter<"FicheDePoste"> | string
    missions?: StringNullableListFilter<"FicheDePoste">
    experience?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    formation?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    remuneration?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    avantages?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    horaires?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    email?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    codePostal?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    ville?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    dateNaissance?: DateTimeNullableWithAggregatesFilter<"FicheDePoste"> | Date | string | null
    numeroSecu?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    lieuTravail?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
    dateCreation?: DateTimeWithAggregatesFilter<"FicheDePoste"> | Date | string
    dateModification?: DateTimeWithAggregatesFilter<"FicheDePoste"> | Date | string
    estActive?: BoolWithAggregatesFilter<"FicheDePoste"> | boolean
    collaborateurId?: StringNullableWithAggregatesFilter<"FicheDePoste"> | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    nom?: StringFilter<"Admin"> | string
    prenom?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    telephone?: StringFilter<"Admin"> | string
    role?: EnumRoleAdminFilter<"Admin"> | $Enums.RoleAdmin
    departement?: StringFilter<"Admin"> | string
    dateCreation?: DateTimeFilter<"Admin"> | Date | string
    dernierAcces?: DateTimeFilter<"Admin"> | Date | string
    estActif?: BoolFilter<"Admin"> | boolean
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    departement?: SortOrder
    dateCreation?: SortOrder
    dernierAcces?: SortOrder
    estActif?: SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    nom?: StringFilter<"Admin"> | string
    prenom?: StringFilter<"Admin"> | string
    telephone?: StringFilter<"Admin"> | string
    role?: EnumRoleAdminFilter<"Admin"> | $Enums.RoleAdmin
    departement?: StringFilter<"Admin"> | string
    dateCreation?: DateTimeFilter<"Admin"> | Date | string
    dernierAcces?: DateTimeFilter<"Admin"> | Date | string
    estActif?: BoolFilter<"Admin"> | boolean
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    departement?: SortOrder
    dateCreation?: SortOrder
    dernierAcces?: SortOrder
    estActif?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    nom?: StringWithAggregatesFilter<"Admin"> | string
    prenom?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    telephone?: StringWithAggregatesFilter<"Admin"> | string
    role?: EnumRoleAdminWithAggregatesFilter<"Admin"> | $Enums.RoleAdmin
    departement?: StringWithAggregatesFilter<"Admin"> | string
    dateCreation?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    dernierAcces?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    estActif?: BoolWithAggregatesFilter<"Admin"> | boolean
  }

  export type CollaborateurCreateInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementCreateNestedManyWithoutCollaborateurInput
    compte?: CompteCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementUncheckedCreateNestedManyWithoutCollaborateurInput
    compte?: CompteUncheckedCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactUncheckedCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieUncheckedCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUncheckedUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUncheckedUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurCreateManyInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
  }

  export type CollaborateurUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollaborateurUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompteCreateInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    createdAt?: Date | string
    collaborateur: CollaborateurCreateNestedOneWithoutCompteInput
    collaborateursGeres?: CollaborateurCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteUncheckedCreateInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    collaborateurId: string
    createdAt?: Date | string
    collaborateursGeres?: CollaborateurUncheckedCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateur?: CollaborateurUpdateOneRequiredWithoutCompteNestedInput
    collaborateursGeres?: CollaborateurUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    collaborateurId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursGeres?: CollaborateurUncheckedUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteCreateManyInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    collaborateurId: string
    createdAt?: Date | string
  }

  export type CompteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    collaborateurId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementCreateInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    typeEvenement: string
    lieuChantier?: string | null
    zoneTrajet?: string | null
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: number
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: number
    typeAbsence?: string | null
    verrouille?: boolean
    latitude?: number | null
    longitude?: number | null
    adresseComplete?: string | null
    createdAt?: Date | string
    collaborateur: CollaborateurCreateNestedOneWithoutEvenementsInput
  }

  export type EvenementUncheckedCreateInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    collaborateurId: string
    typeEvenement: string
    lieuChantier?: string | null
    zoneTrajet?: string | null
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: number
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: number
    typeAbsence?: string | null
    verrouille?: boolean
    latitude?: number | null
    longitude?: number | null
    adresseComplete?: string | null
    createdAt?: Date | string
  }

  export type EvenementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvenement?: StringFieldUpdateOperationsInput | string
    lieuChantier?: NullableStringFieldUpdateOperationsInput | string | null
    zoneTrajet?: NullableStringFieldUpdateOperationsInput | string | null
    panierRepas?: BoolFieldUpdateOperationsInput | boolean
    ticketRestaurant?: BoolFieldUpdateOperationsInput | boolean
    heuresSupplementaires?: FloatFieldUpdateOperationsInput | number
    grandDeplacement?: BoolFieldUpdateOperationsInput | boolean
    prgd?: BoolFieldUpdateOperationsInput | boolean
    nombrePrgd?: IntFieldUpdateOperationsInput | number
    typeAbsence?: NullableStringFieldUpdateOperationsInput | string | null
    verrouille?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    adresseComplete?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateur?: CollaborateurUpdateOneRequiredWithoutEvenementsNestedInput
  }

  export type EvenementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateurId?: StringFieldUpdateOperationsInput | string
    typeEvenement?: StringFieldUpdateOperationsInput | string
    lieuChantier?: NullableStringFieldUpdateOperationsInput | string | null
    zoneTrajet?: NullableStringFieldUpdateOperationsInput | string | null
    panierRepas?: BoolFieldUpdateOperationsInput | boolean
    ticketRestaurant?: BoolFieldUpdateOperationsInput | boolean
    heuresSupplementaires?: FloatFieldUpdateOperationsInput | number
    grandDeplacement?: BoolFieldUpdateOperationsInput | boolean
    prgd?: BoolFieldUpdateOperationsInput | boolean
    nombrePrgd?: IntFieldUpdateOperationsInput | number
    typeAbsence?: NullableStringFieldUpdateOperationsInput | string | null
    verrouille?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    adresseComplete?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementCreateManyInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    collaborateurId: string
    typeEvenement: string
    lieuChantier?: string | null
    zoneTrajet?: string | null
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: number
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: number
    typeAbsence?: string | null
    verrouille?: boolean
    latitude?: number | null
    longitude?: number | null
    adresseComplete?: string | null
    createdAt?: Date | string
  }

  export type EvenementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvenement?: StringFieldUpdateOperationsInput | string
    lieuChantier?: NullableStringFieldUpdateOperationsInput | string | null
    zoneTrajet?: NullableStringFieldUpdateOperationsInput | string | null
    panierRepas?: BoolFieldUpdateOperationsInput | boolean
    ticketRestaurant?: BoolFieldUpdateOperationsInput | boolean
    heuresSupplementaires?: FloatFieldUpdateOperationsInput | number
    grandDeplacement?: BoolFieldUpdateOperationsInput | boolean
    prgd?: BoolFieldUpdateOperationsInput | boolean
    nombrePrgd?: IntFieldUpdateOperationsInput | number
    typeAbsence?: NullableStringFieldUpdateOperationsInput | string | null
    verrouille?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    adresseComplete?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateurId?: StringFieldUpdateOperationsInput | string
    typeEvenement?: StringFieldUpdateOperationsInput | string
    lieuChantier?: NullableStringFieldUpdateOperationsInput | string | null
    zoneTrajet?: NullableStringFieldUpdateOperationsInput | string | null
    panierRepas?: BoolFieldUpdateOperationsInput | boolean
    ticketRestaurant?: BoolFieldUpdateOperationsInput | boolean
    heuresSupplementaires?: FloatFieldUpdateOperationsInput | number
    grandDeplacement?: BoolFieldUpdateOperationsInput | boolean
    prgd?: BoolFieldUpdateOperationsInput | boolean
    nombrePrgd?: IntFieldUpdateOperationsInput | number
    typeAbsence?: NullableStringFieldUpdateOperationsInput | string | null
    verrouille?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    adresseComplete?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalarieCreateInput = {
    id?: string
    nom: string
    prenom: string
    classification: string
    dateEntree: Date | string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: SalarieCreatecertificationsInput | string[]
    habilitations?: SalarieCreatehabilitationsInput | string[]
    entreprise: string
    poste: string
    email: string
    telephone: string
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    createdAt?: Date | string
    collaborateur?: CollaborateurCreateNestedOneWithoutSalarieInput
  }

  export type SalarieUncheckedCreateInput = {
    id?: string
    nom: string
    prenom: string
    classification: string
    dateEntree: Date | string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: SalarieCreatecertificationsInput | string[]
    habilitations?: SalarieCreatehabilitationsInput | string[]
    entreprise: string
    poste: string
    email: string
    telephone: string
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    collaborateurId?: string | null
    createdAt?: Date | string
  }

  export type SalarieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: SalarieUpdatecertificationsInput | string[]
    habilitations?: SalarieUpdatehabilitationsInput | string[]
    entreprise?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateur?: CollaborateurUpdateOneWithoutSalarieNestedInput
  }

  export type SalarieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: SalarieUpdatecertificationsInput | string[]
    habilitations?: SalarieUpdatehabilitationsInput | string[]
    entreprise?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    collaborateurId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalarieCreateManyInput = {
    id?: string
    nom: string
    prenom: string
    classification: string
    dateEntree: Date | string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: SalarieCreatecertificationsInput | string[]
    habilitations?: SalarieCreatehabilitationsInput | string[]
    entreprise: string
    poste: string
    email: string
    telephone: string
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    collaborateurId?: string | null
    createdAt?: Date | string
  }

  export type SalarieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: SalarieUpdatecertificationsInput | string[]
    habilitations?: SalarieUpdatehabilitationsInput | string[]
    entreprise?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalarieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: SalarieUpdatecertificationsInput | string[]
    habilitations?: SalarieUpdatehabilitationsInput | string[]
    entreprise?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    collaborateurId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehiculeCreateInput = {
    id?: string
    societe: string
    marque: string
    modele: string
    immatriculation: string
    etat: string
    proprietaire: string
    dateMiseEnCirculation?: Date | string | null
    kilometrage?: number | null
    kmProchaineRevision?: number | null
    dateLimiteControleTechnique?: Date | string | null
    dateLimiteControlePollution?: Date | string | null
    typeVehicule?: string | null
    createdAt?: Date | string
  }

  export type VehiculeUncheckedCreateInput = {
    id?: string
    societe: string
    marque: string
    modele: string
    immatriculation: string
    etat: string
    proprietaire: string
    dateMiseEnCirculation?: Date | string | null
    kilometrage?: number | null
    kmProchaineRevision?: number | null
    dateLimiteControleTechnique?: Date | string | null
    dateLimiteControlePollution?: Date | string | null
    typeVehicule?: string | null
    createdAt?: Date | string
  }

  export type VehiculeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    societe?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    immatriculation?: StringFieldUpdateOperationsInput | string
    etat?: StringFieldUpdateOperationsInput | string
    proprietaire?: StringFieldUpdateOperationsInput | string
    dateMiseEnCirculation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrage?: NullableIntFieldUpdateOperationsInput | number | null
    kmProchaineRevision?: NullableIntFieldUpdateOperationsInput | number | null
    dateLimiteControleTechnique?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateLimiteControlePollution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVehicule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehiculeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    societe?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    immatriculation?: StringFieldUpdateOperationsInput | string
    etat?: StringFieldUpdateOperationsInput | string
    proprietaire?: StringFieldUpdateOperationsInput | string
    dateMiseEnCirculation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrage?: NullableIntFieldUpdateOperationsInput | number | null
    kmProchaineRevision?: NullableIntFieldUpdateOperationsInput | number | null
    dateLimiteControleTechnique?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateLimiteControlePollution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVehicule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehiculeCreateManyInput = {
    id?: string
    societe: string
    marque: string
    modele: string
    immatriculation: string
    etat: string
    proprietaire: string
    dateMiseEnCirculation?: Date | string | null
    kilometrage?: number | null
    kmProchaineRevision?: number | null
    dateLimiteControleTechnique?: Date | string | null
    dateLimiteControlePollution?: Date | string | null
    typeVehicule?: string | null
    createdAt?: Date | string
  }

  export type VehiculeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    societe?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    immatriculation?: StringFieldUpdateOperationsInput | string
    etat?: StringFieldUpdateOperationsInput | string
    proprietaire?: StringFieldUpdateOperationsInput | string
    dateMiseEnCirculation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrage?: NullableIntFieldUpdateOperationsInput | number | null
    kmProchaineRevision?: NullableIntFieldUpdateOperationsInput | number | null
    dateLimiteControleTechnique?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateLimiteControlePollution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVehicule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehiculeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    societe?: StringFieldUpdateOperationsInput | string
    marque?: StringFieldUpdateOperationsInput | string
    modele?: StringFieldUpdateOperationsInput | string
    immatriculation?: StringFieldUpdateOperationsInput | string
    etat?: StringFieldUpdateOperationsInput | string
    proprietaire?: StringFieldUpdateOperationsInput | string
    dateMiseEnCirculation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrage?: NullableIntFieldUpdateOperationsInput | number | null
    kmProchaineRevision?: NullableIntFieldUpdateOperationsInput | number | null
    dateLimiteControleTechnique?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateLimiteControlePollution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVehicule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
    utilisateur: CompteCreateNestedOneWithoutContactsInput
    collaborateurs?: CollaborateurCreateNestedManyWithoutContactsGeresInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    utilisateurId: string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
    collaborateurs?: CollaborateurUncheckedCreateNestedManyWithoutContactsGeresInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utilisateur?: CompteUpdateOneRequiredWithoutContactsNestedInput
    collaborateurs?: CollaborateurUpdateManyWithoutContactsGeresNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborateurs?: CollaborateurUncheckedUpdateManyWithoutContactsGeresNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    utilisateurId: string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DemandeCongeCreateInput = {
    id?: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
    utilisateur: CompteCreateNestedOneWithoutDemandesCongesInput
    collaborateur: CollaborateurCreateNestedOneWithoutDemandesCongesInput
    notifications?: NotificationCreateNestedManyWithoutDemandeCongeInput
  }

  export type DemandeCongeUncheckedCreateInput = {
    id?: string
    utilisateurId: string
    collaborateurId: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
    notifications?: NotificationUncheckedCreateNestedManyWithoutDemandeCongeInput
  }

  export type DemandeCongeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
    utilisateur?: CompteUpdateOneRequiredWithoutDemandesCongesNestedInput
    collaborateur?: CollaborateurUpdateOneRequiredWithoutDemandesCongesNestedInput
    notifications?: NotificationUpdateManyWithoutDemandeCongeNestedInput
  }

  export type DemandeCongeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateurId?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationUncheckedUpdateManyWithoutDemandeCongeNestedInput
  }

  export type DemandeCongeCreateManyInput = {
    id?: string
    utilisateurId: string
    collaborateurId: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
  }

  export type DemandeCongeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DemandeCongeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateurId?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
    utilisateur: CompteCreateNestedOneWithoutNotificationsInput
    demandeConge?: DemandeCongeCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    utilisateurId: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
    demandeId?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    utilisateur?: CompteUpdateOneRequiredWithoutNotificationsNestedInput
    demandeConge?: DemandeCongeUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    demandeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    utilisateurId: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
    demandeId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    demandeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContratMaintenanceCreateInput = {
    id?: string
    client: string
    reference: string
    type: string
    montant: number
    dateDebut: Date | string
    dateEcheance: Date | string
    statut: string
    description: string
    contactClient: string
    emailContact: string
    telephoneContact: string
    notes?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
  }

  export type ContratMaintenanceUncheckedCreateInput = {
    id?: string
    client: string
    reference: string
    type: string
    montant: number
    dateDebut: Date | string
    dateEcheance: Date | string
    statut: string
    description: string
    contactClient: string
    emailContact: string
    telephoneContact: string
    notes?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
  }

  export type ContratMaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contactClient?: StringFieldUpdateOperationsInput | string
    emailContact?: StringFieldUpdateOperationsInput | string
    telephoneContact?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContratMaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contactClient?: StringFieldUpdateOperationsInput | string
    emailContact?: StringFieldUpdateOperationsInput | string
    telephoneContact?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContratMaintenanceCreateManyInput = {
    id?: string
    client: string
    reference: string
    type: string
    montant: number
    dateDebut: Date | string
    dateEcheance: Date | string
    statut: string
    description: string
    contactClient: string
    emailContact: string
    telephoneContact: string
    notes?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
  }

  export type ContratMaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contactClient?: StringFieldUpdateOperationsInput | string
    emailContact?: StringFieldUpdateOperationsInput | string
    telephoneContact?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContratMaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    montant?: FloatFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contactClient?: StringFieldUpdateOperationsInput | string
    emailContact?: StringFieldUpdateOperationsInput | string
    telephoneContact?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemCreateInput = {
    id?: string
    cableType: string
    typeM: string
    typeG: string
    enroulement: string
    longueur: number
    createdAt?: Date | string
  }

  export type StockItemUncheckedCreateInput = {
    id?: string
    cableType: string
    typeM: string
    typeG: string
    enroulement: string
    longueur: number
    createdAt?: Date | string
  }

  export type StockItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cableType?: StringFieldUpdateOperationsInput | string
    typeM?: StringFieldUpdateOperationsInput | string
    typeG?: StringFieldUpdateOperationsInput | string
    enroulement?: StringFieldUpdateOperationsInput | string
    longueur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cableType?: StringFieldUpdateOperationsInput | string
    typeM?: StringFieldUpdateOperationsInput | string
    typeG?: StringFieldUpdateOperationsInput | string
    enroulement?: StringFieldUpdateOperationsInput | string
    longueur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemCreateManyInput = {
    id?: string
    cableType: string
    typeM: string
    typeG: string
    enroulement: string
    longueur: number
    createdAt?: Date | string
  }

  export type StockItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cableType?: StringFieldUpdateOperationsInput | string
    typeM?: StringFieldUpdateOperationsInput | string
    typeG?: StringFieldUpdateOperationsInput | string
    enroulement?: StringFieldUpdateOperationsInput | string
    longueur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cableType?: StringFieldUpdateOperationsInput | string
    typeM?: StringFieldUpdateOperationsInput | string
    typeG?: StringFieldUpdateOperationsInput | string
    enroulement?: StringFieldUpdateOperationsInput | string
    longueur?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FicheDePosteCreateInput = {
    id?: string
    classification: string
    poste: string
    entreprise: string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: FicheDePosteCreatecertificationsInput | string[]
    habilitations?: FicheDePosteCreatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteCreatecompetencesRequisesInput | string[]
    description: string
    missions?: FicheDePosteCreatemissionsInput | string[]
    experience?: string | null
    formation?: string | null
    remuneration?: string | null
    avantages?: string | null
    horaires?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    lieuTravail?: string | null
    dateCreation?: Date | string
    dateModification?: Date | string
    estActive?: boolean
    collaborateur?: CollaborateurCreateNestedOneWithoutFicheDePosteInput
  }

  export type FicheDePosteUncheckedCreateInput = {
    id?: string
    classification: string
    poste: string
    entreprise: string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: FicheDePosteCreatecertificationsInput | string[]
    habilitations?: FicheDePosteCreatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteCreatecompetencesRequisesInput | string[]
    description: string
    missions?: FicheDePosteCreatemissionsInput | string[]
    experience?: string | null
    formation?: string | null
    remuneration?: string | null
    avantages?: string | null
    horaires?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    lieuTravail?: string | null
    dateCreation?: Date | string
    dateModification?: Date | string
    estActive?: boolean
    collaborateurId?: string | null
  }

  export type FicheDePosteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: FicheDePosteUpdatecertificationsInput | string[]
    habilitations?: FicheDePosteUpdatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteUpdatecompetencesRequisesInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    missions?: FicheDePosteUpdatemissionsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    remuneration?: NullableStringFieldUpdateOperationsInput | string | null
    avantages?: NullableStringFieldUpdateOperationsInput | string | null
    horaires?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    lieuTravail?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    collaborateur?: CollaborateurUpdateOneWithoutFicheDePosteNestedInput
  }

  export type FicheDePosteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: FicheDePosteUpdatecertificationsInput | string[]
    habilitations?: FicheDePosteUpdatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteUpdatecompetencesRequisesInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    missions?: FicheDePosteUpdatemissionsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    remuneration?: NullableStringFieldUpdateOperationsInput | string | null
    avantages?: NullableStringFieldUpdateOperationsInput | string | null
    horaires?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    lieuTravail?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    collaborateurId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FicheDePosteCreateManyInput = {
    id?: string
    classification: string
    poste: string
    entreprise: string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: FicheDePosteCreatecertificationsInput | string[]
    habilitations?: FicheDePosteCreatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteCreatecompetencesRequisesInput | string[]
    description: string
    missions?: FicheDePosteCreatemissionsInput | string[]
    experience?: string | null
    formation?: string | null
    remuneration?: string | null
    avantages?: string | null
    horaires?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    lieuTravail?: string | null
    dateCreation?: Date | string
    dateModification?: Date | string
    estActive?: boolean
    collaborateurId?: string | null
  }

  export type FicheDePosteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: FicheDePosteUpdatecertificationsInput | string[]
    habilitations?: FicheDePosteUpdatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteUpdatecompetencesRequisesInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    missions?: FicheDePosteUpdatemissionsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    remuneration?: NullableStringFieldUpdateOperationsInput | string | null
    avantages?: NullableStringFieldUpdateOperationsInput | string | null
    horaires?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    lieuTravail?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FicheDePosteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: FicheDePosteUpdatecertificationsInput | string[]
    habilitations?: FicheDePosteUpdatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteUpdatecompetencesRequisesInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    missions?: FicheDePosteUpdatemissionsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    remuneration?: NullableStringFieldUpdateOperationsInput | string | null
    avantages?: NullableStringFieldUpdateOperationsInput | string | null
    horaires?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    lieuTravail?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    collaborateurId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    role: $Enums.RoleAdmin
    departement: string
    dateCreation?: Date | string
    dernierAcces?: Date | string
    estActif?: boolean
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    role: $Enums.RoleAdmin
    departement: string
    dateCreation?: Date | string
    dernierAcces?: Date | string
    estActif?: boolean
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAdminFieldUpdateOperationsInput | $Enums.RoleAdmin
    departement?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dernierAcces?: DateTimeFieldUpdateOperationsInput | Date | string
    estActif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAdminFieldUpdateOperationsInput | $Enums.RoleAdmin
    departement?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dernierAcces?: DateTimeFieldUpdateOperationsInput | Date | string
    estActif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminCreateManyInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    role: $Enums.RoleAdmin
    departement: string
    dateCreation?: Date | string
    dernierAcces?: Date | string
    estActif?: boolean
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAdminFieldUpdateOperationsInput | $Enums.RoleAdmin
    departement?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dernierAcces?: DateTimeFieldUpdateOperationsInput | Date | string
    estActif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAdminFieldUpdateOperationsInput | $Enums.RoleAdmin
    departement?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dernierAcces?: DateTimeFieldUpdateOperationsInput | Date | string
    estActif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EvenementListRelationFilter = {
    every?: EvenementWhereInput
    some?: EvenementWhereInput
    none?: EvenementWhereInput
  }

  export type CompteNullableScalarRelationFilter = {
    is?: CompteWhereInput | null
    isNot?: CompteWhereInput | null
  }

  export type CompteListRelationFilter = {
    every?: CompteWhereInput
    some?: CompteWhereInput
    none?: CompteWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type DemandeCongeListRelationFilter = {
    every?: DemandeCongeWhereInput
    some?: DemandeCongeWhereInput
    none?: DemandeCongeWhereInput
  }

  export type SalarieNullableScalarRelationFilter = {
    is?: SalarieWhereInput | null
    isNot?: SalarieWhereInput | null
  }

  export type FicheDePosteNullableScalarRelationFilter = {
    is?: FicheDePosteWhereInput | null
    isNot?: FicheDePosteWhereInput | null
  }

  export type EvenementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DemandeCongeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollaborateurCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    couleur?: SortOrder
    entreprise?: SortOrder
    aCompte?: SortOrder
    createdAt?: SortOrder
  }

  export type CollaborateurMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    couleur?: SortOrder
    entreprise?: SortOrder
    aCompte?: SortOrder
    createdAt?: SortOrder
  }

  export type CollaborateurMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    couleur?: SortOrder
    entreprise?: SortOrder
    aCompte?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type CollaborateurScalarRelationFilter = {
    is?: CollaborateurWhereInput
    isNot?: CollaborateurWhereInput
  }

  export type CollaborateurListRelationFilter = {
    every?: CollaborateurWhereInput
    some?: CollaborateurWhereInput
    none?: CollaborateurWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CollaborateurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompteCountOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    motDePasse?: SortOrder
    role?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompteMaxOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    motDePasse?: SortOrder
    role?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompteMinOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    motDePasse?: SortOrder
    role?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EvenementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    collaborateurId?: SortOrder
    typeEvenement?: SortOrder
    lieuChantier?: SortOrder
    zoneTrajet?: SortOrder
    panierRepas?: SortOrder
    ticketRestaurant?: SortOrder
    heuresSupplementaires?: SortOrder
    grandDeplacement?: SortOrder
    prgd?: SortOrder
    nombrePrgd?: SortOrder
    typeAbsence?: SortOrder
    verrouille?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    adresseComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type EvenementAvgOrderByAggregateInput = {
    heuresSupplementaires?: SortOrder
    nombrePrgd?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EvenementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    collaborateurId?: SortOrder
    typeEvenement?: SortOrder
    lieuChantier?: SortOrder
    zoneTrajet?: SortOrder
    panierRepas?: SortOrder
    ticketRestaurant?: SortOrder
    heuresSupplementaires?: SortOrder
    grandDeplacement?: SortOrder
    prgd?: SortOrder
    nombrePrgd?: SortOrder
    typeAbsence?: SortOrder
    verrouille?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    adresseComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type EvenementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    collaborateurId?: SortOrder
    typeEvenement?: SortOrder
    lieuChantier?: SortOrder
    zoneTrajet?: SortOrder
    panierRepas?: SortOrder
    ticketRestaurant?: SortOrder
    heuresSupplementaires?: SortOrder
    grandDeplacement?: SortOrder
    prgd?: SortOrder
    nombrePrgd?: SortOrder
    typeAbsence?: SortOrder
    verrouille?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    adresseComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type EvenementSumOrderByAggregateInput = {
    heuresSupplementaires?: SortOrder
    nombrePrgd?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CollaborateurNullableScalarRelationFilter = {
    is?: CollaborateurWhereInput | null
    isNot?: CollaborateurWhereInput | null
  }

  export type SalarieCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    classification?: SortOrder
    dateEntree?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrder
    certifications?: SortOrder
    habilitations?: SortOrder
    entreprise?: SortOrder
    poste?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    dateNaissance?: SortOrder
    numeroSecu?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
  }

  export type SalarieMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    classification?: SortOrder
    dateEntree?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrder
    entreprise?: SortOrder
    poste?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    dateNaissance?: SortOrder
    numeroSecu?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
  }

  export type SalarieMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    classification?: SortOrder
    dateEntree?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrder
    entreprise?: SortOrder
    poste?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    dateNaissance?: SortOrder
    numeroSecu?: SortOrder
    collaborateurId?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VehiculeCountOrderByAggregateInput = {
    id?: SortOrder
    societe?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    immatriculation?: SortOrder
    etat?: SortOrder
    proprietaire?: SortOrder
    dateMiseEnCirculation?: SortOrder
    kilometrage?: SortOrder
    kmProchaineRevision?: SortOrder
    dateLimiteControleTechnique?: SortOrder
    dateLimiteControlePollution?: SortOrder
    typeVehicule?: SortOrder
    createdAt?: SortOrder
  }

  export type VehiculeAvgOrderByAggregateInput = {
    kilometrage?: SortOrder
    kmProchaineRevision?: SortOrder
  }

  export type VehiculeMaxOrderByAggregateInput = {
    id?: SortOrder
    societe?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    immatriculation?: SortOrder
    etat?: SortOrder
    proprietaire?: SortOrder
    dateMiseEnCirculation?: SortOrder
    kilometrage?: SortOrder
    kmProchaineRevision?: SortOrder
    dateLimiteControleTechnique?: SortOrder
    dateLimiteControlePollution?: SortOrder
    typeVehicule?: SortOrder
    createdAt?: SortOrder
  }

  export type VehiculeMinOrderByAggregateInput = {
    id?: SortOrder
    societe?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    immatriculation?: SortOrder
    etat?: SortOrder
    proprietaire?: SortOrder
    dateMiseEnCirculation?: SortOrder
    kilometrage?: SortOrder
    kmProchaineRevision?: SortOrder
    dateLimiteControleTechnique?: SortOrder
    dateLimiteControlePollution?: SortOrder
    typeVehicule?: SortOrder
    createdAt?: SortOrder
  }

  export type VehiculeSumOrderByAggregateInput = {
    kilometrage?: SortOrder
    kmProchaineRevision?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CompteScalarRelationFilter = {
    is?: CompteWhereInput
    isNot?: CompteWhereInput
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    categories?: SortOrder
    status?: SortOrder
    commentaires?: SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
    utilisateurId?: SortOrder
    collaborateursIds?: SortOrder
    montantDevis?: SortOrder
    archived?: SortOrder
    archiveDate?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    montantDevis?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    status?: SortOrder
    commentaires?: SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
    utilisateurId?: SortOrder
    montantDevis?: SortOrder
    archived?: SortOrder
    archiveDate?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    status?: SortOrder
    commentaires?: SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
    utilisateurId?: SortOrder
    montantDevis?: SortOrder
    archived?: SortOrder
    archiveDate?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    montantDevis?: SortOrder
  }

  export type DemandeCongeCountOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    collaborateurId?: SortOrder
    collaborateurNom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    typeConge?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    commentaireAdmin?: SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    notificationLue?: SortOrder
  }

  export type DemandeCongeMaxOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    collaborateurId?: SortOrder
    collaborateurNom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    typeConge?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    commentaireAdmin?: SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    notificationLue?: SortOrder
  }

  export type DemandeCongeMinOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    collaborateurId?: SortOrder
    collaborateurNom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    typeConge?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    commentaireAdmin?: SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    notificationLue?: SortOrder
  }

  export type DemandeCongeNullableScalarRelationFilter = {
    is?: DemandeCongeWhereInput | null
    isNot?: DemandeCongeWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    message?: SortOrder
    lien?: SortOrder
    dateCreation?: SortOrder
    lue?: SortOrder
    type?: SortOrder
    demandeId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    message?: SortOrder
    lien?: SortOrder
    dateCreation?: SortOrder
    lue?: SortOrder
    type?: SortOrder
    demandeId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    message?: SortOrder
    lien?: SortOrder
    dateCreation?: SortOrder
    lue?: SortOrder
    type?: SortOrder
    demandeId?: SortOrder
  }

  export type ContratMaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    client?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateDebut?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    description?: SortOrder
    contactClient?: SortOrder
    emailContact?: SortOrder
    telephoneContact?: SortOrder
    notes?: SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
  }

  export type ContratMaintenanceAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type ContratMaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    client?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateDebut?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    description?: SortOrder
    contactClient?: SortOrder
    emailContact?: SortOrder
    telephoneContact?: SortOrder
    notes?: SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
  }

  export type ContratMaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    client?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    montant?: SortOrder
    dateDebut?: SortOrder
    dateEcheance?: SortOrder
    statut?: SortOrder
    description?: SortOrder
    contactClient?: SortOrder
    emailContact?: SortOrder
    telephoneContact?: SortOrder
    notes?: SortOrder
    dateCreation?: SortOrder
    dateDerniereModification?: SortOrder
  }

  export type ContratMaintenanceSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type StockItemCountOrderByAggregateInput = {
    id?: SortOrder
    cableType?: SortOrder
    typeM?: SortOrder
    typeG?: SortOrder
    enroulement?: SortOrder
    longueur?: SortOrder
    createdAt?: SortOrder
  }

  export type StockItemAvgOrderByAggregateInput = {
    longueur?: SortOrder
  }

  export type StockItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cableType?: SortOrder
    typeM?: SortOrder
    typeG?: SortOrder
    enroulement?: SortOrder
    longueur?: SortOrder
    createdAt?: SortOrder
  }

  export type StockItemMinOrderByAggregateInput = {
    id?: SortOrder
    cableType?: SortOrder
    typeM?: SortOrder
    typeG?: SortOrder
    enroulement?: SortOrder
    longueur?: SortOrder
    createdAt?: SortOrder
  }

  export type StockItemSumOrderByAggregateInput = {
    longueur?: SortOrder
  }

  export type FicheDePosteCountOrderByAggregateInput = {
    id?: SortOrder
    classification?: SortOrder
    poste?: SortOrder
    entreprise?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrder
    certifications?: SortOrder
    habilitations?: SortOrder
    competencesRequises?: SortOrder
    description?: SortOrder
    missions?: SortOrder
    experience?: SortOrder
    formation?: SortOrder
    remuneration?: SortOrder
    avantages?: SortOrder
    horaires?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    dateNaissance?: SortOrder
    numeroSecu?: SortOrder
    lieuTravail?: SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    estActive?: SortOrder
    collaborateurId?: SortOrder
  }

  export type FicheDePosteMaxOrderByAggregateInput = {
    id?: SortOrder
    classification?: SortOrder
    poste?: SortOrder
    entreprise?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    formation?: SortOrder
    remuneration?: SortOrder
    avantages?: SortOrder
    horaires?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    dateNaissance?: SortOrder
    numeroSecu?: SortOrder
    lieuTravail?: SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    estActive?: SortOrder
    collaborateurId?: SortOrder
  }

  export type FicheDePosteMinOrderByAggregateInput = {
    id?: SortOrder
    classification?: SortOrder
    poste?: SortOrder
    entreprise?: SortOrder
    typeContrat?: SortOrder
    dureeContrat?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    formation?: SortOrder
    remuneration?: SortOrder
    avantages?: SortOrder
    horaires?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    codePostal?: SortOrder
    ville?: SortOrder
    dateNaissance?: SortOrder
    numeroSecu?: SortOrder
    lieuTravail?: SortOrder
    dateCreation?: SortOrder
    dateModification?: SortOrder
    estActive?: SortOrder
    collaborateurId?: SortOrder
  }

  export type EnumRoleAdminFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAdmin | EnumRoleAdminFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAdminFilter<$PrismaModel> | $Enums.RoleAdmin
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    departement?: SortOrder
    dateCreation?: SortOrder
    dernierAcces?: SortOrder
    estActif?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    departement?: SortOrder
    dateCreation?: SortOrder
    dernierAcces?: SortOrder
    estActif?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    role?: SortOrder
    departement?: SortOrder
    dateCreation?: SortOrder
    dernierAcces?: SortOrder
    estActif?: SortOrder
  }

  export type EnumRoleAdminWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAdmin | EnumRoleAdminFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAdminWithAggregatesFilter<$PrismaModel> | $Enums.RoleAdmin
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleAdminFilter<$PrismaModel>
    _max?: NestedEnumRoleAdminFilter<$PrismaModel>
  }

  export type EvenementCreateNestedManyWithoutCollaborateurInput = {
    create?: XOR<EvenementCreateWithoutCollaborateurInput, EvenementUncheckedCreateWithoutCollaborateurInput> | EvenementCreateWithoutCollaborateurInput[] | EvenementUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCollaborateurInput | EvenementCreateOrConnectWithoutCollaborateurInput[]
    createMany?: EvenementCreateManyCollaborateurInputEnvelope
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
  }

  export type CompteCreateNestedOneWithoutCollaborateurInput = {
    create?: XOR<CompteCreateWithoutCollaborateurInput, CompteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateurInput
    connect?: CompteWhereUniqueInput
  }

  export type CompteCreateNestedManyWithoutCollaborateursGeresInput = {
    create?: XOR<CompteCreateWithoutCollaborateursGeresInput, CompteUncheckedCreateWithoutCollaborateursGeresInput> | CompteCreateWithoutCollaborateursGeresInput[] | CompteUncheckedCreateWithoutCollaborateursGeresInput[]
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateursGeresInput | CompteCreateOrConnectWithoutCollaborateursGeresInput[]
    connect?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCollaborateursInput = {
    create?: XOR<ContactCreateWithoutCollaborateursInput, ContactUncheckedCreateWithoutCollaborateursInput> | ContactCreateWithoutCollaborateursInput[] | ContactUncheckedCreateWithoutCollaborateursInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCollaborateursInput | ContactCreateOrConnectWithoutCollaborateursInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DemandeCongeCreateNestedManyWithoutCollaborateurInput = {
    create?: XOR<DemandeCongeCreateWithoutCollaborateurInput, DemandeCongeUncheckedCreateWithoutCollaborateurInput> | DemandeCongeCreateWithoutCollaborateurInput[] | DemandeCongeUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutCollaborateurInput | DemandeCongeCreateOrConnectWithoutCollaborateurInput[]
    createMany?: DemandeCongeCreateManyCollaborateurInputEnvelope
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
  }

  export type SalarieCreateNestedOneWithoutCollaborateurInput = {
    create?: XOR<SalarieCreateWithoutCollaborateurInput, SalarieUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: SalarieCreateOrConnectWithoutCollaborateurInput
    connect?: SalarieWhereUniqueInput
  }

  export type FicheDePosteCreateNestedOneWithoutCollaborateurInput = {
    create?: XOR<FicheDePosteCreateWithoutCollaborateurInput, FicheDePosteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: FicheDePosteCreateOrConnectWithoutCollaborateurInput
    connect?: FicheDePosteWhereUniqueInput
  }

  export type EvenementUncheckedCreateNestedManyWithoutCollaborateurInput = {
    create?: XOR<EvenementCreateWithoutCollaborateurInput, EvenementUncheckedCreateWithoutCollaborateurInput> | EvenementCreateWithoutCollaborateurInput[] | EvenementUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCollaborateurInput | EvenementCreateOrConnectWithoutCollaborateurInput[]
    createMany?: EvenementCreateManyCollaborateurInputEnvelope
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
  }

  export type CompteUncheckedCreateNestedOneWithoutCollaborateurInput = {
    create?: XOR<CompteCreateWithoutCollaborateurInput, CompteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateurInput
    connect?: CompteWhereUniqueInput
  }

  export type CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput = {
    create?: XOR<CompteCreateWithoutCollaborateursGeresInput, CompteUncheckedCreateWithoutCollaborateursGeresInput> | CompteCreateWithoutCollaborateursGeresInput[] | CompteUncheckedCreateWithoutCollaborateursGeresInput[]
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateursGeresInput | CompteCreateOrConnectWithoutCollaborateursGeresInput[]
    connect?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCollaborateursInput = {
    create?: XOR<ContactCreateWithoutCollaborateursInput, ContactUncheckedCreateWithoutCollaborateursInput> | ContactCreateWithoutCollaborateursInput[] | ContactUncheckedCreateWithoutCollaborateursInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCollaborateursInput | ContactCreateOrConnectWithoutCollaborateursInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput = {
    create?: XOR<DemandeCongeCreateWithoutCollaborateurInput, DemandeCongeUncheckedCreateWithoutCollaborateurInput> | DemandeCongeCreateWithoutCollaborateurInput[] | DemandeCongeUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutCollaborateurInput | DemandeCongeCreateOrConnectWithoutCollaborateurInput[]
    createMany?: DemandeCongeCreateManyCollaborateurInputEnvelope
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
  }

  export type SalarieUncheckedCreateNestedOneWithoutCollaborateurInput = {
    create?: XOR<SalarieCreateWithoutCollaborateurInput, SalarieUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: SalarieCreateOrConnectWithoutCollaborateurInput
    connect?: SalarieWhereUniqueInput
  }

  export type FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput = {
    create?: XOR<FicheDePosteCreateWithoutCollaborateurInput, FicheDePosteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: FicheDePosteCreateOrConnectWithoutCollaborateurInput
    connect?: FicheDePosteWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EvenementUpdateManyWithoutCollaborateurNestedInput = {
    create?: XOR<EvenementCreateWithoutCollaborateurInput, EvenementUncheckedCreateWithoutCollaborateurInput> | EvenementCreateWithoutCollaborateurInput[] | EvenementUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCollaborateurInput | EvenementCreateOrConnectWithoutCollaborateurInput[]
    upsert?: EvenementUpsertWithWhereUniqueWithoutCollaborateurInput | EvenementUpsertWithWhereUniqueWithoutCollaborateurInput[]
    createMany?: EvenementCreateManyCollaborateurInputEnvelope
    set?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    disconnect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    delete?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    update?: EvenementUpdateWithWhereUniqueWithoutCollaborateurInput | EvenementUpdateWithWhereUniqueWithoutCollaborateurInput[]
    updateMany?: EvenementUpdateManyWithWhereWithoutCollaborateurInput | EvenementUpdateManyWithWhereWithoutCollaborateurInput[]
    deleteMany?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
  }

  export type CompteUpdateOneWithoutCollaborateurNestedInput = {
    create?: XOR<CompteCreateWithoutCollaborateurInput, CompteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateurInput
    upsert?: CompteUpsertWithoutCollaborateurInput
    disconnect?: CompteWhereInput | boolean
    delete?: CompteWhereInput | boolean
    connect?: CompteWhereUniqueInput
    update?: XOR<XOR<CompteUpdateToOneWithWhereWithoutCollaborateurInput, CompteUpdateWithoutCollaborateurInput>, CompteUncheckedUpdateWithoutCollaborateurInput>
  }

  export type CompteUpdateManyWithoutCollaborateursGeresNestedInput = {
    create?: XOR<CompteCreateWithoutCollaborateursGeresInput, CompteUncheckedCreateWithoutCollaborateursGeresInput> | CompteCreateWithoutCollaborateursGeresInput[] | CompteUncheckedCreateWithoutCollaborateursGeresInput[]
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateursGeresInput | CompteCreateOrConnectWithoutCollaborateursGeresInput[]
    upsert?: CompteUpsertWithWhereUniqueWithoutCollaborateursGeresInput | CompteUpsertWithWhereUniqueWithoutCollaborateursGeresInput[]
    set?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    disconnect?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    delete?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    connect?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    update?: CompteUpdateWithWhereUniqueWithoutCollaborateursGeresInput | CompteUpdateWithWhereUniqueWithoutCollaborateursGeresInput[]
    updateMany?: CompteUpdateManyWithWhereWithoutCollaborateursGeresInput | CompteUpdateManyWithWhereWithoutCollaborateursGeresInput[]
    deleteMany?: CompteScalarWhereInput | CompteScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCollaborateursNestedInput = {
    create?: XOR<ContactCreateWithoutCollaborateursInput, ContactUncheckedCreateWithoutCollaborateursInput> | ContactCreateWithoutCollaborateursInput[] | ContactUncheckedCreateWithoutCollaborateursInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCollaborateursInput | ContactCreateOrConnectWithoutCollaborateursInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCollaborateursInput | ContactUpsertWithWhereUniqueWithoutCollaborateursInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCollaborateursInput | ContactUpdateWithWhereUniqueWithoutCollaborateursInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCollaborateursInput | ContactUpdateManyWithWhereWithoutCollaborateursInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DemandeCongeUpdateManyWithoutCollaborateurNestedInput = {
    create?: XOR<DemandeCongeCreateWithoutCollaborateurInput, DemandeCongeUncheckedCreateWithoutCollaborateurInput> | DemandeCongeCreateWithoutCollaborateurInput[] | DemandeCongeUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutCollaborateurInput | DemandeCongeCreateOrConnectWithoutCollaborateurInput[]
    upsert?: DemandeCongeUpsertWithWhereUniqueWithoutCollaborateurInput | DemandeCongeUpsertWithWhereUniqueWithoutCollaborateurInput[]
    createMany?: DemandeCongeCreateManyCollaborateurInputEnvelope
    set?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    disconnect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    delete?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    update?: DemandeCongeUpdateWithWhereUniqueWithoutCollaborateurInput | DemandeCongeUpdateWithWhereUniqueWithoutCollaborateurInput[]
    updateMany?: DemandeCongeUpdateManyWithWhereWithoutCollaborateurInput | DemandeCongeUpdateManyWithWhereWithoutCollaborateurInput[]
    deleteMany?: DemandeCongeScalarWhereInput | DemandeCongeScalarWhereInput[]
  }

  export type SalarieUpdateOneWithoutCollaborateurNestedInput = {
    create?: XOR<SalarieCreateWithoutCollaborateurInput, SalarieUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: SalarieCreateOrConnectWithoutCollaborateurInput
    upsert?: SalarieUpsertWithoutCollaborateurInput
    disconnect?: SalarieWhereInput | boolean
    delete?: SalarieWhereInput | boolean
    connect?: SalarieWhereUniqueInput
    update?: XOR<XOR<SalarieUpdateToOneWithWhereWithoutCollaborateurInput, SalarieUpdateWithoutCollaborateurInput>, SalarieUncheckedUpdateWithoutCollaborateurInput>
  }

  export type FicheDePosteUpdateOneWithoutCollaborateurNestedInput = {
    create?: XOR<FicheDePosteCreateWithoutCollaborateurInput, FicheDePosteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: FicheDePosteCreateOrConnectWithoutCollaborateurInput
    upsert?: FicheDePosteUpsertWithoutCollaborateurInput
    disconnect?: FicheDePosteWhereInput | boolean
    delete?: FicheDePosteWhereInput | boolean
    connect?: FicheDePosteWhereUniqueInput
    update?: XOR<XOR<FicheDePosteUpdateToOneWithWhereWithoutCollaborateurInput, FicheDePosteUpdateWithoutCollaborateurInput>, FicheDePosteUncheckedUpdateWithoutCollaborateurInput>
  }

  export type EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput = {
    create?: XOR<EvenementCreateWithoutCollaborateurInput, EvenementUncheckedCreateWithoutCollaborateurInput> | EvenementCreateWithoutCollaborateurInput[] | EvenementUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCollaborateurInput | EvenementCreateOrConnectWithoutCollaborateurInput[]
    upsert?: EvenementUpsertWithWhereUniqueWithoutCollaborateurInput | EvenementUpsertWithWhereUniqueWithoutCollaborateurInput[]
    createMany?: EvenementCreateManyCollaborateurInputEnvelope
    set?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    disconnect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    delete?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    update?: EvenementUpdateWithWhereUniqueWithoutCollaborateurInput | EvenementUpdateWithWhereUniqueWithoutCollaborateurInput[]
    updateMany?: EvenementUpdateManyWithWhereWithoutCollaborateurInput | EvenementUpdateManyWithWhereWithoutCollaborateurInput[]
    deleteMany?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
  }

  export type CompteUncheckedUpdateOneWithoutCollaborateurNestedInput = {
    create?: XOR<CompteCreateWithoutCollaborateurInput, CompteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateurInput
    upsert?: CompteUpsertWithoutCollaborateurInput
    disconnect?: CompteWhereInput | boolean
    delete?: CompteWhereInput | boolean
    connect?: CompteWhereUniqueInput
    update?: XOR<XOR<CompteUpdateToOneWithWhereWithoutCollaborateurInput, CompteUpdateWithoutCollaborateurInput>, CompteUncheckedUpdateWithoutCollaborateurInput>
  }

  export type CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput = {
    create?: XOR<CompteCreateWithoutCollaborateursGeresInput, CompteUncheckedCreateWithoutCollaborateursGeresInput> | CompteCreateWithoutCollaborateursGeresInput[] | CompteUncheckedCreateWithoutCollaborateursGeresInput[]
    connectOrCreate?: CompteCreateOrConnectWithoutCollaborateursGeresInput | CompteCreateOrConnectWithoutCollaborateursGeresInput[]
    upsert?: CompteUpsertWithWhereUniqueWithoutCollaborateursGeresInput | CompteUpsertWithWhereUniqueWithoutCollaborateursGeresInput[]
    set?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    disconnect?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    delete?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    connect?: CompteWhereUniqueInput | CompteWhereUniqueInput[]
    update?: CompteUpdateWithWhereUniqueWithoutCollaborateursGeresInput | CompteUpdateWithWhereUniqueWithoutCollaborateursGeresInput[]
    updateMany?: CompteUpdateManyWithWhereWithoutCollaborateursGeresInput | CompteUpdateManyWithWhereWithoutCollaborateursGeresInput[]
    deleteMany?: CompteScalarWhereInput | CompteScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCollaborateursNestedInput = {
    create?: XOR<ContactCreateWithoutCollaborateursInput, ContactUncheckedCreateWithoutCollaborateursInput> | ContactCreateWithoutCollaborateursInput[] | ContactUncheckedCreateWithoutCollaborateursInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCollaborateursInput | ContactCreateOrConnectWithoutCollaborateursInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCollaborateursInput | ContactUpsertWithWhereUniqueWithoutCollaborateursInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCollaborateursInput | ContactUpdateWithWhereUniqueWithoutCollaborateursInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCollaborateursInput | ContactUpdateManyWithWhereWithoutCollaborateursInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput = {
    create?: XOR<DemandeCongeCreateWithoutCollaborateurInput, DemandeCongeUncheckedCreateWithoutCollaborateurInput> | DemandeCongeCreateWithoutCollaborateurInput[] | DemandeCongeUncheckedCreateWithoutCollaborateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutCollaborateurInput | DemandeCongeCreateOrConnectWithoutCollaborateurInput[]
    upsert?: DemandeCongeUpsertWithWhereUniqueWithoutCollaborateurInput | DemandeCongeUpsertWithWhereUniqueWithoutCollaborateurInput[]
    createMany?: DemandeCongeCreateManyCollaborateurInputEnvelope
    set?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    disconnect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    delete?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    update?: DemandeCongeUpdateWithWhereUniqueWithoutCollaborateurInput | DemandeCongeUpdateWithWhereUniqueWithoutCollaborateurInput[]
    updateMany?: DemandeCongeUpdateManyWithWhereWithoutCollaborateurInput | DemandeCongeUpdateManyWithWhereWithoutCollaborateurInput[]
    deleteMany?: DemandeCongeScalarWhereInput | DemandeCongeScalarWhereInput[]
  }

  export type SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput = {
    create?: XOR<SalarieCreateWithoutCollaborateurInput, SalarieUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: SalarieCreateOrConnectWithoutCollaborateurInput
    upsert?: SalarieUpsertWithoutCollaborateurInput
    disconnect?: SalarieWhereInput | boolean
    delete?: SalarieWhereInput | boolean
    connect?: SalarieWhereUniqueInput
    update?: XOR<XOR<SalarieUpdateToOneWithWhereWithoutCollaborateurInput, SalarieUpdateWithoutCollaborateurInput>, SalarieUncheckedUpdateWithoutCollaborateurInput>
  }

  export type FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput = {
    create?: XOR<FicheDePosteCreateWithoutCollaborateurInput, FicheDePosteUncheckedCreateWithoutCollaborateurInput>
    connectOrCreate?: FicheDePosteCreateOrConnectWithoutCollaborateurInput
    upsert?: FicheDePosteUpsertWithoutCollaborateurInput
    disconnect?: FicheDePosteWhereInput | boolean
    delete?: FicheDePosteWhereInput | boolean
    connect?: FicheDePosteWhereUniqueInput
    update?: XOR<XOR<FicheDePosteUpdateToOneWithWhereWithoutCollaborateurInput, FicheDePosteUpdateWithoutCollaborateurInput>, FicheDePosteUncheckedUpdateWithoutCollaborateurInput>
  }

  export type CollaborateurCreateNestedOneWithoutCompteInput = {
    create?: XOR<CollaborateurCreateWithoutCompteInput, CollaborateurUncheckedCreateWithoutCompteInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutCompteInput
    connect?: CollaborateurWhereUniqueInput
  }

  export type CollaborateurCreateNestedManyWithoutManagersParInput = {
    create?: XOR<CollaborateurCreateWithoutManagersParInput, CollaborateurUncheckedCreateWithoutManagersParInput> | CollaborateurCreateWithoutManagersParInput[] | CollaborateurUncheckedCreateWithoutManagersParInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutManagersParInput | CollaborateurCreateOrConnectWithoutManagersParInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
  }

  export type DemandeCongeCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<DemandeCongeCreateWithoutUtilisateurInput, DemandeCongeUncheckedCreateWithoutUtilisateurInput> | DemandeCongeCreateWithoutUtilisateurInput[] | DemandeCongeUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutUtilisateurInput | DemandeCongeCreateOrConnectWithoutUtilisateurInput[]
    createMany?: DemandeCongeCreateManyUtilisateurInputEnvelope
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<NotificationCreateWithoutUtilisateurInput, NotificationUncheckedCreateWithoutUtilisateurInput> | NotificationCreateWithoutUtilisateurInput[] | NotificationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUtilisateurInput | NotificationCreateOrConnectWithoutUtilisateurInput[]
    createMany?: NotificationCreateManyUtilisateurInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CollaborateurUncheckedCreateNestedManyWithoutManagersParInput = {
    create?: XOR<CollaborateurCreateWithoutManagersParInput, CollaborateurUncheckedCreateWithoutManagersParInput> | CollaborateurCreateWithoutManagersParInput[] | CollaborateurUncheckedCreateWithoutManagersParInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutManagersParInput | CollaborateurCreateOrConnectWithoutManagersParInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
  }

  export type DemandeCongeUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<DemandeCongeCreateWithoutUtilisateurInput, DemandeCongeUncheckedCreateWithoutUtilisateurInput> | DemandeCongeCreateWithoutUtilisateurInput[] | DemandeCongeUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutUtilisateurInput | DemandeCongeCreateOrConnectWithoutUtilisateurInput[]
    createMany?: DemandeCongeCreateManyUtilisateurInputEnvelope
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<NotificationCreateWithoutUtilisateurInput, NotificationUncheckedCreateWithoutUtilisateurInput> | NotificationCreateWithoutUtilisateurInput[] | NotificationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUtilisateurInput | NotificationCreateOrConnectWithoutUtilisateurInput[]
    createMany?: NotificationCreateManyUtilisateurInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type CollaborateurUpdateOneRequiredWithoutCompteNestedInput = {
    create?: XOR<CollaborateurCreateWithoutCompteInput, CollaborateurUncheckedCreateWithoutCompteInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutCompteInput
    upsert?: CollaborateurUpsertWithoutCompteInput
    connect?: CollaborateurWhereUniqueInput
    update?: XOR<XOR<CollaborateurUpdateToOneWithWhereWithoutCompteInput, CollaborateurUpdateWithoutCompteInput>, CollaborateurUncheckedUpdateWithoutCompteInput>
  }

  export type CollaborateurUpdateManyWithoutManagersParNestedInput = {
    create?: XOR<CollaborateurCreateWithoutManagersParInput, CollaborateurUncheckedCreateWithoutManagersParInput> | CollaborateurCreateWithoutManagersParInput[] | CollaborateurUncheckedCreateWithoutManagersParInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutManagersParInput | CollaborateurCreateOrConnectWithoutManagersParInput[]
    upsert?: CollaborateurUpsertWithWhereUniqueWithoutManagersParInput | CollaborateurUpsertWithWhereUniqueWithoutManagersParInput[]
    set?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    disconnect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    delete?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    update?: CollaborateurUpdateWithWhereUniqueWithoutManagersParInput | CollaborateurUpdateWithWhereUniqueWithoutManagersParInput[]
    updateMany?: CollaborateurUpdateManyWithWhereWithoutManagersParInput | CollaborateurUpdateManyWithWhereWithoutManagersParInput[]
    deleteMany?: CollaborateurScalarWhereInput | CollaborateurScalarWhereInput[]
  }

  export type DemandeCongeUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<DemandeCongeCreateWithoutUtilisateurInput, DemandeCongeUncheckedCreateWithoutUtilisateurInput> | DemandeCongeCreateWithoutUtilisateurInput[] | DemandeCongeUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutUtilisateurInput | DemandeCongeCreateOrConnectWithoutUtilisateurInput[]
    upsert?: DemandeCongeUpsertWithWhereUniqueWithoutUtilisateurInput | DemandeCongeUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: DemandeCongeCreateManyUtilisateurInputEnvelope
    set?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    disconnect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    delete?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    update?: DemandeCongeUpdateWithWhereUniqueWithoutUtilisateurInput | DemandeCongeUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: DemandeCongeUpdateManyWithWhereWithoutUtilisateurInput | DemandeCongeUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: DemandeCongeScalarWhereInput | DemandeCongeScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUtilisateurInput | ContactUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUtilisateurInput | ContactUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUtilisateurInput | ContactUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<NotificationCreateWithoutUtilisateurInput, NotificationUncheckedCreateWithoutUtilisateurInput> | NotificationCreateWithoutUtilisateurInput[] | NotificationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUtilisateurInput | NotificationCreateOrConnectWithoutUtilisateurInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUtilisateurInput | NotificationUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: NotificationCreateManyUtilisateurInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUtilisateurInput | NotificationUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUtilisateurInput | NotificationUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CollaborateurUncheckedUpdateManyWithoutManagersParNestedInput = {
    create?: XOR<CollaborateurCreateWithoutManagersParInput, CollaborateurUncheckedCreateWithoutManagersParInput> | CollaborateurCreateWithoutManagersParInput[] | CollaborateurUncheckedCreateWithoutManagersParInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutManagersParInput | CollaborateurCreateOrConnectWithoutManagersParInput[]
    upsert?: CollaborateurUpsertWithWhereUniqueWithoutManagersParInput | CollaborateurUpsertWithWhereUniqueWithoutManagersParInput[]
    set?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    disconnect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    delete?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    update?: CollaborateurUpdateWithWhereUniqueWithoutManagersParInput | CollaborateurUpdateWithWhereUniqueWithoutManagersParInput[]
    updateMany?: CollaborateurUpdateManyWithWhereWithoutManagersParInput | CollaborateurUpdateManyWithWhereWithoutManagersParInput[]
    deleteMany?: CollaborateurScalarWhereInput | CollaborateurScalarWhereInput[]
  }

  export type DemandeCongeUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<DemandeCongeCreateWithoutUtilisateurInput, DemandeCongeUncheckedCreateWithoutUtilisateurInput> | DemandeCongeCreateWithoutUtilisateurInput[] | DemandeCongeUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutUtilisateurInput | DemandeCongeCreateOrConnectWithoutUtilisateurInput[]
    upsert?: DemandeCongeUpsertWithWhereUniqueWithoutUtilisateurInput | DemandeCongeUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: DemandeCongeCreateManyUtilisateurInputEnvelope
    set?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    disconnect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    delete?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    connect?: DemandeCongeWhereUniqueInput | DemandeCongeWhereUniqueInput[]
    update?: DemandeCongeUpdateWithWhereUniqueWithoutUtilisateurInput | DemandeCongeUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: DemandeCongeUpdateManyWithWhereWithoutUtilisateurInput | DemandeCongeUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: DemandeCongeScalarWhereInput | DemandeCongeScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUtilisateurInput | ContactUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUtilisateurInput | ContactUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUtilisateurInput | ContactUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<NotificationCreateWithoutUtilisateurInput, NotificationUncheckedCreateWithoutUtilisateurInput> | NotificationCreateWithoutUtilisateurInput[] | NotificationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUtilisateurInput | NotificationCreateOrConnectWithoutUtilisateurInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUtilisateurInput | NotificationUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: NotificationCreateManyUtilisateurInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUtilisateurInput | NotificationUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUtilisateurInput | NotificationUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CollaborateurCreateNestedOneWithoutEvenementsInput = {
    create?: XOR<CollaborateurCreateWithoutEvenementsInput, CollaborateurUncheckedCreateWithoutEvenementsInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutEvenementsInput
    connect?: CollaborateurWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CollaborateurUpdateOneRequiredWithoutEvenementsNestedInput = {
    create?: XOR<CollaborateurCreateWithoutEvenementsInput, CollaborateurUncheckedCreateWithoutEvenementsInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutEvenementsInput
    upsert?: CollaborateurUpsertWithoutEvenementsInput
    connect?: CollaborateurWhereUniqueInput
    update?: XOR<XOR<CollaborateurUpdateToOneWithWhereWithoutEvenementsInput, CollaborateurUpdateWithoutEvenementsInput>, CollaborateurUncheckedUpdateWithoutEvenementsInput>
  }

  export type SalarieCreatecertificationsInput = {
    set: string[]
  }

  export type SalarieCreatehabilitationsInput = {
    set: string[]
  }

  export type CollaborateurCreateNestedOneWithoutSalarieInput = {
    create?: XOR<CollaborateurCreateWithoutSalarieInput, CollaborateurUncheckedCreateWithoutSalarieInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutSalarieInput
    connect?: CollaborateurWhereUniqueInput
  }

  export type SalarieUpdatecertificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SalarieUpdatehabilitationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CollaborateurUpdateOneWithoutSalarieNestedInput = {
    create?: XOR<CollaborateurCreateWithoutSalarieInput, CollaborateurUncheckedCreateWithoutSalarieInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutSalarieInput
    upsert?: CollaborateurUpsertWithoutSalarieInput
    disconnect?: CollaborateurWhereInput | boolean
    delete?: CollaborateurWhereInput | boolean
    connect?: CollaborateurWhereUniqueInput
    update?: XOR<XOR<CollaborateurUpdateToOneWithWhereWithoutSalarieInput, CollaborateurUpdateWithoutSalarieInput>, CollaborateurUncheckedUpdateWithoutSalarieInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContactCreatecategoriesInput = {
    set: string[]
  }

  export type ContactCreatecollaborateursIdsInput = {
    set: string[]
  }

  export type CompteCreateNestedOneWithoutContactsInput = {
    create?: XOR<CompteCreateWithoutContactsInput, CompteUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompteCreateOrConnectWithoutContactsInput
    connect?: CompteWhereUniqueInput
  }

  export type CollaborateurCreateNestedManyWithoutContactsGeresInput = {
    create?: XOR<CollaborateurCreateWithoutContactsGeresInput, CollaborateurUncheckedCreateWithoutContactsGeresInput> | CollaborateurCreateWithoutContactsGeresInput[] | CollaborateurUncheckedCreateWithoutContactsGeresInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutContactsGeresInput | CollaborateurCreateOrConnectWithoutContactsGeresInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
  }

  export type CollaborateurUncheckedCreateNestedManyWithoutContactsGeresInput = {
    create?: XOR<CollaborateurCreateWithoutContactsGeresInput, CollaborateurUncheckedCreateWithoutContactsGeresInput> | CollaborateurCreateWithoutContactsGeresInput[] | CollaborateurUncheckedCreateWithoutContactsGeresInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutContactsGeresInput | CollaborateurCreateOrConnectWithoutContactsGeresInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
  }

  export type ContactUpdatecategoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContactUpdatecollaborateursIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompteUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<CompteCreateWithoutContactsInput, CompteUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompteCreateOrConnectWithoutContactsInput
    upsert?: CompteUpsertWithoutContactsInput
    connect?: CompteWhereUniqueInput
    update?: XOR<XOR<CompteUpdateToOneWithWhereWithoutContactsInput, CompteUpdateWithoutContactsInput>, CompteUncheckedUpdateWithoutContactsInput>
  }

  export type CollaborateurUpdateManyWithoutContactsGeresNestedInput = {
    create?: XOR<CollaborateurCreateWithoutContactsGeresInput, CollaborateurUncheckedCreateWithoutContactsGeresInput> | CollaborateurCreateWithoutContactsGeresInput[] | CollaborateurUncheckedCreateWithoutContactsGeresInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutContactsGeresInput | CollaborateurCreateOrConnectWithoutContactsGeresInput[]
    upsert?: CollaborateurUpsertWithWhereUniqueWithoutContactsGeresInput | CollaborateurUpsertWithWhereUniqueWithoutContactsGeresInput[]
    set?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    disconnect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    delete?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    update?: CollaborateurUpdateWithWhereUniqueWithoutContactsGeresInput | CollaborateurUpdateWithWhereUniqueWithoutContactsGeresInput[]
    updateMany?: CollaborateurUpdateManyWithWhereWithoutContactsGeresInput | CollaborateurUpdateManyWithWhereWithoutContactsGeresInput[]
    deleteMany?: CollaborateurScalarWhereInput | CollaborateurScalarWhereInput[]
  }

  export type CollaborateurUncheckedUpdateManyWithoutContactsGeresNestedInput = {
    create?: XOR<CollaborateurCreateWithoutContactsGeresInput, CollaborateurUncheckedCreateWithoutContactsGeresInput> | CollaborateurCreateWithoutContactsGeresInput[] | CollaborateurUncheckedCreateWithoutContactsGeresInput[]
    connectOrCreate?: CollaborateurCreateOrConnectWithoutContactsGeresInput | CollaborateurCreateOrConnectWithoutContactsGeresInput[]
    upsert?: CollaborateurUpsertWithWhereUniqueWithoutContactsGeresInput | CollaborateurUpsertWithWhereUniqueWithoutContactsGeresInput[]
    set?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    disconnect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    delete?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    connect?: CollaborateurWhereUniqueInput | CollaborateurWhereUniqueInput[]
    update?: CollaborateurUpdateWithWhereUniqueWithoutContactsGeresInput | CollaborateurUpdateWithWhereUniqueWithoutContactsGeresInput[]
    updateMany?: CollaborateurUpdateManyWithWhereWithoutContactsGeresInput | CollaborateurUpdateManyWithWhereWithoutContactsGeresInput[]
    deleteMany?: CollaborateurScalarWhereInput | CollaborateurScalarWhereInput[]
  }

  export type CompteCreateNestedOneWithoutDemandesCongesInput = {
    create?: XOR<CompteCreateWithoutDemandesCongesInput, CompteUncheckedCreateWithoutDemandesCongesInput>
    connectOrCreate?: CompteCreateOrConnectWithoutDemandesCongesInput
    connect?: CompteWhereUniqueInput
  }

  export type CollaborateurCreateNestedOneWithoutDemandesCongesInput = {
    create?: XOR<CollaborateurCreateWithoutDemandesCongesInput, CollaborateurUncheckedCreateWithoutDemandesCongesInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutDemandesCongesInput
    connect?: CollaborateurWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutDemandeCongeInput = {
    create?: XOR<NotificationCreateWithoutDemandeCongeInput, NotificationUncheckedCreateWithoutDemandeCongeInput> | NotificationCreateWithoutDemandeCongeInput[] | NotificationUncheckedCreateWithoutDemandeCongeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDemandeCongeInput | NotificationCreateOrConnectWithoutDemandeCongeInput[]
    createMany?: NotificationCreateManyDemandeCongeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutDemandeCongeInput = {
    create?: XOR<NotificationCreateWithoutDemandeCongeInput, NotificationUncheckedCreateWithoutDemandeCongeInput> | NotificationCreateWithoutDemandeCongeInput[] | NotificationUncheckedCreateWithoutDemandeCongeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDemandeCongeInput | NotificationCreateOrConnectWithoutDemandeCongeInput[]
    createMany?: NotificationCreateManyDemandeCongeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CompteUpdateOneRequiredWithoutDemandesCongesNestedInput = {
    create?: XOR<CompteCreateWithoutDemandesCongesInput, CompteUncheckedCreateWithoutDemandesCongesInput>
    connectOrCreate?: CompteCreateOrConnectWithoutDemandesCongesInput
    upsert?: CompteUpsertWithoutDemandesCongesInput
    connect?: CompteWhereUniqueInput
    update?: XOR<XOR<CompteUpdateToOneWithWhereWithoutDemandesCongesInput, CompteUpdateWithoutDemandesCongesInput>, CompteUncheckedUpdateWithoutDemandesCongesInput>
  }

  export type CollaborateurUpdateOneRequiredWithoutDemandesCongesNestedInput = {
    create?: XOR<CollaborateurCreateWithoutDemandesCongesInput, CollaborateurUncheckedCreateWithoutDemandesCongesInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutDemandesCongesInput
    upsert?: CollaborateurUpsertWithoutDemandesCongesInput
    connect?: CollaborateurWhereUniqueInput
    update?: XOR<XOR<CollaborateurUpdateToOneWithWhereWithoutDemandesCongesInput, CollaborateurUpdateWithoutDemandesCongesInput>, CollaborateurUncheckedUpdateWithoutDemandesCongesInput>
  }

  export type NotificationUpdateManyWithoutDemandeCongeNestedInput = {
    create?: XOR<NotificationCreateWithoutDemandeCongeInput, NotificationUncheckedCreateWithoutDemandeCongeInput> | NotificationCreateWithoutDemandeCongeInput[] | NotificationUncheckedCreateWithoutDemandeCongeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDemandeCongeInput | NotificationCreateOrConnectWithoutDemandeCongeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDemandeCongeInput | NotificationUpsertWithWhereUniqueWithoutDemandeCongeInput[]
    createMany?: NotificationCreateManyDemandeCongeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDemandeCongeInput | NotificationUpdateWithWhereUniqueWithoutDemandeCongeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDemandeCongeInput | NotificationUpdateManyWithWhereWithoutDemandeCongeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutDemandeCongeNestedInput = {
    create?: XOR<NotificationCreateWithoutDemandeCongeInput, NotificationUncheckedCreateWithoutDemandeCongeInput> | NotificationCreateWithoutDemandeCongeInput[] | NotificationUncheckedCreateWithoutDemandeCongeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDemandeCongeInput | NotificationCreateOrConnectWithoutDemandeCongeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDemandeCongeInput | NotificationUpsertWithWhereUniqueWithoutDemandeCongeInput[]
    createMany?: NotificationCreateManyDemandeCongeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDemandeCongeInput | NotificationUpdateWithWhereUniqueWithoutDemandeCongeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDemandeCongeInput | NotificationUpdateManyWithWhereWithoutDemandeCongeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CompteCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CompteCreateWithoutNotificationsInput, CompteUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CompteCreateOrConnectWithoutNotificationsInput
    connect?: CompteWhereUniqueInput
  }

  export type DemandeCongeCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<DemandeCongeCreateWithoutNotificationsInput, DemandeCongeUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutNotificationsInput
    connect?: DemandeCongeWhereUniqueInput
  }

  export type CompteUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<CompteCreateWithoutNotificationsInput, CompteUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CompteCreateOrConnectWithoutNotificationsInput
    upsert?: CompteUpsertWithoutNotificationsInput
    connect?: CompteWhereUniqueInput
    update?: XOR<XOR<CompteUpdateToOneWithWhereWithoutNotificationsInput, CompteUpdateWithoutNotificationsInput>, CompteUncheckedUpdateWithoutNotificationsInput>
  }

  export type DemandeCongeUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<DemandeCongeCreateWithoutNotificationsInput, DemandeCongeUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: DemandeCongeCreateOrConnectWithoutNotificationsInput
    upsert?: DemandeCongeUpsertWithoutNotificationsInput
    disconnect?: DemandeCongeWhereInput | boolean
    delete?: DemandeCongeWhereInput | boolean
    connect?: DemandeCongeWhereUniqueInput
    update?: XOR<XOR<DemandeCongeUpdateToOneWithWhereWithoutNotificationsInput, DemandeCongeUpdateWithoutNotificationsInput>, DemandeCongeUncheckedUpdateWithoutNotificationsInput>
  }

  export type FicheDePosteCreatecertificationsInput = {
    set: string[]
  }

  export type FicheDePosteCreatehabilitationsInput = {
    set: string[]
  }

  export type FicheDePosteCreatecompetencesRequisesInput = {
    set: string[]
  }

  export type FicheDePosteCreatemissionsInput = {
    set: string[]
  }

  export type CollaborateurCreateNestedOneWithoutFicheDePosteInput = {
    create?: XOR<CollaborateurCreateWithoutFicheDePosteInput, CollaborateurUncheckedCreateWithoutFicheDePosteInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutFicheDePosteInput
    connect?: CollaborateurWhereUniqueInput
  }

  export type FicheDePosteUpdatecertificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FicheDePosteUpdatehabilitationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FicheDePosteUpdatecompetencesRequisesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FicheDePosteUpdatemissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CollaborateurUpdateOneWithoutFicheDePosteNestedInput = {
    create?: XOR<CollaborateurCreateWithoutFicheDePosteInput, CollaborateurUncheckedCreateWithoutFicheDePosteInput>
    connectOrCreate?: CollaborateurCreateOrConnectWithoutFicheDePosteInput
    upsert?: CollaborateurUpsertWithoutFicheDePosteInput
    disconnect?: CollaborateurWhereInput | boolean
    delete?: CollaborateurWhereInput | boolean
    connect?: CollaborateurWhereUniqueInput
    update?: XOR<XOR<CollaborateurUpdateToOneWithWhereWithoutFicheDePosteInput, CollaborateurUpdateWithoutFicheDePosteInput>, CollaborateurUncheckedUpdateWithoutFicheDePosteInput>
  }

  export type EnumRoleAdminFieldUpdateOperationsInput = {
    set?: $Enums.RoleAdmin
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleAdminFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAdmin | EnumRoleAdminFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAdminFilter<$PrismaModel> | $Enums.RoleAdmin
  }

  export type NestedEnumRoleAdminWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAdmin | EnumRoleAdminFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAdmin[] | ListEnumRoleAdminFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAdminWithAggregatesFilter<$PrismaModel> | $Enums.RoleAdmin
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleAdminFilter<$PrismaModel>
    _max?: NestedEnumRoleAdminFilter<$PrismaModel>
  }

  export type EvenementCreateWithoutCollaborateurInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    typeEvenement: string
    lieuChantier?: string | null
    zoneTrajet?: string | null
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: number
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: number
    typeAbsence?: string | null
    verrouille?: boolean
    latitude?: number | null
    longitude?: number | null
    adresseComplete?: string | null
    createdAt?: Date | string
  }

  export type EvenementUncheckedCreateWithoutCollaborateurInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    typeEvenement: string
    lieuChantier?: string | null
    zoneTrajet?: string | null
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: number
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: number
    typeAbsence?: string | null
    verrouille?: boolean
    latitude?: number | null
    longitude?: number | null
    adresseComplete?: string | null
    createdAt?: Date | string
  }

  export type EvenementCreateOrConnectWithoutCollaborateurInput = {
    where: EvenementWhereUniqueInput
    create: XOR<EvenementCreateWithoutCollaborateurInput, EvenementUncheckedCreateWithoutCollaborateurInput>
  }

  export type EvenementCreateManyCollaborateurInputEnvelope = {
    data: EvenementCreateManyCollaborateurInput | EvenementCreateManyCollaborateurInput[]
    skipDuplicates?: boolean
  }

  export type CompteCreateWithoutCollaborateurInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    createdAt?: Date | string
    collaborateursGeres?: CollaborateurCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteUncheckedCreateWithoutCollaborateurInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    createdAt?: Date | string
    collaborateursGeres?: CollaborateurUncheckedCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteCreateOrConnectWithoutCollaborateurInput = {
    where: CompteWhereUniqueInput
    create: XOR<CompteCreateWithoutCollaborateurInput, CompteUncheckedCreateWithoutCollaborateurInput>
  }

  export type CompteCreateWithoutCollaborateursGeresInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    createdAt?: Date | string
    collaborateur: CollaborateurCreateNestedOneWithoutCompteInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteUncheckedCreateWithoutCollaborateursGeresInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    collaborateurId: string
    createdAt?: Date | string
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteCreateOrConnectWithoutCollaborateursGeresInput = {
    where: CompteWhereUniqueInput
    create: XOR<CompteCreateWithoutCollaborateursGeresInput, CompteUncheckedCreateWithoutCollaborateursGeresInput>
  }

  export type ContactCreateWithoutCollaborateursInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
    utilisateur: CompteCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutCollaborateursInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    utilisateurId: string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
  }

  export type ContactCreateOrConnectWithoutCollaborateursInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCollaborateursInput, ContactUncheckedCreateWithoutCollaborateursInput>
  }

  export type DemandeCongeCreateWithoutCollaborateurInput = {
    id?: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
    utilisateur: CompteCreateNestedOneWithoutDemandesCongesInput
    notifications?: NotificationCreateNestedManyWithoutDemandeCongeInput
  }

  export type DemandeCongeUncheckedCreateWithoutCollaborateurInput = {
    id?: string
    utilisateurId: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
    notifications?: NotificationUncheckedCreateNestedManyWithoutDemandeCongeInput
  }

  export type DemandeCongeCreateOrConnectWithoutCollaborateurInput = {
    where: DemandeCongeWhereUniqueInput
    create: XOR<DemandeCongeCreateWithoutCollaborateurInput, DemandeCongeUncheckedCreateWithoutCollaborateurInput>
  }

  export type DemandeCongeCreateManyCollaborateurInputEnvelope = {
    data: DemandeCongeCreateManyCollaborateurInput | DemandeCongeCreateManyCollaborateurInput[]
    skipDuplicates?: boolean
  }

  export type SalarieCreateWithoutCollaborateurInput = {
    id?: string
    nom: string
    prenom: string
    classification: string
    dateEntree: Date | string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: SalarieCreatecertificationsInput | string[]
    habilitations?: SalarieCreatehabilitationsInput | string[]
    entreprise: string
    poste: string
    email: string
    telephone: string
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    createdAt?: Date | string
  }

  export type SalarieUncheckedCreateWithoutCollaborateurInput = {
    id?: string
    nom: string
    prenom: string
    classification: string
    dateEntree: Date | string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: SalarieCreatecertificationsInput | string[]
    habilitations?: SalarieCreatehabilitationsInput | string[]
    entreprise: string
    poste: string
    email: string
    telephone: string
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    createdAt?: Date | string
  }

  export type SalarieCreateOrConnectWithoutCollaborateurInput = {
    where: SalarieWhereUniqueInput
    create: XOR<SalarieCreateWithoutCollaborateurInput, SalarieUncheckedCreateWithoutCollaborateurInput>
  }

  export type FicheDePosteCreateWithoutCollaborateurInput = {
    id?: string
    classification: string
    poste: string
    entreprise: string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: FicheDePosteCreatecertificationsInput | string[]
    habilitations?: FicheDePosteCreatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteCreatecompetencesRequisesInput | string[]
    description: string
    missions?: FicheDePosteCreatemissionsInput | string[]
    experience?: string | null
    formation?: string | null
    remuneration?: string | null
    avantages?: string | null
    horaires?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    lieuTravail?: string | null
    dateCreation?: Date | string
    dateModification?: Date | string
    estActive?: boolean
  }

  export type FicheDePosteUncheckedCreateWithoutCollaborateurInput = {
    id?: string
    classification: string
    poste: string
    entreprise: string
    typeContrat: string
    dureeContrat?: string | null
    certifications?: FicheDePosteCreatecertificationsInput | string[]
    habilitations?: FicheDePosteCreatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteCreatecompetencesRequisesInput | string[]
    description: string
    missions?: FicheDePosteCreatemissionsInput | string[]
    experience?: string | null
    formation?: string | null
    remuneration?: string | null
    avantages?: string | null
    horaires?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    codePostal?: string | null
    ville?: string | null
    dateNaissance?: Date | string | null
    numeroSecu?: string | null
    lieuTravail?: string | null
    dateCreation?: Date | string
    dateModification?: Date | string
    estActive?: boolean
  }

  export type FicheDePosteCreateOrConnectWithoutCollaborateurInput = {
    where: FicheDePosteWhereUniqueInput
    create: XOR<FicheDePosteCreateWithoutCollaborateurInput, FicheDePosteUncheckedCreateWithoutCollaborateurInput>
  }

  export type EvenementUpsertWithWhereUniqueWithoutCollaborateurInput = {
    where: EvenementWhereUniqueInput
    update: XOR<EvenementUpdateWithoutCollaborateurInput, EvenementUncheckedUpdateWithoutCollaborateurInput>
    create: XOR<EvenementCreateWithoutCollaborateurInput, EvenementUncheckedCreateWithoutCollaborateurInput>
  }

  export type EvenementUpdateWithWhereUniqueWithoutCollaborateurInput = {
    where: EvenementWhereUniqueInput
    data: XOR<EvenementUpdateWithoutCollaborateurInput, EvenementUncheckedUpdateWithoutCollaborateurInput>
  }

  export type EvenementUpdateManyWithWhereWithoutCollaborateurInput = {
    where: EvenementScalarWhereInput
    data: XOR<EvenementUpdateManyMutationInput, EvenementUncheckedUpdateManyWithoutCollaborateurInput>
  }

  export type EvenementScalarWhereInput = {
    AND?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
    OR?: EvenementScalarWhereInput[]
    NOT?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
    id?: StringFilter<"Evenement"> | string
    title?: StringFilter<"Evenement"> | string
    start?: DateTimeFilter<"Evenement"> | Date | string
    end?: DateTimeFilter<"Evenement"> | Date | string
    collaborateurId?: StringFilter<"Evenement"> | string
    typeEvenement?: StringFilter<"Evenement"> | string
    lieuChantier?: StringNullableFilter<"Evenement"> | string | null
    zoneTrajet?: StringNullableFilter<"Evenement"> | string | null
    panierRepas?: BoolFilter<"Evenement"> | boolean
    ticketRestaurant?: BoolFilter<"Evenement"> | boolean
    heuresSupplementaires?: FloatFilter<"Evenement"> | number
    grandDeplacement?: BoolFilter<"Evenement"> | boolean
    prgd?: BoolFilter<"Evenement"> | boolean
    nombrePrgd?: IntFilter<"Evenement"> | number
    typeAbsence?: StringNullableFilter<"Evenement"> | string | null
    verrouille?: BoolFilter<"Evenement"> | boolean
    latitude?: FloatNullableFilter<"Evenement"> | number | null
    longitude?: FloatNullableFilter<"Evenement"> | number | null
    adresseComplete?: StringNullableFilter<"Evenement"> | string | null
    createdAt?: DateTimeFilter<"Evenement"> | Date | string
  }

  export type CompteUpsertWithoutCollaborateurInput = {
    update: XOR<CompteUpdateWithoutCollaborateurInput, CompteUncheckedUpdateWithoutCollaborateurInput>
    create: XOR<CompteCreateWithoutCollaborateurInput, CompteUncheckedCreateWithoutCollaborateurInput>
    where?: CompteWhereInput
  }

  export type CompteUpdateToOneWithWhereWithoutCollaborateurInput = {
    where?: CompteWhereInput
    data: XOR<CompteUpdateWithoutCollaborateurInput, CompteUncheckedUpdateWithoutCollaborateurInput>
  }

  export type CompteUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursGeres?: CollaborateurUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUncheckedUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursGeres?: CollaborateurUncheckedUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUpsertWithWhereUniqueWithoutCollaborateursGeresInput = {
    where: CompteWhereUniqueInput
    update: XOR<CompteUpdateWithoutCollaborateursGeresInput, CompteUncheckedUpdateWithoutCollaborateursGeresInput>
    create: XOR<CompteCreateWithoutCollaborateursGeresInput, CompteUncheckedCreateWithoutCollaborateursGeresInput>
  }

  export type CompteUpdateWithWhereUniqueWithoutCollaborateursGeresInput = {
    where: CompteWhereUniqueInput
    data: XOR<CompteUpdateWithoutCollaborateursGeresInput, CompteUncheckedUpdateWithoutCollaborateursGeresInput>
  }

  export type CompteUpdateManyWithWhereWithoutCollaborateursGeresInput = {
    where: CompteScalarWhereInput
    data: XOR<CompteUpdateManyMutationInput, CompteUncheckedUpdateManyWithoutCollaborateursGeresInput>
  }

  export type CompteScalarWhereInput = {
    AND?: CompteScalarWhereInput | CompteScalarWhereInput[]
    OR?: CompteScalarWhereInput[]
    NOT?: CompteScalarWhereInput | CompteScalarWhereInput[]
    id?: StringFilter<"Compte"> | string
    identifiant?: StringFilter<"Compte"> | string
    motDePasse?: StringFilter<"Compte"> | string
    role?: EnumRoleFilter<"Compte"> | $Enums.Role
    collaborateurId?: StringFilter<"Compte"> | string
    createdAt?: DateTimeFilter<"Compte"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutCollaborateursInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCollaborateursInput, ContactUncheckedUpdateWithoutCollaborateursInput>
    create: XOR<ContactCreateWithoutCollaborateursInput, ContactUncheckedCreateWithoutCollaborateursInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCollaborateursInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCollaborateursInput, ContactUncheckedUpdateWithoutCollaborateursInput>
  }

  export type ContactUpdateManyWithWhereWithoutCollaborateursInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCollaborateursInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    nom?: StringFilter<"Contact"> | string
    prenom?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    telephone?: StringFilter<"Contact"> | string
    adresse?: StringFilter<"Contact"> | string
    codePostal?: StringFilter<"Contact"> | string
    ville?: StringFilter<"Contact"> | string
    categories?: StringNullableListFilter<"Contact">
    status?: StringFilter<"Contact"> | string
    commentaires?: StringNullableFilter<"Contact"> | string | null
    dateCreation?: DateTimeFilter<"Contact"> | Date | string
    dateDerniereModification?: DateTimeFilter<"Contact"> | Date | string
    utilisateurId?: StringFilter<"Contact"> | string
    collaborateursIds?: StringNullableListFilter<"Contact">
    montantDevis?: FloatNullableFilter<"Contact"> | number | null
    archived?: BoolFilter<"Contact"> | boolean
    archiveDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
  }

  export type DemandeCongeUpsertWithWhereUniqueWithoutCollaborateurInput = {
    where: DemandeCongeWhereUniqueInput
    update: XOR<DemandeCongeUpdateWithoutCollaborateurInput, DemandeCongeUncheckedUpdateWithoutCollaborateurInput>
    create: XOR<DemandeCongeCreateWithoutCollaborateurInput, DemandeCongeUncheckedCreateWithoutCollaborateurInput>
  }

  export type DemandeCongeUpdateWithWhereUniqueWithoutCollaborateurInput = {
    where: DemandeCongeWhereUniqueInput
    data: XOR<DemandeCongeUpdateWithoutCollaborateurInput, DemandeCongeUncheckedUpdateWithoutCollaborateurInput>
  }

  export type DemandeCongeUpdateManyWithWhereWithoutCollaborateurInput = {
    where: DemandeCongeScalarWhereInput
    data: XOR<DemandeCongeUpdateManyMutationInput, DemandeCongeUncheckedUpdateManyWithoutCollaborateurInput>
  }

  export type DemandeCongeScalarWhereInput = {
    AND?: DemandeCongeScalarWhereInput | DemandeCongeScalarWhereInput[]
    OR?: DemandeCongeScalarWhereInput[]
    NOT?: DemandeCongeScalarWhereInput | DemandeCongeScalarWhereInput[]
    id?: StringFilter<"DemandeConge"> | string
    utilisateurId?: StringFilter<"DemandeConge"> | string
    collaborateurId?: StringFilter<"DemandeConge"> | string
    collaborateurNom?: StringFilter<"DemandeConge"> | string
    dateDebut?: DateTimeFilter<"DemandeConge"> | Date | string
    dateFin?: DateTimeFilter<"DemandeConge"> | Date | string
    typeConge?: StringFilter<"DemandeConge"> | string
    motif?: StringFilter<"DemandeConge"> | string
    statut?: StringFilter<"DemandeConge"> | string
    commentaireAdmin?: StringNullableFilter<"DemandeConge"> | string | null
    dateCreation?: DateTimeFilter<"DemandeConge"> | Date | string
    dateModification?: DateTimeFilter<"DemandeConge"> | Date | string
    notificationLue?: BoolFilter<"DemandeConge"> | boolean
  }

  export type SalarieUpsertWithoutCollaborateurInput = {
    update: XOR<SalarieUpdateWithoutCollaborateurInput, SalarieUncheckedUpdateWithoutCollaborateurInput>
    create: XOR<SalarieCreateWithoutCollaborateurInput, SalarieUncheckedCreateWithoutCollaborateurInput>
    where?: SalarieWhereInput
  }

  export type SalarieUpdateToOneWithWhereWithoutCollaborateurInput = {
    where?: SalarieWhereInput
    data: XOR<SalarieUpdateWithoutCollaborateurInput, SalarieUncheckedUpdateWithoutCollaborateurInput>
  }

  export type SalarieUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: SalarieUpdatecertificationsInput | string[]
    habilitations?: SalarieUpdatehabilitationsInput | string[]
    entreprise?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalarieUncheckedUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: SalarieUpdatecertificationsInput | string[]
    habilitations?: SalarieUpdatehabilitationsInput | string[]
    entreprise?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FicheDePosteUpsertWithoutCollaborateurInput = {
    update: XOR<FicheDePosteUpdateWithoutCollaborateurInput, FicheDePosteUncheckedUpdateWithoutCollaborateurInput>
    create: XOR<FicheDePosteCreateWithoutCollaborateurInput, FicheDePosteUncheckedCreateWithoutCollaborateurInput>
    where?: FicheDePosteWhereInput
  }

  export type FicheDePosteUpdateToOneWithWhereWithoutCollaborateurInput = {
    where?: FicheDePosteWhereInput
    data: XOR<FicheDePosteUpdateWithoutCollaborateurInput, FicheDePosteUncheckedUpdateWithoutCollaborateurInput>
  }

  export type FicheDePosteUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: FicheDePosteUpdatecertificationsInput | string[]
    habilitations?: FicheDePosteUpdatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteUpdatecompetencesRequisesInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    missions?: FicheDePosteUpdatemissionsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    remuneration?: NullableStringFieldUpdateOperationsInput | string | null
    avantages?: NullableStringFieldUpdateOperationsInput | string | null
    horaires?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    lieuTravail?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FicheDePosteUncheckedUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    classification?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    dureeContrat?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: FicheDePosteUpdatecertificationsInput | string[]
    habilitations?: FicheDePosteUpdatehabilitationsInput | string[]
    competencesRequises?: FicheDePosteUpdatecompetencesRequisesInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    missions?: FicheDePosteUpdatemissionsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    remuneration?: NullableStringFieldUpdateOperationsInput | string | null
    avantages?: NullableStringFieldUpdateOperationsInput | string | null
    horaires?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroSecu?: NullableStringFieldUpdateOperationsInput | string | null
    lieuTravail?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CollaborateurCreateWithoutCompteInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementCreateNestedManyWithoutCollaborateurInput
    managersPar?: CompteCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateWithoutCompteInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementUncheckedCreateNestedManyWithoutCollaborateurInput
    managersPar?: CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactUncheckedCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieUncheckedCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurCreateOrConnectWithoutCompteInput = {
    where: CollaborateurWhereUniqueInput
    create: XOR<CollaborateurCreateWithoutCompteInput, CollaborateurUncheckedCreateWithoutCompteInput>
  }

  export type CollaborateurCreateWithoutManagersParInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementCreateNestedManyWithoutCollaborateurInput
    compte?: CompteCreateNestedOneWithoutCollaborateurInput
    contactsGeres?: ContactCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateWithoutManagersParInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementUncheckedCreateNestedManyWithoutCollaborateurInput
    compte?: CompteUncheckedCreateNestedOneWithoutCollaborateurInput
    contactsGeres?: ContactUncheckedCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieUncheckedCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurCreateOrConnectWithoutManagersParInput = {
    where: CollaborateurWhereUniqueInput
    create: XOR<CollaborateurCreateWithoutManagersParInput, CollaborateurUncheckedCreateWithoutManagersParInput>
  }

  export type DemandeCongeCreateWithoutUtilisateurInput = {
    id?: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
    collaborateur: CollaborateurCreateNestedOneWithoutDemandesCongesInput
    notifications?: NotificationCreateNestedManyWithoutDemandeCongeInput
  }

  export type DemandeCongeUncheckedCreateWithoutUtilisateurInput = {
    id?: string
    collaborateurId: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
    notifications?: NotificationUncheckedCreateNestedManyWithoutDemandeCongeInput
  }

  export type DemandeCongeCreateOrConnectWithoutUtilisateurInput = {
    where: DemandeCongeWhereUniqueInput
    create: XOR<DemandeCongeCreateWithoutUtilisateurInput, DemandeCongeUncheckedCreateWithoutUtilisateurInput>
  }

  export type DemandeCongeCreateManyUtilisateurInputEnvelope = {
    data: DemandeCongeCreateManyUtilisateurInput | DemandeCongeCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUtilisateurInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
    collaborateurs?: CollaborateurCreateNestedManyWithoutContactsGeresInput
  }

  export type ContactUncheckedCreateWithoutUtilisateurInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
    collaborateurs?: CollaborateurUncheckedCreateNestedManyWithoutContactsGeresInput
  }

  export type ContactCreateOrConnectWithoutUtilisateurInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput>
  }

  export type ContactCreateManyUtilisateurInputEnvelope = {
    data: ContactCreateManyUtilisateurInput | ContactCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUtilisateurInput = {
    id?: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
    demandeConge?: DemandeCongeCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUtilisateurInput = {
    id?: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
    demandeId?: string | null
  }

  export type NotificationCreateOrConnectWithoutUtilisateurInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUtilisateurInput, NotificationUncheckedCreateWithoutUtilisateurInput>
  }

  export type NotificationCreateManyUtilisateurInputEnvelope = {
    data: NotificationCreateManyUtilisateurInput | NotificationCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type CollaborateurUpsertWithoutCompteInput = {
    update: XOR<CollaborateurUpdateWithoutCompteInput, CollaborateurUncheckedUpdateWithoutCompteInput>
    create: XOR<CollaborateurCreateWithoutCompteInput, CollaborateurUncheckedCreateWithoutCompteInput>
    where?: CollaborateurWhereInput
  }

  export type CollaborateurUpdateToOneWithWhereWithoutCompteInput = {
    where?: CollaborateurWhereInput
    data: XOR<CollaborateurUpdateWithoutCompteInput, CollaborateurUncheckedUpdateWithoutCompteInput>
  }

  export type CollaborateurUpdateWithoutCompteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUpdateManyWithoutCollaborateurNestedInput
    managersPar?: CompteUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateWithoutCompteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput
    managersPar?: CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUncheckedUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUpsertWithWhereUniqueWithoutManagersParInput = {
    where: CollaborateurWhereUniqueInput
    update: XOR<CollaborateurUpdateWithoutManagersParInput, CollaborateurUncheckedUpdateWithoutManagersParInput>
    create: XOR<CollaborateurCreateWithoutManagersParInput, CollaborateurUncheckedCreateWithoutManagersParInput>
  }

  export type CollaborateurUpdateWithWhereUniqueWithoutManagersParInput = {
    where: CollaborateurWhereUniqueInput
    data: XOR<CollaborateurUpdateWithoutManagersParInput, CollaborateurUncheckedUpdateWithoutManagersParInput>
  }

  export type CollaborateurUpdateManyWithWhereWithoutManagersParInput = {
    where: CollaborateurScalarWhereInput
    data: XOR<CollaborateurUpdateManyMutationInput, CollaborateurUncheckedUpdateManyWithoutManagersParInput>
  }

  export type CollaborateurScalarWhereInput = {
    AND?: CollaborateurScalarWhereInput | CollaborateurScalarWhereInput[]
    OR?: CollaborateurScalarWhereInput[]
    NOT?: CollaborateurScalarWhereInput | CollaborateurScalarWhereInput[]
    id?: StringFilter<"Collaborateur"> | string
    nom?: StringFilter<"Collaborateur"> | string
    couleur?: StringFilter<"Collaborateur"> | string
    entreprise?: StringFilter<"Collaborateur"> | string
    aCompte?: BoolFilter<"Collaborateur"> | boolean
    createdAt?: DateTimeFilter<"Collaborateur"> | Date | string
  }

  export type DemandeCongeUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: DemandeCongeWhereUniqueInput
    update: XOR<DemandeCongeUpdateWithoutUtilisateurInput, DemandeCongeUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<DemandeCongeCreateWithoutUtilisateurInput, DemandeCongeUncheckedCreateWithoutUtilisateurInput>
  }

  export type DemandeCongeUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: DemandeCongeWhereUniqueInput
    data: XOR<DemandeCongeUpdateWithoutUtilisateurInput, DemandeCongeUncheckedUpdateWithoutUtilisateurInput>
  }

  export type DemandeCongeUpdateManyWithWhereWithoutUtilisateurInput = {
    where: DemandeCongeScalarWhereInput
    data: XOR<DemandeCongeUpdateManyMutationInput, DemandeCongeUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUtilisateurInput, ContactUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUtilisateurInput, ContactUncheckedUpdateWithoutUtilisateurInput>
  }

  export type ContactUpdateManyWithWhereWithoutUtilisateurInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUtilisateurInput, NotificationUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<NotificationCreateWithoutUtilisateurInput, NotificationUncheckedCreateWithoutUtilisateurInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUtilisateurInput, NotificationUncheckedUpdateWithoutUtilisateurInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUtilisateurInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    utilisateurId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    lien?: StringFilter<"Notification"> | string
    dateCreation?: DateTimeFilter<"Notification"> | Date | string
    lue?: BoolFilter<"Notification"> | boolean
    type?: StringFilter<"Notification"> | string
    demandeId?: StringNullableFilter<"Notification"> | string | null
  }

  export type CollaborateurCreateWithoutEvenementsInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    compte?: CompteCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateWithoutEvenementsInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    compte?: CompteUncheckedCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactUncheckedCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieUncheckedCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurCreateOrConnectWithoutEvenementsInput = {
    where: CollaborateurWhereUniqueInput
    create: XOR<CollaborateurCreateWithoutEvenementsInput, CollaborateurUncheckedCreateWithoutEvenementsInput>
  }

  export type CollaborateurUpsertWithoutEvenementsInput = {
    update: XOR<CollaborateurUpdateWithoutEvenementsInput, CollaborateurUncheckedUpdateWithoutEvenementsInput>
    create: XOR<CollaborateurCreateWithoutEvenementsInput, CollaborateurUncheckedCreateWithoutEvenementsInput>
    where?: CollaborateurWhereInput
  }

  export type CollaborateurUpdateToOneWithWhereWithoutEvenementsInput = {
    where?: CollaborateurWhereInput
    data: XOR<CollaborateurUpdateWithoutEvenementsInput, CollaborateurUncheckedUpdateWithoutEvenementsInput>
  }

  export type CollaborateurUpdateWithoutEvenementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    compte?: CompteUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateWithoutEvenementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    compte?: CompteUncheckedUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUncheckedUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurCreateWithoutSalarieInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementCreateNestedManyWithoutCollaborateurInput
    compte?: CompteCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateWithoutSalarieInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementUncheckedCreateNestedManyWithoutCollaborateurInput
    compte?: CompteUncheckedCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactUncheckedCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurCreateOrConnectWithoutSalarieInput = {
    where: CollaborateurWhereUniqueInput
    create: XOR<CollaborateurCreateWithoutSalarieInput, CollaborateurUncheckedCreateWithoutSalarieInput>
  }

  export type CollaborateurUpsertWithoutSalarieInput = {
    update: XOR<CollaborateurUpdateWithoutSalarieInput, CollaborateurUncheckedUpdateWithoutSalarieInput>
    create: XOR<CollaborateurCreateWithoutSalarieInput, CollaborateurUncheckedCreateWithoutSalarieInput>
    where?: CollaborateurWhereInput
  }

  export type CollaborateurUpdateToOneWithWhereWithoutSalarieInput = {
    where?: CollaborateurWhereInput
    data: XOR<CollaborateurUpdateWithoutSalarieInput, CollaborateurUncheckedUpdateWithoutSalarieInput>
  }

  export type CollaborateurUpdateWithoutSalarieInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateWithoutSalarieInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUncheckedUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUncheckedUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type CompteCreateWithoutContactsInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    createdAt?: Date | string
    collaborateur: CollaborateurCreateNestedOneWithoutCompteInput
    collaborateursGeres?: CollaborateurCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteUncheckedCreateWithoutContactsInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    collaborateurId: string
    createdAt?: Date | string
    collaborateursGeres?: CollaborateurUncheckedCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteCreateOrConnectWithoutContactsInput = {
    where: CompteWhereUniqueInput
    create: XOR<CompteCreateWithoutContactsInput, CompteUncheckedCreateWithoutContactsInput>
  }

  export type CollaborateurCreateWithoutContactsGeresInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementCreateNestedManyWithoutCollaborateurInput
    compte?: CompteCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteCreateNestedManyWithoutCollaborateursGeresInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateWithoutContactsGeresInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementUncheckedCreateNestedManyWithoutCollaborateurInput
    compte?: CompteUncheckedCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieUncheckedCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurCreateOrConnectWithoutContactsGeresInput = {
    where: CollaborateurWhereUniqueInput
    create: XOR<CollaborateurCreateWithoutContactsGeresInput, CollaborateurUncheckedCreateWithoutContactsGeresInput>
  }

  export type CompteUpsertWithoutContactsInput = {
    update: XOR<CompteUpdateWithoutContactsInput, CompteUncheckedUpdateWithoutContactsInput>
    create: XOR<CompteCreateWithoutContactsInput, CompteUncheckedCreateWithoutContactsInput>
    where?: CompteWhereInput
  }

  export type CompteUpdateToOneWithWhereWithoutContactsInput = {
    where?: CompteWhereInput
    data: XOR<CompteUpdateWithoutContactsInput, CompteUncheckedUpdateWithoutContactsInput>
  }

  export type CompteUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateur?: CollaborateurUpdateOneRequiredWithoutCompteNestedInput
    collaborateursGeres?: CollaborateurUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    collaborateurId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursGeres?: CollaborateurUncheckedUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type CollaborateurUpsertWithWhereUniqueWithoutContactsGeresInput = {
    where: CollaborateurWhereUniqueInput
    update: XOR<CollaborateurUpdateWithoutContactsGeresInput, CollaborateurUncheckedUpdateWithoutContactsGeresInput>
    create: XOR<CollaborateurCreateWithoutContactsGeresInput, CollaborateurUncheckedCreateWithoutContactsGeresInput>
  }

  export type CollaborateurUpdateWithWhereUniqueWithoutContactsGeresInput = {
    where: CollaborateurWhereUniqueInput
    data: XOR<CollaborateurUpdateWithoutContactsGeresInput, CollaborateurUncheckedUpdateWithoutContactsGeresInput>
  }

  export type CollaborateurUpdateManyWithWhereWithoutContactsGeresInput = {
    where: CollaborateurScalarWhereInput
    data: XOR<CollaborateurUpdateManyMutationInput, CollaborateurUncheckedUpdateManyWithoutContactsGeresInput>
  }

  export type CompteCreateWithoutDemandesCongesInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    createdAt?: Date | string
    collaborateur: CollaborateurCreateNestedOneWithoutCompteInput
    collaborateursGeres?: CollaborateurCreateNestedManyWithoutManagersParInput
    contacts?: ContactCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteUncheckedCreateWithoutDemandesCongesInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    collaborateurId: string
    createdAt?: Date | string
    collaborateursGeres?: CollaborateurUncheckedCreateNestedManyWithoutManagersParInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteCreateOrConnectWithoutDemandesCongesInput = {
    where: CompteWhereUniqueInput
    create: XOR<CompteCreateWithoutDemandesCongesInput, CompteUncheckedCreateWithoutDemandesCongesInput>
  }

  export type CollaborateurCreateWithoutDemandesCongesInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementCreateNestedManyWithoutCollaborateurInput
    compte?: CompteCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactCreateNestedManyWithoutCollaborateursInput
    salarie?: SalarieCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateWithoutDemandesCongesInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementUncheckedCreateNestedManyWithoutCollaborateurInput
    compte?: CompteUncheckedCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactUncheckedCreateNestedManyWithoutCollaborateursInput
    salarie?: SalarieUncheckedCreateNestedOneWithoutCollaborateurInput
    ficheDePoste?: FicheDePosteUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurCreateOrConnectWithoutDemandesCongesInput = {
    where: CollaborateurWhereUniqueInput
    create: XOR<CollaborateurCreateWithoutDemandesCongesInput, CollaborateurUncheckedCreateWithoutDemandesCongesInput>
  }

  export type NotificationCreateWithoutDemandeCongeInput = {
    id?: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
    utilisateur: CompteCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutDemandeCongeInput = {
    id?: string
    utilisateurId: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
  }

  export type NotificationCreateOrConnectWithoutDemandeCongeInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutDemandeCongeInput, NotificationUncheckedCreateWithoutDemandeCongeInput>
  }

  export type NotificationCreateManyDemandeCongeInputEnvelope = {
    data: NotificationCreateManyDemandeCongeInput | NotificationCreateManyDemandeCongeInput[]
    skipDuplicates?: boolean
  }

  export type CompteUpsertWithoutDemandesCongesInput = {
    update: XOR<CompteUpdateWithoutDemandesCongesInput, CompteUncheckedUpdateWithoutDemandesCongesInput>
    create: XOR<CompteCreateWithoutDemandesCongesInput, CompteUncheckedCreateWithoutDemandesCongesInput>
    where?: CompteWhereInput
  }

  export type CompteUpdateToOneWithWhereWithoutDemandesCongesInput = {
    where?: CompteWhereInput
    data: XOR<CompteUpdateWithoutDemandesCongesInput, CompteUncheckedUpdateWithoutDemandesCongesInput>
  }

  export type CompteUpdateWithoutDemandesCongesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateur?: CollaborateurUpdateOneRequiredWithoutCompteNestedInput
    collaborateursGeres?: CollaborateurUpdateManyWithoutManagersParNestedInput
    contacts?: ContactUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUncheckedUpdateWithoutDemandesCongesInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    collaborateurId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursGeres?: CollaborateurUncheckedUpdateManyWithoutManagersParNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type CollaborateurUpsertWithoutDemandesCongesInput = {
    update: XOR<CollaborateurUpdateWithoutDemandesCongesInput, CollaborateurUncheckedUpdateWithoutDemandesCongesInput>
    create: XOR<CollaborateurCreateWithoutDemandesCongesInput, CollaborateurUncheckedCreateWithoutDemandesCongesInput>
    where?: CollaborateurWhereInput
  }

  export type CollaborateurUpdateToOneWithWhereWithoutDemandesCongesInput = {
    where?: CollaborateurWhereInput
    data: XOR<CollaborateurUpdateWithoutDemandesCongesInput, CollaborateurUncheckedUpdateWithoutDemandesCongesInput>
  }

  export type CollaborateurUpdateWithoutDemandesCongesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUpdateManyWithoutCollaborateursNestedInput
    salarie?: SalarieUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateWithoutDemandesCongesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUncheckedUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUncheckedUpdateManyWithoutCollaborateursNestedInput
    salarie?: SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutDemandeCongeInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutDemandeCongeInput, NotificationUncheckedUpdateWithoutDemandeCongeInput>
    create: XOR<NotificationCreateWithoutDemandeCongeInput, NotificationUncheckedCreateWithoutDemandeCongeInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutDemandeCongeInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutDemandeCongeInput, NotificationUncheckedUpdateWithoutDemandeCongeInput>
  }

  export type NotificationUpdateManyWithWhereWithoutDemandeCongeInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutDemandeCongeInput>
  }

  export type CompteCreateWithoutNotificationsInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    createdAt?: Date | string
    collaborateur: CollaborateurCreateNestedOneWithoutCompteInput
    collaborateursGeres?: CollaborateurCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteUncheckedCreateWithoutNotificationsInput = {
    id?: string
    identifiant: string
    motDePasse: string
    role: $Enums.Role
    collaborateurId: string
    createdAt?: Date | string
    collaborateursGeres?: CollaborateurUncheckedCreateNestedManyWithoutManagersParInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutUtilisateurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type CompteCreateOrConnectWithoutNotificationsInput = {
    where: CompteWhereUniqueInput
    create: XOR<CompteCreateWithoutNotificationsInput, CompteUncheckedCreateWithoutNotificationsInput>
  }

  export type DemandeCongeCreateWithoutNotificationsInput = {
    id?: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
    utilisateur: CompteCreateNestedOneWithoutDemandesCongesInput
    collaborateur: CollaborateurCreateNestedOneWithoutDemandesCongesInput
  }

  export type DemandeCongeUncheckedCreateWithoutNotificationsInput = {
    id?: string
    utilisateurId: string
    collaborateurId: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
  }

  export type DemandeCongeCreateOrConnectWithoutNotificationsInput = {
    where: DemandeCongeWhereUniqueInput
    create: XOR<DemandeCongeCreateWithoutNotificationsInput, DemandeCongeUncheckedCreateWithoutNotificationsInput>
  }

  export type CompteUpsertWithoutNotificationsInput = {
    update: XOR<CompteUpdateWithoutNotificationsInput, CompteUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CompteCreateWithoutNotificationsInput, CompteUncheckedCreateWithoutNotificationsInput>
    where?: CompteWhereInput
  }

  export type CompteUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CompteWhereInput
    data: XOR<CompteUpdateWithoutNotificationsInput, CompteUncheckedUpdateWithoutNotificationsInput>
  }

  export type CompteUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateur?: CollaborateurUpdateOneRequiredWithoutCompteNestedInput
    collaborateursGeres?: CollaborateurUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    collaborateurId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursGeres?: CollaborateurUncheckedUpdateManyWithoutManagersParNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type DemandeCongeUpsertWithoutNotificationsInput = {
    update: XOR<DemandeCongeUpdateWithoutNotificationsInput, DemandeCongeUncheckedUpdateWithoutNotificationsInput>
    create: XOR<DemandeCongeCreateWithoutNotificationsInput, DemandeCongeUncheckedCreateWithoutNotificationsInput>
    where?: DemandeCongeWhereInput
  }

  export type DemandeCongeUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: DemandeCongeWhereInput
    data: XOR<DemandeCongeUpdateWithoutNotificationsInput, DemandeCongeUncheckedUpdateWithoutNotificationsInput>
  }

  export type DemandeCongeUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
    utilisateur?: CompteUpdateOneRequiredWithoutDemandesCongesNestedInput
    collaborateur?: CollaborateurUpdateOneRequiredWithoutDemandesCongesNestedInput
  }

  export type DemandeCongeUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateurId?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CollaborateurCreateWithoutFicheDePosteInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementCreateNestedManyWithoutCollaborateurInput
    compte?: CompteCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurUncheckedCreateWithoutFicheDePosteInput = {
    id?: string
    nom: string
    couleur: string
    entreprise: string
    aCompte?: boolean
    createdAt?: Date | string
    evenements?: EvenementUncheckedCreateNestedManyWithoutCollaborateurInput
    compte?: CompteUncheckedCreateNestedOneWithoutCollaborateurInput
    managersPar?: CompteUncheckedCreateNestedManyWithoutCollaborateursGeresInput
    contactsGeres?: ContactUncheckedCreateNestedManyWithoutCollaborateursInput
    demandesConges?: DemandeCongeUncheckedCreateNestedManyWithoutCollaborateurInput
    salarie?: SalarieUncheckedCreateNestedOneWithoutCollaborateurInput
  }

  export type CollaborateurCreateOrConnectWithoutFicheDePosteInput = {
    where: CollaborateurWhereUniqueInput
    create: XOR<CollaborateurCreateWithoutFicheDePosteInput, CollaborateurUncheckedCreateWithoutFicheDePosteInput>
  }

  export type CollaborateurUpsertWithoutFicheDePosteInput = {
    update: XOR<CollaborateurUpdateWithoutFicheDePosteInput, CollaborateurUncheckedUpdateWithoutFicheDePosteInput>
    create: XOR<CollaborateurCreateWithoutFicheDePosteInput, CollaborateurUncheckedCreateWithoutFicheDePosteInput>
    where?: CollaborateurWhereInput
  }

  export type CollaborateurUpdateToOneWithWhereWithoutFicheDePosteInput = {
    where?: CollaborateurWhereInput
    data: XOR<CollaborateurUpdateWithoutFicheDePosteInput, CollaborateurUncheckedUpdateWithoutFicheDePosteInput>
  }

  export type CollaborateurUpdateWithoutFicheDePosteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateWithoutFicheDePosteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUncheckedUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput
    contactsGeres?: ContactUncheckedUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type EvenementCreateManyCollaborateurInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    typeEvenement: string
    lieuChantier?: string | null
    zoneTrajet?: string | null
    panierRepas?: boolean
    ticketRestaurant?: boolean
    heuresSupplementaires?: number
    grandDeplacement?: boolean
    prgd?: boolean
    nombrePrgd?: number
    typeAbsence?: string | null
    verrouille?: boolean
    latitude?: number | null
    longitude?: number | null
    adresseComplete?: string | null
    createdAt?: Date | string
  }

  export type DemandeCongeCreateManyCollaborateurInput = {
    id?: string
    utilisateurId: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
  }

  export type EvenementUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvenement?: StringFieldUpdateOperationsInput | string
    lieuChantier?: NullableStringFieldUpdateOperationsInput | string | null
    zoneTrajet?: NullableStringFieldUpdateOperationsInput | string | null
    panierRepas?: BoolFieldUpdateOperationsInput | boolean
    ticketRestaurant?: BoolFieldUpdateOperationsInput | boolean
    heuresSupplementaires?: FloatFieldUpdateOperationsInput | number
    grandDeplacement?: BoolFieldUpdateOperationsInput | boolean
    prgd?: BoolFieldUpdateOperationsInput | boolean
    nombrePrgd?: IntFieldUpdateOperationsInput | number
    typeAbsence?: NullableStringFieldUpdateOperationsInput | string | null
    verrouille?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    adresseComplete?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementUncheckedUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvenement?: StringFieldUpdateOperationsInput | string
    lieuChantier?: NullableStringFieldUpdateOperationsInput | string | null
    zoneTrajet?: NullableStringFieldUpdateOperationsInput | string | null
    panierRepas?: BoolFieldUpdateOperationsInput | boolean
    ticketRestaurant?: BoolFieldUpdateOperationsInput | boolean
    heuresSupplementaires?: FloatFieldUpdateOperationsInput | number
    grandDeplacement?: BoolFieldUpdateOperationsInput | boolean
    prgd?: BoolFieldUpdateOperationsInput | boolean
    nombrePrgd?: IntFieldUpdateOperationsInput | number
    typeAbsence?: NullableStringFieldUpdateOperationsInput | string | null
    verrouille?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    adresseComplete?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementUncheckedUpdateManyWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    typeEvenement?: StringFieldUpdateOperationsInput | string
    lieuChantier?: NullableStringFieldUpdateOperationsInput | string | null
    zoneTrajet?: NullableStringFieldUpdateOperationsInput | string | null
    panierRepas?: BoolFieldUpdateOperationsInput | boolean
    ticketRestaurant?: BoolFieldUpdateOperationsInput | boolean
    heuresSupplementaires?: FloatFieldUpdateOperationsInput | number
    grandDeplacement?: BoolFieldUpdateOperationsInput | boolean
    prgd?: BoolFieldUpdateOperationsInput | boolean
    nombrePrgd?: IntFieldUpdateOperationsInput | number
    typeAbsence?: NullableStringFieldUpdateOperationsInput | string | null
    verrouille?: BoolFieldUpdateOperationsInput | boolean
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    adresseComplete?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompteUpdateWithoutCollaborateursGeresInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateur?: CollaborateurUpdateOneRequiredWithoutCompteNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUncheckedUpdateWithoutCollaborateursGeresInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    collaborateurId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutUtilisateurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type CompteUncheckedUpdateManyWithoutCollaborateursGeresInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifiant?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    collaborateurId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutCollaborateursInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    utilisateur?: CompteUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutCollaborateursInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateManyWithoutCollaborateursInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DemandeCongeUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
    utilisateur?: CompteUpdateOneRequiredWithoutDemandesCongesNestedInput
    notifications?: NotificationUpdateManyWithoutDemandeCongeNestedInput
  }

  export type DemandeCongeUncheckedUpdateWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationUncheckedUpdateManyWithoutDemandeCongeNestedInput
  }

  export type DemandeCongeUncheckedUpdateManyWithoutCollaborateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DemandeCongeCreateManyUtilisateurInput = {
    id?: string
    collaborateurId: string
    collaborateurNom: string
    dateDebut: Date | string
    dateFin: Date | string
    typeConge: string
    motif: string
    statut: string
    commentaireAdmin?: string | null
    dateCreation: Date | string
    dateModification: Date | string
    notificationLue?: boolean
  }

  export type ContactCreateManyUtilisateurInput = {
    id?: string
    nom: string
    prenom: string
    email: string
    telephone: string
    adresse: string
    codePostal: string
    ville: string
    categories?: ContactCreatecategoriesInput | string[]
    status: string
    commentaires?: string | null
    dateCreation: Date | string
    dateDerniereModification: Date | string
    collaborateursIds?: ContactCreatecollaborateursIdsInput | string[]
    montantDevis?: number | null
    archived?: boolean
    archiveDate?: Date | string | null
  }

  export type NotificationCreateManyUtilisateurInput = {
    id?: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
    demandeId?: string | null
  }

  export type CollaborateurUpdateWithoutManagersParInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUpdateOneWithoutCollaborateurNestedInput
    contactsGeres?: ContactUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateWithoutManagersParInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUncheckedUpdateOneWithoutCollaborateurNestedInput
    contactsGeres?: ContactUncheckedUpdateManyWithoutCollaborateursNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateManyWithoutManagersParInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DemandeCongeUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
    collaborateur?: CollaborateurUpdateOneRequiredWithoutDemandesCongesNestedInput
    notifications?: NotificationUpdateManyWithoutDemandeCongeNestedInput
  }

  export type DemandeCongeUncheckedUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    collaborateurId?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationUncheckedUpdateManyWithoutDemandeCongeNestedInput
  }

  export type DemandeCongeUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    collaborateurId?: StringFieldUpdateOperationsInput | string
    collaborateurNom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    typeConge?: StringFieldUpdateOperationsInput | string
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    commentaireAdmin?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateModification?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationLue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborateurs?: CollaborateurUpdateManyWithoutContactsGeresNestedInput
  }

  export type ContactUncheckedUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collaborateurs?: CollaborateurUncheckedUpdateManyWithoutContactsGeresNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    categories?: ContactUpdatecategoriesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    dateDerniereModification?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborateursIds?: ContactUpdatecollaborateursIdsInput | string[]
    montantDevis?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    demandeConge?: DemandeCongeUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    demandeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    demandeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollaborateurUpdateWithoutContactsGeresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUpdateManyWithoutCollaborateursGeresNestedInput
    demandesConges?: DemandeCongeUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateWithoutContactsGeresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evenements?: EvenementUncheckedUpdateManyWithoutCollaborateurNestedInput
    compte?: CompteUncheckedUpdateOneWithoutCollaborateurNestedInput
    managersPar?: CompteUncheckedUpdateManyWithoutCollaborateursGeresNestedInput
    demandesConges?: DemandeCongeUncheckedUpdateManyWithoutCollaborateurNestedInput
    salarie?: SalarieUncheckedUpdateOneWithoutCollaborateurNestedInput
    ficheDePoste?: FicheDePosteUncheckedUpdateOneWithoutCollaborateurNestedInput
  }

  export type CollaborateurUncheckedUpdateManyWithoutContactsGeresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    couleur?: StringFieldUpdateOperationsInput | string
    entreprise?: StringFieldUpdateOperationsInput | string
    aCompte?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyDemandeCongeInput = {
    id?: string
    utilisateurId: string
    message: string
    lien: string
    dateCreation: Date | string
    lue?: boolean
    type: string
  }

  export type NotificationUpdateWithoutDemandeCongeInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    utilisateur?: CompteUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutDemandeCongeInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutDemandeCongeInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    lien?: StringFieldUpdateOperationsInput | string
    dateCreation?: DateTimeFieldUpdateOperationsInput | Date | string
    lue?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}